{"version":3,"sources":["asynciterable/race.ts"],"names":[],"mappings":";;AAAA,qDAAkD;AAElD,MAAM,iBAA2B,SAAQ,+BAAuB;IAI9D,YAAY,IAA4B,EAAE,KAA6B;QACrE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;IACtB,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC;QAC3B,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,EAC/C,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;QAChD,IAAI,aAAqC,CAAC;QAC1C,IAAI,cAAsC,CAAC;QAC3C,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC;YACzC,MAAM,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;gBACrB,IAAI,CAAC,cAAc,EAAE;oBACnB,cAAc,GAAG,MAAM,CAAC;oBACxB,aAAa,GAAG,OAAO,CAAC;iBACzB;gBACD,OAAO,CAAC,CAAC;YACX,CAAC,CAAC;YACF,OAAO,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;gBACtB,IAAI,CAAC,cAAc,EAAE;oBACnB,cAAc,GAAG,OAAO,CAAC;oBACzB,aAAa,GAAG,MAAM,CAAC;iBACxB;gBACD,OAAO,CAAC,CAAC;YACX,CAAC,CAAC;SACH,CAAC,CAAC;QAEH,IAAI,CAAC,IAAI,EAAE;YACT,MAAM,KAAK,CAAC;SACb;QAED,aAAa,GAAG,aAAc,CAAC;QAC/B,cAAc,GAAG,cAAe,CAAC;QAEjC,+BAA+B;QAC/B,IAAI,aAAa,CAAC,MAAM,EAAE;YACxB,MAAM,aAAa,CAAC,MAAO,EAAE,CAAC;SAC/B;QAED,IAAI,IAAI,CAAC;QACT,OAAO,CAAC,CAAC,IAAI,GAAG,MAAM,cAAc,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE;YACjD,MAAM,IAAI,CAAC,KAAK,CAAC;SAClB;IACH,CAAC;CACF;AAED;;;;;GAKG;AACH,SAAgB,IAAI,CAClB,IAA4B,EAC5B,KAA6B;IAE7B,OAAO,IAAI,iBAAiB,CAAU,IAAI,EAAE,KAAK,CAAC,CAAC;AACrD,CAAC;AALD,oBAKC","file":"race.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\n\nclass RaceAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _left: AsyncIterable<TSource>;\n  private _right: AsyncIterable<TSource>;\n\n  constructor(left: AsyncIterable<TSource>, right: AsyncIterable<TSource>) {\n    super();\n    this._left = left;\n    this._right = right;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    const leftIt = this._left[Symbol.asyncIterator](),\n      rightIt = this._right[Symbol.asyncIterator]();\n    let otherIterator: AsyncIterator<TSource>;\n    let resultIterator: AsyncIterator<TSource>;\n    const { value, done } = await Promise.race([\n      leftIt.next().then(x => {\n        if (!resultIterator) {\n          resultIterator = leftIt;\n          otherIterator = rightIt;\n        }\n        return x;\n      }),\n      rightIt.next().then(x => {\n        if (!resultIterator) {\n          resultIterator = rightIt;\n          otherIterator = leftIt;\n        }\n        return x;\n      })\n    ]);\n\n    if (!done) {\n      yield value;\n    }\n\n    otherIterator = otherIterator!;\n    resultIterator = resultIterator!;\n\n    // Cancel/finish other iterator\n    if (otherIterator.return) {\n      await otherIterator.return!();\n    }\n\n    let next;\n    while (!(next = await resultIterator.next()).done) {\n      yield next.value;\n    }\n  }\n}\n\n/**\n * Propagates the async sequence that reacts first.\n * @param {AsyncIterable<T>} left First async sequence.\n * @param {AsyncIterable<T>} right Second async sequence.\n * @return {AsyncIterable<T>} An async sequence that surfaces either of the given sequences, whichever reacted first.\n */\nexport function race<TSource>(\n  left: AsyncIterable<TSource>,\n  right: AsyncIterable<TSource>\n): AsyncIterableX<TSource> {\n  return new RaceAsyncIterable<TSource>(left, right);\n}\n"]}