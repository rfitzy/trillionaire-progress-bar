import { AsyncIterableX } from './asynciterablex';
export declare class GroupedAsyncIterable<TKey, TValue> extends AsyncIterableX<TValue> {
    readonly key: TKey;
    private _source;
    constructor(key: TKey, source: Iterable<TValue>);
    [Symbol.asyncIterator](): AsyncIterableIterator<TValue>;
}
export declare class GroupByAsyncIterable<TSource, TKey, TValue, TResult> extends AsyncIterableX<TResult> {
    private _source;
    private _keySelector;
    private _elementSelector;
    private _resultSelector;
    constructor(source: AsyncIterable<TSource>, keySelector: (value: TSource) => TKey | Promise<TKey>, elementSelector: (value: TSource) => TValue | Promise<TValue>, resultSelector: (key: TKey, values: Iterable<TValue>) => TResult | Promise<TResult>);
    [Symbol.asyncIterator](): AsyncIterableIterator<TResult>;
}
export declare function groupByResultIdentityAsync<TKey, TValue>(key: TKey, values: Iterable<TValue>): any;
export declare function groupBy<TSource, TKey>(source: AsyncIterable<TSource>, keySelector: (value: TSource) => TKey | Promise<TKey>): AsyncIterableX<GroupedAsyncIterable<TKey, TSource>>;
export declare function groupBy<TSource, TKey, TValue>(source: AsyncIterable<TSource>, keySelector: (value: TSource) => TKey | Promise<TKey>, elementSelector?: (value: TSource) => TValue | Promise<TValue>): AsyncIterableX<GroupedAsyncIterable<TKey, TValue>>;
export declare function groupBy<TSource, TKey, TValue, TResult>(source: AsyncIterable<TSource>, keySelector: (value: TSource) => TKey | Promise<TKey>, elementSelector?: (value: TSource) => TValue | Promise<TValue>, resultSelector?: (key: TKey, values: Iterable<TValue>) => TResult | Promise<TResult>): AsyncIterableX<TResult>;
