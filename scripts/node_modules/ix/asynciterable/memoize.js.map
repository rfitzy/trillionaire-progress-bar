{"version":3,"sources":["asynciterable/memoize.ts"],"names":[],"mappings":";;AAAA,qDAAkD;AAClD,6DAAyF;AACzF,qCAAkC;AAElC,MAAa,kBAAsB,SAAQ,+BAAiB;IAO1D,YAAY,MAAwB,EAAE,MAAwB;QAC5D,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QACtB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IACxB,CAAC;IAED,CAAC,MAAM,CAAC,aAAa,CAAC;QACpB,OAAO,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;IAC9B,CAAC;IAES,KAAK,CAAC,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC;QACtC,IAAI,CAAC,GAAG,MAAM,GAAG,CAAC,CAAC;QACnB,IAAI,IAAI,GAAY,KAAK,CAAC;QAC1B,IAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC;QAE1B,IAAI;YACF,GAAG;gBACD,IAAI,EAAE,CAAC,GAAG,MAAM,CAAC,KAAK,EAAE;oBACtB,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBACpB,SAAS;iBACV;gBAED,IAAI,IAAI,CAAC,QAAQ,EAAE;oBACjB,MAAM,IAAI,CAAC,MAAM,CAAC;iBACnB;gBAED,IAAI,IAAI,CAAC,OAAO,KAAK,IAAI,EAAE;oBACzB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;wBAC1C,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;wBACpB,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE;4BACX,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;yBACtB;wBACD,OAAO,CAAC,CAAC;oBACX,CAAC,CAAC,CAAC;iBACJ;gBAED,CAAC,EAAE,IAAI,EAAE,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;oBACvC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;oBAChB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;oBACrB,MAAM,CAAC,CAAC;gBACV,CAAC,CAAC,CAAC,CAAC;gBAEJ,IAAI,CAAC,IAAI,EAAE;oBACT,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;iBACrB;aACF,QAAQ,CAAC,IAAI,EAAE;SACjB;gBAAS;YACR,MAAM,CAAC,IAAI,EAAE,CAAC;SACf;IACH,CAAC;CACF;AA5DD,gDA4DC;AAWD,SAAgB,OAAO,CACrB,MAA8B,EAC9B,cAAsB,CAAC,CAAC,EACxB,QAAoE;IAEpE,IAAI,CAAC,QAAQ,EAAE;QACb,OAAO,WAAW,KAAK,CAAC,CAAC;YACvB,CAAC,CAAC,IAAI,kBAAkB,CACpB,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,EAC9B,IAAI,+BAAe,EAAW,CAC/B;YACH,CAAC,CAAC,IAAI,kBAAkB,CACpB,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,EAC9B,IAAI,4BAAY,CAAU,WAAW,CAAC,CACvC,CAAC;KACP;IACD,OAAO,eAAM,CAAoB,GAAG,EAAE,CACpC,QAAS,CAAC,OAAO,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAChE,CAAC;AACJ,CAAC;AAnBD,0BAmBC","file":"memoize.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\nimport { IRefCountList, MaxRefCountList, RefCountList } from '../iterable/_refcountlist';\nimport { create } from './create';\n\nexport class MemoizeAsyncBuffer<T> extends AsyncIterableX<T> {\n  protected _source: AsyncIterator<T>;\n  protected _buffer: IRefCountList<T>;\n  protected _shared: Promise<IteratorResult<T>> | null;\n  protected _error: any;\n  protected _stopped: boolean;\n\n  constructor(source: AsyncIterator<T>, buffer: IRefCountList<T>) {\n    super();\n    this._error = null;\n    this._shared = null;\n    this._stopped = false;\n    this._source = source;\n    this._buffer = buffer;\n  }\n\n  [Symbol.asyncIterator]() {\n    return this._getIterable(0);\n  }\n\n  protected async *_getIterable(offset = 0) {\n    let i = offset - 1;\n    let done: boolean = false;\n    let buffer = this._buffer;\n\n    try {\n      do {\n        if (++i < buffer.count) {\n          yield buffer.get(i);\n          continue;\n        }\n\n        if (this._stopped) {\n          throw this._error;\n        }\n\n        if (this._shared === null) {\n          this._shared = this._source.next().then(r => {\n            this._shared = null;\n            if (!r.done) {\n              buffer.push(r.value);\n            }\n            return r;\n          });\n        }\n\n        ({ done } = await this._shared.catch(e => {\n          this._error = e;\n          this._stopped = true;\n          throw e;\n        }));\n\n        if (!done) {\n          yield buffer.get(i);\n        }\n      } while (!done);\n    } finally {\n      buffer.done();\n    }\n  }\n}\n\nexport function memoize<TSource>(\n  source: AsyncIterable<TSource>,\n  readerCount?: number\n): AsyncIterableX<TSource>;\nexport function memoize<TSource, TResult>(\n  source: AsyncIterable<TSource>,\n  readerCount?: number,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): AsyncIterableX<TResult>;\nexport function memoize<TSource, TResult = TSource>(\n  source: AsyncIterable<TSource>,\n  readerCount: number = -1,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): AsyncIterableX<TSource | TResult> {\n  if (!selector) {\n    return readerCount === -1\n      ? new MemoizeAsyncBuffer<TSource>(\n          source[Symbol.asyncIterator](),\n          new MaxRefCountList<TSource>()\n        )\n      : new MemoizeAsyncBuffer<TSource>(\n          source[Symbol.asyncIterator](),\n          new RefCountList<TSource>(readerCount)\n        );\n  }\n  return create<TSource | TResult>(() =>\n    selector!(memoize(source, readerCount))[Symbol.asyncIterator]()\n  );\n}\n"]}