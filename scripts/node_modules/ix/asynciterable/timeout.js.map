{"version":3,"sources":["asynciterable/timeout.ts"],"names":[],"mappings":";;AAAA,qDAAkD;AAClD,qCAAiC;AAEjC,MAAa,YAAa,SAAQ,KAAK;IACrC;QACE,KAAK,EAAE,CAAC;QACR,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,YAAY,CAAC,SAAS,CAAC,CAAC;QACpD,IAAI,CAAC,OAAO,GAAG,sBAAsB,CAAC;IACxC,CAAC;CACF;AAND,oCAMC;AAED,MAAM,UAAU,GAAG,OAAO,CAAC;AAC3B,MAAM,UAAU,GAAG,OAAO,CAAC;AAO3B,MAAa,oBAA8B,SAAQ,+BAAuB;IAIxE,YAAY,MAA8B,EAAE,OAAe;QACzD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;IAC1B,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC;QAC3B,MAAM,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;QAChD,OAAO,CAAC,EAAE;YACR,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,OAAO,CAAC,IAAI,CAA4B;gBACpE,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;oBACrB,OAAO,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC;gBACrC,CAAC,CAAC;gBACF,cAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE;oBAC7B,OAAO,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC;gBAC9B,CAAC,CAAC;aACH,CAAC,CAAC;YAEH,IAAI,IAAI,KAAK,UAAU,EAAE;gBACvB,MAAM,IAAI,YAAY,EAAE,CAAC;aAC1B;YAED,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,IAAI,EAAE;gBACxB,MAAM;aACP;YACD,MAAM,KAAK,CAAC,KAAK,CAAC;SACnB;IACH,CAAC;CACF;AAhCD,oDAgCC;AAED,SAAgB,OAAO,CACrB,MAA8B,EAC9B,OAAe;IAEf,OAAO,IAAI,oBAAoB,CAAU,MAAM,EAAE,OAAO,CAAC,CAAC;AAC5D,CAAC;AALD,0BAKC","file":"timeout.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\nimport { sleep } from './_sleep';\n\nexport class TimeoutError extends Error {\n  constructor() {\n    super();\n    Object.setPrototypeOf(this, TimeoutError.prototype);\n    this.message = 'Timeout has occurred';\n  }\n}\n\nconst VALUE_TYPE = 'value';\nconst ERROR_TYPE = 'error';\n\ninterface TimeoutOperation<T> {\n  type: string;\n  value?: IteratorResult<T>;\n}\n\nexport class TimeoutAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _dueTime: number;\n\n  constructor(source: AsyncIterable<TSource>, dueTime: number) {\n    super();\n    this._source = source;\n    this._dueTime = dueTime;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    const it = this._source[Symbol.asyncIterator]();\n    while (1) {\n      const { type, value } = await Promise.race<TimeoutOperation<TSource>>([\n        it.next().then(value => {\n          return { type: VALUE_TYPE, value };\n        }),\n        sleep(this._dueTime).then(() => {\n          return { type: ERROR_TYPE };\n        })\n      ]);\n\n      if (type === ERROR_TYPE) {\n        throw new TimeoutError();\n      }\n\n      if (!value || value.done) {\n        break;\n      }\n      yield value.value;\n    }\n  }\n}\n\nexport function timeout<TSource>(\n  source: AsyncIterable<TSource>,\n  dueTime: number\n): AsyncIterableX<TSource> {\n  return new TimeoutAsyncIterable<TSource>(source, dueTime);\n}\n"]}