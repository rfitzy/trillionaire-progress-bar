{"version":3,"sources":["asynciterable/reduce.ts"],"names":[],"mappings":"AAUA,MAAM,CAAC,KAAK,UAAU,MAAM,CAC1B,MAAwB,EACxB,WAAwF,EACxF,GAAG,IAAS;IAEZ,MAAM,OAAO,GAAG,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC;IAClC,IAAI,CAAC,GAAG,CAAC,EACP,QAAQ,GAAG,KAAK,EAChB,GAAG,GAAG,IAAI,CAAC,CAAC,CAAU,CAAC;IACzB,IAAI,KAAK,EAAE,IAAI,IAAI,IAAI,MAAM,EAAE;QAC7B,IAAI,QAAQ,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,EAAE;YACpC,GAAG,GAAG,MAAM,WAAW,CAAI,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;SAC5C;aAAM;YACL,GAAG,GAAG,IAAI,CAAC;YACX,QAAQ,GAAG,IAAI,CAAC;YAChB,CAAC,EAAE,CAAC;SACL;KACF;IAED,IAAI,CAAC,CAAC,OAAO,IAAI,QAAQ,CAAC,EAAE;QAC1B,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;KAClD;IAED,OAAO,GAAQ,CAAC;AAClB,CAAC","file":"reduce.js","sourcesContent":["export async function reduce<T, R = T>(\n  source: AsyncIterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: never[]\n): Promise<R>;\nexport async function reduce<T, R = T>(\n  source: AsyncIterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: R\n): Promise<R>;\nexport async function reduce<T, R = T>(\n  source: AsyncIterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  ...seed: R[]\n): Promise<R> {\n  const hasSeed = seed.length === 1;\n  let i = 0,\n    hasValue = false,\n    acc = seed[0] as T | R;\n  for await (let item of source) {\n    if (hasValue || (hasValue = hasSeed)) {\n      acc = await accumulator(<R>acc, item, i++);\n    } else {\n      acc = item;\n      hasValue = true;\n      i++;\n    }\n  }\n\n  if (!(hasSeed || hasValue)) {\n    throw new Error('Sequence contains no elements');\n  }\n\n  return acc as R;\n}\n"]}