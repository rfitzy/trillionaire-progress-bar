import { AsyncIterableX } from './asynciterablex';
import { returnAsyncIterator } from '../internal/returniterator';
export class CatchWithAsyncIterable extends AsyncIterableX {
    constructor(source, handler) {
        super();
        this._source = source;
        this._handler = handler;
    }
    async *[Symbol.asyncIterator]() {
        let err, hasError = false, it = this._source[Symbol.asyncIterator]();
        while (1) {
            let c = {};
            try {
                c = await it.next();
                if (c.done) {
                    await returnAsyncIterator(it);
                    break;
                }
            }
            catch (e) {
                err = await this._handler(e);
                hasError = true;
                await returnAsyncIterator(it);
                break;
            }
            yield c.value;
        }
        if (hasError) {
            for await (let item of err) {
                yield item;
            }
        }
    }
}
export function catchWith(source, handler) {
    return new CatchWithAsyncIterable(source, handler);
}

//# sourceMappingURL=catchwith.mjs.map
