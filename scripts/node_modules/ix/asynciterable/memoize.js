"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const asynciterablex_1 = require("./asynciterablex");
const _refcountlist_1 = require("../iterable/_refcountlist");
const create_1 = require("./create");
class MemoizeAsyncBuffer extends asynciterablex_1.AsyncIterableX {
    constructor(source, buffer) {
        super();
        this._error = null;
        this._shared = null;
        this._stopped = false;
        this._source = source;
        this._buffer = buffer;
    }
    [Symbol.asyncIterator]() {
        return this._getIterable(0);
    }
    async *_getIterable(offset = 0) {
        let i = offset - 1;
        let done = false;
        let buffer = this._buffer;
        try {
            do {
                if (++i < buffer.count) {
                    yield buffer.get(i);
                    continue;
                }
                if (this._stopped) {
                    throw this._error;
                }
                if (this._shared === null) {
                    this._shared = this._source.next().then(r => {
                        this._shared = null;
                        if (!r.done) {
                            buffer.push(r.value);
                        }
                        return r;
                    });
                }
                ({ done } = await this._shared.catch(e => {
                    this._error = e;
                    this._stopped = true;
                    throw e;
                }));
                if (!done) {
                    yield buffer.get(i);
                }
            } while (!done);
        }
        finally {
            buffer.done();
        }
    }
}
exports.MemoizeAsyncBuffer = MemoizeAsyncBuffer;
function memoize(source, readerCount = -1, selector) {
    if (!selector) {
        return readerCount === -1
            ? new MemoizeAsyncBuffer(source[Symbol.asyncIterator](), new _refcountlist_1.MaxRefCountList())
            : new MemoizeAsyncBuffer(source[Symbol.asyncIterator](), new _refcountlist_1.RefCountList(readerCount));
    }
    return create_1.create(() => selector(memoize(source, readerCount))[Symbol.asyncIterator]());
}
exports.memoize = memoize;

//# sourceMappingURL=memoize.js.map
