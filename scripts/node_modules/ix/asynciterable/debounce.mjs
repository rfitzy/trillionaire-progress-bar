import { AsyncIterableX } from './asynciterablex';
async function forEach(source, fn) {
    for await (const item of source) {
        await fn(item);
    }
}
export class DebounceAsyncIterable extends AsyncIterableX {
    constructor(source, time) {
        super();
        this._source = source;
        this._time = time;
    }
    async *[Symbol.asyncIterator]() {
        let noValue;
        let lastItem;
        let deferred;
        let resolver;
        let done = false;
        let hasError = false;
        let error;
        const reset = (hasNoValue) => {
            noValue = hasNoValue;
            lastItem = undefined;
            deferred = new Promise(r => (resolver = r));
        };
        const run = () => {
            if (lastItem === undefined) {
                noValue = true;
                return;
            }
            const item = lastItem;
            const res = resolver;
            reset(false);
            setTimeout(run, this._time);
            res(item);
        };
        reset(true);
        forEach(this._source, item => {
            lastItem = item;
            if (noValue) {
                run();
            }
        })
            .then(() => (done = true))
            .catch(err => {
            hasError = true;
            error = err;
        });
        while (1) {
            if (done) {
                break;
            }
            if (hasError) {
                throw error;
            }
            yield await deferred;
        }
    }
}
export function debounce(source, time) {
    return new DebounceAsyncIterable(source, time);
}

//# sourceMappingURL=debounce.mjs.map
