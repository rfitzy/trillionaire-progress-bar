{"version":3,"sources":["asynciterable/catchwith.ts"],"names":[],"mappings":";;AAAA,qDAAkD;AAClD,+DAAiE;AAEjE,MAAa,sBAAgC,SAAQ,+BAAuB;IAI1E,YACE,MAA8B,EAC9B,OAAiF;QAEjF,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;IAC1B,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC;QAC3B,IAAI,GAAuC,EACzC,QAAQ,GAAG,KAAK,EAChB,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;QAC5C,OAAO,CAAC,EAAE;YACR,IAAI,CAAC,GAA4B,EAAE,CAAC;YAEpC,IAAI;gBACF,CAAC,GAAG,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC;gBACpB,IAAI,CAAC,CAAC,IAAI,EAAE;oBACV,MAAM,oCAAmB,CAAC,EAAE,CAAC,CAAC;oBAC9B,MAAM;iBACP;aACF;YAAC,OAAO,CAAC,EAAE;gBACV,GAAG,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAC7B,QAAQ,GAAG,IAAI,CAAC;gBAChB,MAAM,oCAAmB,CAAC,EAAE,CAAC,CAAC;gBAC9B,MAAM;aACP;YAED,MAAM,CAAC,CAAC,KAAK,CAAC;SACf;QAED,IAAI,QAAQ,EAAE;YACZ,IAAI,KAAK,EAAE,IAAI,IAAI,IAAI,GAAI,EAAE;gBAC3B,MAAM,IAAI,CAAC;aACZ;SACF;IACH,CAAC;CACF;AA1CD,wDA0CC;AAED,SAAgB,SAAS,CACvB,MAA8B,EAC9B,OAAiF;IAEjF,OAAO,IAAI,sBAAsB,CAAU,MAAM,EAAE,OAAO,CAAC,CAAC;AAC9D,CAAC;AALD,8BAKC","file":"catchwith.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\nimport { returnAsyncIterator } from '../internal/returniterator';\n\nexport class CatchWithAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _handler: (error: any) => AsyncIterable<TSource> | Promise<AsyncIterable<TSource>>;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    handler: (error: any) => AsyncIterable<TSource> | Promise<AsyncIterable<TSource>>\n  ) {\n    super();\n    this._source = source;\n    this._handler = handler;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let err: AsyncIterable<TSource> | undefined,\n      hasError = false,\n      it = this._source[Symbol.asyncIterator]();\n    while (1) {\n      let c = <IteratorResult<TSource>>{};\n\n      try {\n        c = await it.next();\n        if (c.done) {\n          await returnAsyncIterator(it);\n          break;\n        }\n      } catch (e) {\n        err = await this._handler(e);\n        hasError = true;\n        await returnAsyncIterator(it);\n        break;\n      }\n\n      yield c.value;\n    }\n\n    if (hasError) {\n      for await (let item of err!) {\n        yield item;\n      }\n    }\n  }\n}\n\nexport function catchWith<TSource>(\n  source: AsyncIterable<TSource>,\n  handler: (error: any) => AsyncIterable<TSource> | Promise<AsyncIterable<TSource>>\n): AsyncIterableX<TSource> {\n  return new CatchWithAsyncIterable<TSource>(source, handler);\n}\n"]}