{"version":3,"sources":["asynciterable/pipe/groupby.ts"],"names":[],"mappings":";;AAEA,wCAAoG;AACpG,sDAAwD;AAcxD,SAAgB,OAAO,CACrB,WAAqD,EACrD,kBAAgE,wBAAa,EAC7E,iBAGkC,oCAA0B;IAE5D,OAAO,SAAS,uBAAuB,CAAC,MAA8B;QACpE,OAAO,IAAI,8BAAoB,CAC7B,MAAM,EACN,WAAW,EACX,eAAe,EACf,cAAc,CACf,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC;AAhBD,0BAgBC","file":"groupby.js","sourcesContent":["import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { GroupByAsyncIterable, GroupedAsyncIterable, groupByResultIdentityAsync } from '../groupby';\nimport { identityAsync } from '../../internal/identity';\n\nexport function groupBy<TSource, TKey>(\n  keySelector: (value: TSource) => TKey | Promise<TKey>\n): OperatorAsyncFunction<TSource, GroupedAsyncIterable<TKey, TSource>>;\nexport function groupBy<TSource, TKey, TValue>(\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (value: TSource) => TValue | Promise<TValue>\n): OperatorAsyncFunction<TSource, GroupedAsyncIterable<TKey, TValue>>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (value: TSource) => TValue | Promise<TValue>,\n  resultSelector?: (key: TKey, values: Iterable<TValue>) => TResult | Promise<TResult>\n): OperatorAsyncFunction<TSource, TResult>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector: (value: TSource) => TValue | Promise<TValue> = identityAsync,\n  resultSelector: (\n    key: TKey,\n    values: Iterable<TValue>\n  ) => TResult | Promise<TResult> = groupByResultIdentityAsync\n): OperatorAsyncFunction<TSource, TResult> {\n  return function groupByOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TResult> {\n    return new GroupByAsyncIterable<TSource, TKey, TValue, TResult>(\n      source,\n      keySelector,\n      elementSelector,\n      resultSelector\n    );\n  };\n}\n"]}