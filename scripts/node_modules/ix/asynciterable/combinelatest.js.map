{"version":3,"sources":["asynciterable/combinelatest.ts"],"names":[],"mappings":"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","file":"combinelatest.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\nimport { identity, identityAsync } from '../internal/identity';\n\n// tslint:disable-next-line:no-empty\nconst NEVER_PROMISE = new Promise(() => {});\n\ntype MergeResult<T> = { value: T; index: number };\n\nfunction wrapPromiseWithIndex<T>(promise: Promise<T>, index: number) {\n  return promise.then(value => ({ value, index })) as Promise<MergeResult<T>>;\n}\n\nexport class CombineLatestAsyncIterable<TSource, TResult> extends AsyncIterableX<TResult> {\n  private _sources: AsyncIterable<TSource>[];\n  private _fn: (values: any[]) => TResult | Promise<TResult>;\n\n  constructor(\n    sources: AsyncIterable<TSource>[],\n    fn: (values: any[]) => TResult | Promise<TResult>\n  ) {\n    super();\n    this._sources = sources;\n    this._fn = fn;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    const fn = this._fn;\n    const length = this._sources.length;\n    const iterators = new Array<AsyncIterator<TSource>>(length);\n    const nexts = new Array<Promise<MergeResult<IteratorResult<TSource>>>>(length);\n    let hasValueAll = false;\n    const values = new Array<TSource>(length);\n    const hasValues = new Array<boolean>(length);\n    let active = length;\n\n    hasValues.fill(false);\n\n    for (let i = 0; i < length; i++) {\n      const iterator = this._sources[i][Symbol.asyncIterator]();\n      iterators[i] = iterator;\n      nexts[i] = wrapPromiseWithIndex(iterator.next(), i);\n    }\n\n    while (active > 0) {\n      const next = Promise.race(nexts);\n      const { value: next$, index } = await next;\n      if (next$.done) {\n        nexts[index] = <Promise<MergeResult<IteratorResult<TSource>>>>NEVER_PROMISE;\n        active--;\n      } else {\n        values[index] = next$.value;\n        hasValues[index] = true;\n\n        const iterator$ = iterators[index];\n        nexts[index] = wrapPromiseWithIndex(iterator$.next(), index);\n\n        if (hasValueAll || (hasValueAll = hasValues.every(identity))) {\n          yield await fn(values);\n        }\n      }\n    }\n  }\n}\n\nexport function combineLatest<T, T2>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>\n): AsyncIterableX<[T, T2]>;\nexport function combineLatest<T, T2, T3>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): AsyncIterableX<[T, T2, T3]>;\nexport function combineLatest<T, T2, T3, T4>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): AsyncIterableX<[T, T2, T3, T4]>;\nexport function combineLatest<T, T2, T3, T4, T5>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): AsyncIterableX<[T, T2, T3, T4, T5]>;\nexport function combineLatest<T, T2, T3, T4, T5, T6>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): AsyncIterableX<[T, T2, T3, T4, T5, T6]>;\n\nexport function combineLatest<T, R>(\n  project: (values: [T]) => R | Promise<R>,\n  source: AsyncIterable<T>\n): AsyncIterableX<R>;\nexport function combineLatest<T, T2, R>(\n  project: (values: [T, T2]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>\n): AsyncIterableX<R>;\nexport function combineLatest<T, T2, T3, R>(\n  project: (values: [T, T2, T3]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): AsyncIterableX<R>;\nexport function combineLatest<T, T2, T3, T4, R>(\n  project: (values: [T, T2, T3, T4]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): AsyncIterableX<R>;\nexport function combineLatest<T, T2, T3, T4, T5, R>(\n  project: (values: [T, T2, T3, T4, T5]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): AsyncIterableX<R>;\nexport function combineLatest<T, T2, T3, T4, T5, T6, R>(\n  project: (values: [T, T2, T3, T4, T5, T6]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): AsyncIterableX<R>;\n\nexport function combineLatest<T>(...sources: AsyncIterable<T>[]): AsyncIterableX<T[]>;\nexport function combineLatest<T, R>(\n  project: (values: T[]) => R | Promise<R>,\n  ...sources: AsyncIterable<T>[]\n): AsyncIterableX<R>;\n/* tslint:enable:max-line-length */\nexport function combineLatest<T, R>(...sources: any[]): AsyncIterableX<R> {\n  let fn = (sources.shift() || identityAsync) as (values: any[]) => R | Promise<R>;\n  if (fn && typeof fn !== 'function') {\n    sources.unshift(fn);\n    fn = identityAsync;\n  }\n  return new CombineLatestAsyncIterable<T, R>(sources as AsyncIterable<T>[], fn);\n}\n"]}