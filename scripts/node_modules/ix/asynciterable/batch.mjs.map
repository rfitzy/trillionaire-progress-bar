{"version":3,"sources":["asynciterable/batch.ts"],"names":[],"mappings":"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","file":"batch.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\n\ninterface AsyncResolver<T> {\n  resolve: (value?: T | PromiseLike<T> | undefined) => void;\n  reject: (reason?: any) => void;\n}\n\ninterface WaitingState<T> {\n  type: 'waiting';\n  resolver: AsyncResolver<IteratorResult<T[]>>;\n}\ninterface BatchingState<T> {\n  type: 'batching';\n  values: T[];\n}\n\ntype State<T> = WaitingState<T> | BatchingState<T>;\n\nfunction assertNever(value: never): never {\n  throw new Error(`Unhandled discriminated union member ${value}`);\n}\n\nclass BatchAsyncIterable<TSource> extends AsyncIterableX<TSource[]> {\n  private _source: AsyncIterable<TSource>;\n\n  constructor(source: AsyncIterable<TSource>) {\n    super();\n    this._source = source;\n  }\n\n  [Symbol.asyncIterator]() {\n    const it = this._source[Symbol.asyncIterator]();\n\n    let state: State<TSource> = { type: 'batching', values: [] };\n    let ended: null | Promise<IteratorResult<TSource[]>> = null;\n\n    function consumeNext() {\n      it.next().then(\n        res => {\n          if (res.done) {\n            ended = Promise.resolve({ done: true } as IteratorResult<TSource[]>);\n\n            if (state.type === 'waiting') {\n              state.resolver.resolve(ended);\n            }\n          } else {\n            if (state.type === 'waiting') {\n              const { resolve } = state.resolver;\n              state = { type: 'batching', values: [] };\n              resolve({ done: res.done, value: [res.value] });\n            } else if (state.type === 'batching') {\n              state.values.push(res.value);\n            } else {\n              assertNever(state);\n            }\n\n            consumeNext();\n          }\n        },\n        err => {\n          ended = Promise.reject(err);\n\n          if (state.type === 'waiting') {\n            const { reject } = state.resolver;\n            reject(err);\n          }\n        }\n      );\n    }\n\n    consumeNext();\n\n    return {\n      next() {\n        if (state.type === 'batching' && state.values.length > 0) {\n          const { values } = state;\n          state.values = [];\n          return Promise.resolve({ done: false, value: values });\n        }\n\n        if (ended) {\n          return ended;\n        }\n\n        if (state.type === 'waiting') {\n          throw new Error('Previous `next()` is still in progress');\n        }\n\n        return new Promise<IteratorResult<TSource[]>>((resolve, reject) => {\n          state = {\n            type: 'waiting',\n            resolver: { resolve, reject }\n          };\n        });\n      },\n\n      return(value: any) {\n        return it.return\n          ? it.return(value).then(() => ({ done: true } as IteratorResult<TSource[]>))\n          : Promise.resolve({ done: true } as IteratorResult<TSource[]>);\n      }\n    };\n  }\n}\n\n/**\n * Returns an async iterable sequence of batches that are collected from the source sequence between\n * subsequent `next()` calls.\n */\nexport function batch<TSource>(source: AsyncIterable<TSource>): AsyncIterableX<TSource[]> {\n  return new BatchAsyncIterable(source);\n}\n"]}