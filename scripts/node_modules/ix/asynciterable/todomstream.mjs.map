{"version":3,"sources":["asynciterable/todomstream.ts"],"names":[],"mappings":"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","file":"todomstream.js","sourcesContent":["import { fromDOMStream } from './fromdomstream';\n\nexport type ReadableBYOBStreamOptions<T = any> = QueuingStrategy<T> & { type: 'bytes' };\nexport type ReadableByteStreamOptions<T = any> = QueuingStrategy<T> & {\n  type: 'bytes';\n  autoAllocateChunkSize?: number;\n};\n\n/** @ignore */\nfunction memcpy<TTarget extends ArrayBufferView, TSource extends ArrayBufferView>(\n  target: TTarget,\n  source: TSource,\n  targetByteOffset = 0,\n  sourceByteLength = source.byteLength\n) {\n  const targetByteLength = target.byteLength;\n  const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);\n  const src = new Uint8Array(\n    source.buffer,\n    source.byteOffset,\n    Math.min(sourceByteLength, targetByteLength, source.buffer.byteLength - source.byteOffset)\n  );\n  dst.set(src, targetByteOffset);\n  return src.byteLength;\n}\n\nabstract class AbstractUnderlyingSource<TSource> {\n  constructor(protected _source: AsyncIterator<TSource> | null) {}\n  async cancel() {\n    const source = this._source;\n    if (source && source.return) {\n      await source.return();\n    }\n    this._source = null;\n  }\n}\n\nclass UnderlyingAsyncIterableDefaultSource<TSource = any> extends AbstractUnderlyingSource<TSource>\n  implements UnderlyingSource<TSource> {\n  constructor(source: AsyncIterator<TSource> | null) {\n    super(source);\n  }\n  async pull(controller: ReadableStreamDefaultController<TSource>) {\n    const source = this._source;\n    if (source) {\n      const r = await source.next(controller.desiredSize);\n      if (!r.done) {\n        return controller.enqueue(r.value);\n      }\n    }\n    controller.close();\n  }\n}\n\nclass UnderlyingAsyncIterableByteSource<TSource extends ArrayBufferView = Uint8Array>\n  extends AbstractUnderlyingSource<TSource>\n  implements UnderlyingByteSource {\n  public readonly type: 'bytes';\n  public readonly autoAllocateChunkSize?: number;\n\n  // If we can't create a \"byob\" reader (no browsers currently suppor it),\n  // fallback to pulling values from the source iterator and enqueueing like\n  // object streams\n  private fallbackDefaultSource: UnderlyingAsyncIterableDefaultSource<TSource>;\n\n  constructor(\n    reader: AsyncIterator<TSource> | null,\n    opts: { autoAllocateChunkSize?: number } = {}\n  ) {\n    super(reader);\n    this.type = 'bytes';\n    this.autoAllocateChunkSize = opts.autoAllocateChunkSize;\n    this.fallbackDefaultSource = new UnderlyingAsyncIterableDefaultSource<TSource>(reader);\n  }\n  async pull(controller: ReadableByteStreamController) {\n    if (!controller.byobRequest) {\n      return await this.fallbackDefaultSource.pull(controller);\n    }\n    if (this._source) {\n      const { view } = controller.byobRequest;\n      const { done, value } = await this._source.next(view);\n      if (!done) {\n        // Did the source write into the BYOB view itself,\n        // then yield us the `bytesWritten` value? If so,\n        // pass that along\n        if (typeof value === 'number') {\n          return controller.byobRequest.respond(value);\n        }\n        // otherwise if the source is only producing buffers\n        // but doesn't expect to be given one, we should copy\n        // the produced buffer into the front of the BYOB view\n        if (ArrayBuffer.isView(value)) {\n          return value.buffer === view.buffer\n            ? controller.byobRequest.respondWithNewView(value)\n            : controller.byobRequest.respond(memcpy(view, value));\n        }\n      }\n    }\n    controller.close();\n  }\n}\n\n// Generate subclasses of ReadableStream that conform to the\n// AsyncIterable protocol. These classes are dynamically created\n// the first time a ReadableStream is produced because ReadableStream\n// is a browser-only API, and closure-compiler won't compile if they're\n// statically defined at the module scope.\n/** @ignore */\nconst asyncIterableReadableStream = (() => {\n  let AsyncIterableReadableByteStream_: any;\n  let AsyncIterableDefaultReadableStream_: any;\n\n  // A function that's called the first time someone creates a\n  // ReadableStream via `toDOMStream()`\n  let createFirstTime = <T>(source: any, opts?: any) => {\n    // Generate the subclasses with [Symbol.asyncIterator]() methods\n    class AsyncIterableDefaultReadableStream extends ReadableStream<T> {\n      [Symbol.asyncIterator]() {\n        return fromDOMStream(this)[Symbol.asyncIterator]();\n      }\n    }\n    class AsyncIterableReadableByteStream extends ReadableStream<Uint8Array> {\n      [Symbol.asyncIterator]() {\n        return fromDOMStream(this, { mode: 'byob' })[Symbol.asyncIterator]();\n      }\n    }\n    AsyncIterableReadableByteStream_ = AsyncIterableReadableByteStream;\n    AsyncIterableDefaultReadableStream_ = AsyncIterableDefaultReadableStream;\n    // Now point `createAsyncIterableReadableStream` to the function that\n    // instantiates the classes we just created\n    //tslint:disable-next-line\n    createAsyncIterableReadableStream = createAsyncIterableReadableStreamEveryOtherTime;\n    // Create and return the first ReadableStream<T> instance\n    //tslint:disable-next-line\n    return createAsyncIterableReadableStreamEveryOtherTime<T>(source, opts) as ReadableStream<T>;\n  };\n\n  // Shared function pointer that's called by the wrapper closure we return\n  //tslint:disable-next-line\n  let createAsyncIterableReadableStream = createFirstTime;\n  // Create instances of the classes generated by `createFirstTime`\n  let createAsyncIterableReadableStreamEveryOtherTime = <T>(source: any, opts?: any) => {\n    return source instanceof UnderlyingAsyncIterableByteSource\n      ? (new AsyncIterableReadableByteStream_(source, opts) as ReadableStream<T>)\n      : (new AsyncIterableDefaultReadableStream_(source, opts) as ReadableStream<T>);\n  };\n\n  return <T>(source: any, opts?: any) => createAsyncIterableReadableStream<T>(source, opts);\n})();\n\nexport function toDOMStream<T>(\n  source: AsyncIterable<T>,\n  strategy?: QueuingStrategy<T>\n): ReadableStream<T>;\nexport function toDOMStream<T>(\n  source: AsyncIterable<T>,\n  options: ReadableBYOBStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStream<T>(\n  source: AsyncIterable<T>,\n  options: ReadableByteStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStream(\n  source: AsyncIterable<any>,\n  options?: QueuingStrategy<any> | ReadableBYOBStreamOptions | ReadableByteStreamOptions\n) {\n  if (!options || !('type' in options) || options['type'] !== 'bytes') {\n    return asyncIterableReadableStream(\n      new UnderlyingAsyncIterableDefaultSource(source[Symbol.asyncIterator]()),\n      options\n    );\n  }\n  return asyncIterableReadableStream(\n    new UnderlyingAsyncIterableByteSource(source[Symbol.asyncIterator]()),\n    options\n  );\n}\n"]}