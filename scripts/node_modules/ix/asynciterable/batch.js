"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const asynciterablex_1 = require("./asynciterablex");
function assertNever(value) {
    throw new Error(`Unhandled discriminated union member ${value}`);
}
class BatchAsyncIterable extends asynciterablex_1.AsyncIterableX {
    constructor(source) {
        super();
        this._source = source;
    }
    [Symbol.asyncIterator]() {
        const it = this._source[Symbol.asyncIterator]();
        let state = { type: 'batching', values: [] };
        let ended = null;
        function consumeNext() {
            it.next().then(res => {
                if (res.done) {
                    ended = Promise.resolve({ done: true });
                    if (state.type === 'waiting') {
                        state.resolver.resolve(ended);
                    }
                }
                else {
                    if (state.type === 'waiting') {
                        const { resolve } = state.resolver;
                        state = { type: 'batching', values: [] };
                        resolve({ done: res.done, value: [res.value] });
                    }
                    else if (state.type === 'batching') {
                        state.values.push(res.value);
                    }
                    else {
                        assertNever(state);
                    }
                    consumeNext();
                }
            }, err => {
                ended = Promise.reject(err);
                if (state.type === 'waiting') {
                    const { reject } = state.resolver;
                    reject(err);
                }
            });
        }
        consumeNext();
        return {
            next() {
                if (state.type === 'batching' && state.values.length > 0) {
                    const { values } = state;
                    state.values = [];
                    return Promise.resolve({ done: false, value: values });
                }
                if (ended) {
                    return ended;
                }
                if (state.type === 'waiting') {
                    throw new Error('Previous `next()` is still in progress');
                }
                return new Promise((resolve, reject) => {
                    state = {
                        type: 'waiting',
                        resolver: { resolve, reject }
                    };
                });
            },
            return(value) {
                return it.return
                    ? it.return(value).then(() => ({ done: true }))
                    : Promise.resolve({ done: true });
            }
        };
    }
}
/**
 * Returns an async iterable sequence of batches that are collected from the source sequence between
 * subsequent `next()` calls.
 */
function batch(source) {
    return new BatchAsyncIterable(source);
}
exports.batch = batch;

//# sourceMappingURL=batch.js.map
