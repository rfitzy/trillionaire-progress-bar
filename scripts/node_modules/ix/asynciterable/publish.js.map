{"version":3,"sources":["asynciterable/publish.ts"],"names":[],"mappings":";;AAAA,qCAAkC;AAClC,uCAA+C;AAE/C,6DAAyD;AAEzD,MAAM,oBAAwB,SAAQ,4BAAqB;IAIzD,YAAY,MAAwB;QAClC,KAAK,CAAC,MAAM,EAAE,IAAI,4BAAY,CAAI,CAAC,CAAC,CAAC,CAAC;IACxC,CAAC;IAED,CAAC,MAAM,CAAC,aAAa,CAAC;QACpB,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC;QAC3B,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;IACvE,CAAC;CACF;AAOD,SAAgB,OAAO,CACrB,MAA8B,EAC9B,QAAoE;IAEpE,OAAO,QAAQ;QACb,CAAC,CAAC,eAAM,CAAC,KAAK,IAAI,EAAE,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;QACvE,CAAC,CAAC,IAAI,oBAAoB,CAAU,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC,CAAC;AACxE,CAAC;AAPD,0BAOC","file":"publish.js","sourcesContent":["import { create } from './create';\nimport { MemoizeAsyncBuffer } from './memoize';\nimport { AsyncIterableX } from './asynciterablex';\nimport { RefCountList } from '../iterable/_refcountlist';\n\nclass PublishedAsyncBuffer<T> extends MemoizeAsyncBuffer<T> {\n  // @ts-ignore\n  protected _buffer: RefCountList<T>;\n\n  constructor(source: AsyncIterator<T>) {\n    super(source, new RefCountList<T>(0));\n  }\n\n  [Symbol.asyncIterator]() {\n    this._buffer.readerCount++;\n    return this._getIterable(this._buffer.count)[Symbol.asyncIterator]();\n  }\n}\n\nexport function publish<TSource>(source: AsyncIterable<TSource>): AsyncIterableX<TSource>;\nexport function publish<TSource, TResult>(\n  source: AsyncIterable<TSource>,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): AsyncIterableX<TResult>;\nexport function publish<TSource, TResult>(\n  source: AsyncIterable<TSource>,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): AsyncIterableX<TSource | TResult> {\n  return selector\n    ? create(async () => selector(publish(source))[Symbol.asyncIterator]())\n    : new PublishedAsyncBuffer<TSource>(source[Symbol.asyncIterator]());\n}\n"]}