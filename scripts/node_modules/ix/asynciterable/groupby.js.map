{"version":3,"sources":["asynciterable/groupby.ts"],"names":[],"mappings":";;AAAA,qDAAkD;AAClD,mDAAqD;AACrD,2CAA6C;AAE7C,MAAa,oBAAmC,SAAQ,+BAAsB;IAI5E,YAAY,GAAS,EAAE,MAAwB;QAC7C,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IACxB,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC;QAC3B,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,OAAO,EAAE;YAC7B,MAAM,IAAI,CAAC;SACZ;IACH,CAAC;CACF;AAfD,oDAeC;AAED,MAAa,oBAAqD,SAAQ,+BAAuB;IAM/F,YACE,MAA8B,EAC9B,WAAqD,EACrD,eAA6D,EAC7D,cAAmF;QAEnF,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;QAChC,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;QACxC,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;IACxC,CAAC;IAED,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC;QAC3B,MAAM,GAAG,GAAG,MAAM,0BAAc,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;QACzF,KAAK,IAAI,CAAC,GAAG,EAAE,MAAM,CAAC,IAAI,GAAG,EAAE;YAC7B,MAAM,MAAM,IAAI,CAAC,eAAe,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;SAC/C;IACH,CAAC;CACF;AAzBD,oDAyBC;AAED,SAAgB,0BAA0B,CAAe,GAAS,EAAE,MAAwB;IAC1F,OAAO,IAAI,oBAAoB,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;AAC/C,CAAC;AAFD,gEAEC;AAiBD,SAAgB,OAAO,CACrB,MAA8B,EAC9B,WAAqD,EACrD,kBAAgE,wBAAa,EAC7E,iBAGkC,0BAA0B;IAE5D,OAAO,IAAI,oBAAoB,CAC7B,MAAM,EACN,WAAW,EACX,eAAe,EACf,cAAc,CACf,CAAC;AACJ,CAAC;AAfD,0BAeC","file":"groupby.js","sourcesContent":["import { AsyncIterableX } from './asynciterablex';\nimport { identityAsync } from '../internal/identity';\nimport { createGrouping } from './_grouping';\n\nexport class GroupedAsyncIterable<TKey, TValue> extends AsyncIterableX<TValue> {\n  public readonly key: TKey;\n  private _source: Iterable<TValue>;\n\n  constructor(key: TKey, source: Iterable<TValue>) {\n    super();\n    this.key = key;\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for (let item of this._source) {\n      yield item;\n    }\n  }\n}\n\nexport class GroupByAsyncIterable<TSource, TKey, TValue, TResult> extends AsyncIterableX<TResult> {\n  private _source: AsyncIterable<TSource>;\n  private _keySelector: (value: TSource) => TKey | Promise<TKey>;\n  private _elementSelector: (value: TSource) => TValue | Promise<TValue>;\n  private _resultSelector: (key: TKey, values: Iterable<TValue>) => TResult | Promise<TResult>;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    keySelector: (value: TSource) => TKey | Promise<TKey>,\n    elementSelector: (value: TSource) => TValue | Promise<TValue>,\n    resultSelector: (key: TKey, values: Iterable<TValue>) => TResult | Promise<TResult>\n  ) {\n    super();\n    this._source = source;\n    this._keySelector = keySelector;\n    this._elementSelector = elementSelector;\n    this._resultSelector = resultSelector;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    const map = await createGrouping(this._source, this._keySelector, this._elementSelector);\n    for (let [key, values] of map) {\n      yield await this._resultSelector(key, values);\n    }\n  }\n}\n\nexport function groupByResultIdentityAsync<TKey, TValue>(key: TKey, values: Iterable<TValue>): any {\n  return new GroupedAsyncIterable(key, values);\n}\n\nexport function groupBy<TSource, TKey>(\n  source: AsyncIterable<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>\n): AsyncIterableX<GroupedAsyncIterable<TKey, TSource>>;\nexport function groupBy<TSource, TKey, TValue>(\n  source: AsyncIterable<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (value: TSource) => TValue | Promise<TValue>\n): AsyncIterableX<GroupedAsyncIterable<TKey, TValue>>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  source: AsyncIterable<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (value: TSource) => TValue | Promise<TValue>,\n  resultSelector?: (key: TKey, values: Iterable<TValue>) => TResult | Promise<TResult>\n): AsyncIterableX<TResult>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  source: AsyncIterable<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector: (value: TSource) => TValue | Promise<TValue> = identityAsync,\n  resultSelector: (\n    key: TKey,\n    values: Iterable<TValue>\n  ) => TResult | Promise<TResult> = groupByResultIdentityAsync\n): AsyncIterableX<TResult> {\n  return new GroupByAsyncIterable<TSource, TKey, TValue, TResult>(\n    source,\n    keySelector,\n    elementSelector,\n    resultSelector\n  );\n}\n"]}