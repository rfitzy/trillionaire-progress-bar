"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const asynciterablex_1 = require("./asynciterablex");
class RaceAsyncIterable extends asynciterablex_1.AsyncIterableX {
    constructor(left, right) {
        super();
        this._left = left;
        this._right = right;
    }
    async *[Symbol.asyncIterator]() {
        const leftIt = this._left[Symbol.asyncIterator](), rightIt = this._right[Symbol.asyncIterator]();
        let otherIterator;
        let resultIterator;
        const { value, done } = await Promise.race([
            leftIt.next().then(x => {
                if (!resultIterator) {
                    resultIterator = leftIt;
                    otherIterator = rightIt;
                }
                return x;
            }),
            rightIt.next().then(x => {
                if (!resultIterator) {
                    resultIterator = rightIt;
                    otherIterator = leftIt;
                }
                return x;
            })
        ]);
        if (!done) {
            yield value;
        }
        otherIterator = otherIterator;
        resultIterator = resultIterator;
        // Cancel/finish other iterator
        if (otherIterator.return) {
            await otherIterator.return();
        }
        let next;
        while (!(next = await resultIterator.next()).done) {
            yield next.value;
        }
    }
}
/**
 * Propagates the async sequence that reacts first.
 * @param {AsyncIterable<T>} left First async sequence.
 * @param {AsyncIterable<T>} right Second async sequence.
 * @return {AsyncIterable<T>} An async sequence that surfaces either of the given sequences, whichever reacted first.
 */
function race(left, right) {
    return new RaceAsyncIterable(left, right);
}
exports.race = race;

//# sourceMappingURL=race.js.map
