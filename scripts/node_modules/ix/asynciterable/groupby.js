"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const asynciterablex_1 = require("./asynciterablex");
const identity_1 = require("../internal/identity");
const _grouping_1 = require("./_grouping");
class GroupedAsyncIterable extends asynciterablex_1.AsyncIterableX {
    constructor(key, source) {
        super();
        this.key = key;
        this._source = source;
    }
    async *[Symbol.asyncIterator]() {
        for (let item of this._source) {
            yield item;
        }
    }
}
exports.GroupedAsyncIterable = GroupedAsyncIterable;
class GroupByAsyncIterable extends asynciterablex_1.AsyncIterableX {
    constructor(source, keySelector, elementSelector, resultSelector) {
        super();
        this._source = source;
        this._keySelector = keySelector;
        this._elementSelector = elementSelector;
        this._resultSelector = resultSelector;
    }
    async *[Symbol.asyncIterator]() {
        const map = await _grouping_1.createGrouping(this._source, this._keySelector, this._elementSelector);
        for (let [key, values] of map) {
            yield await this._resultSelector(key, values);
        }
    }
}
exports.GroupByAsyncIterable = GroupByAsyncIterable;
function groupByResultIdentityAsync(key, values) {
    return new GroupedAsyncIterable(key, values);
}
exports.groupByResultIdentityAsync = groupByResultIdentityAsync;
function groupBy(source, keySelector, elementSelector = identity_1.identityAsync, resultSelector = groupByResultIdentityAsync) {
    return new GroupByAsyncIterable(source, keySelector, elementSelector, resultSelector);
}
exports.groupBy = groupBy;

//# sourceMappingURL=groupby.js.map
