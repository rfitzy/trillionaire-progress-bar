{"version":3,"sources":["iterable/todomstream.ts"],"names":[],"mappings":";;AAAA,oEAAiE;AACjE,8DAIsC;AAEtC,+DAA+D;AAC/D,+DAA+D;AAC/D,6CAA2C;AAC3C,iDAA+C;AAc/C,SAAgB,WAAW,CACzB,MAAqB,EACrB,OAAsF;IAEtF,IAAI,CAAC,OAAO,IAAI,CAAC,CAAC,MAAM,IAAI,OAAO,CAAC,IAAI,OAAO,CAAC,MAAM,CAAC,KAAK,OAAO,EAAE;QACnE,OAAO,yBAAwB,CAAC,+BAAc,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC,CAAC;KACvE;IACD,OAAO,yBAAwB,CAAC,+BAAc,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC,CAAC;AACxE,CAAC;AARD,kCAQC","file":"todomstream.js","sourcesContent":["import { AsyncIterableX } from '../asynciterable/asynciterablex';\nimport {\n  toDOMStream as asyncIterableToDOMStream,\n  ReadableBYOBStreamOptions,\n  ReadableByteStreamOptions\n} from '../asynciterable/todomstream';\n\n// To work around circular-dependency hell, these need to be on\n// the AsyncIterable prototype for tee, pipeTo, and pipeThrough\nimport '../add/iterable-operators/publish';\nimport '../add/iterable-operators/todomstream';\n\nexport function toDOMStream<T>(\n  source: Iterable<T>,\n  strategy?: QueuingStrategy<T>\n): ReadableStream<T>;\nexport function toDOMStream<T>(\n  source: Iterable<T>,\n  options: ReadableBYOBStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStream<T>(\n  source: Iterable<T>,\n  options: ReadableByteStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStream(\n  source: Iterable<any>,\n  options?: QueuingStrategy<any> | ReadableBYOBStreamOptions | ReadableByteStreamOptions\n) {\n  if (!options || !('type' in options) || options['type'] !== 'bytes') {\n    return asyncIterableToDOMStream(AsyncIterableX.from(source), options);\n  }\n  return asyncIterableToDOMStream(AsyncIterableX.from(source), options);\n}\n"]}