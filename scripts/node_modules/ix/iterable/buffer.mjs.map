{"version":3,"sources":["iterable/buffer.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AAExC,MAAM,OAAO,cAAwB,SAAQ,SAAoB;IAK/D,YAAY,MAAyB,EAAE,KAAa,EAAE,IAAY;QAChE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;IACpB,CAAC;IAED,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC;QAChB,IAAI,OAAO,GAAgB,EAAE,EAC3B,CAAC,GAAG,CAAC,CAAC;QACR,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,OAAO,EAAE;YAC7B,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;gBACxB,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aAClB;YAED,KAAK,IAAI,MAAM,IAAI,OAAO,EAAE;gBAC1B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACnB;YAED,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM,EAAE;gBAC3D,MAAM,OAAO,CAAC,KAAK,EAAG,CAAC;aACxB;YAED,CAAC,EAAE,CAAC;SACL;QAED,OAAO,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;YACzB,MAAM,OAAO,CAAC,KAAK,EAAG,CAAC;SACxB;IACH,CAAC;CACF;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4BG;AACH,MAAM,UAAU,MAAM,CACpB,MAAyB,EACzB,KAAa,EACb,IAAa;IAEb,IAAI,IAAI,IAAI,IAAI,EAAE;QAChB,IAAI,GAAG,KAAK,CAAC;KACd;IACD,OAAO,IAAI,cAAc,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;AACjD,CAAC","file":"buffer.js","sourcesContent":["import { IterableX } from './iterablex';\n\nexport class BufferIterable<TSource> extends IterableX<TSource[]> {\n  private _source: Iterable<TSource>;\n  private _count: number;\n  private _skip: number;\n\n  constructor(source: Iterable<TSource>, count: number, skip: number) {\n    super();\n    this._source = source;\n    this._count = count;\n    this._skip = skip;\n  }\n\n  *[Symbol.iterator]() {\n    let buffers: TSource[][] = [],\n      i = 0;\n    for (let item of this._source) {\n      if (i % this._skip === 0) {\n        buffers.push([]);\n      }\n\n      for (let buffer of buffers) {\n        buffer.push(item);\n      }\n\n      if (buffers.length > 0 && buffers[0].length === this._count) {\n        yield buffers.shift()!;\n      }\n\n      i++;\n    }\n\n    while (buffers.length > 0) {\n      yield buffers.shift()!;\n    }\n  }\n}\n\n/**\n * Generates a sequence of buffers over the source sequence, with specified length and possible overlap.\n * @example <caption>Creates a sequence of buffers with and without skip</caption>\n * const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n *\n * // Without skip\n * const result = buffer(source, 5);\n * const result = Ix.Iterable.from(source).buffer(5);\n * for (const item of result) {\n *   console.log(result);\n * }\n * // => [0, 1, 2, 3, 4]\n * // => [5, 6, 7, 8, 9]\n *\n * // With skip\n * const result = buffer(source, 3, 4);\n * const result = Ix.Iterable.from(source).buffer(3, 4);\n * for (const item of result) {\n *   console.log(result);\n * }\n * // => [0, 1, 2]\n * // => [4, 5, 6]\n * // => [8, 9]\n * @param {Iterabel<TSource>} source Source sequence\n * @param {number} count Number of elements for allocated buffers.\n * @param {number} [skip] Number of elements to skip between the start of consecutive buffers. If not specified, defaults\n * to the count.\n * @return {IterableX<TSource>[]} Sequence of buffers containing source sequence elements\n */\nexport function buffer<TSource>(\n  source: Iterable<TSource>,\n  count: number,\n  skip?: number\n): IterableX<TSource[]> {\n  if (skip == null) {\n    skip = count;\n  }\n  return new BufferIterable(source, count, skip);\n}\n"]}