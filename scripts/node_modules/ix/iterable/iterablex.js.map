{"version":3,"sources":["iterable/iterablex.ts"],"names":[],"mappings":"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","file":"iterablex.js","sourcesContent":["import { OperatorFunction } from '../interfaces';\nimport { bindCallback } from '../internal/bindcallback';\nimport { identity } from '../internal/identity';\nimport { toLength } from '../internal/tolength';\nimport {\n  isArrayLike,\n  isIterable,\n  isIterator,\n  isReadableNodeStream,\n  isWritableNodeStream\n} from '../internal/isiterable';\n\n/**\n * This clas serves as the base for all operations which support [Symbol.iterator].\n */\nexport abstract class IterableX<T> implements Iterable<T> {\n  abstract [Symbol.iterator](): Iterator<T>;\n\n  forEach(projection: (value: T, index: number) => void, thisArg?: any): void {\n    const fn = bindCallback(projection, thisArg, 2);\n    let i = 0;\n    for (let item of this) {\n      fn(item, i++);\n    }\n  }\n\n  pipe<R>(...operations: OperatorFunction<T, R>[]): IterableX<R>;\n  pipe<R extends NodeJS.WritableStream>(writable: R, options?: { end?: boolean }): R;\n  pipe<R>(...args: any[]) {\n    let i = -1;\n    let n = args.length;\n    let acc: any = this;\n    let as = IterableX.as;\n    while (++i < n) {\n      acc = as(args[i](acc));\n    }\n    return acc;\n  }\n\n  tee(): [ReadableStream<T>, ReadableStream<T>] {\n    return this._getDOMStream().tee();\n  }\n\n  pipeTo(writable: WritableStream<T>, options?: PipeOptions) {\n    return this._getDOMStream().pipeTo(writable, options);\n  }\n\n  pipeThrough<R extends ReadableStream<any>>(\n    duplex: { writable: WritableStream<T>; readable: R },\n    options?: PipeOptions\n  ) {\n    return this._getDOMStream().pipeThrough(duplex, options);\n  }\n\n  private _DOMStream?: ReadableStream<T>;\n  private _getDOMStream(): ReadableStream<T> {\n    return this._DOMStream || (this._DOMStream = this.publish().toDOMStream());\n  }\n\n  static as(source: string): IterableX<string>;\n  static as<T extends IterableX<any>>(source: T): T;\n  static as<T>(source: Iterable<T> | Iterator<T> | ArrayLike<T>): IterableX<T>;\n  static as<T>(source: T): IterableX<T>;\n  /** @nocollapse */\n  static as(source: any) {\n    /* tslint:disable */\n    if (source instanceof IterableX) {\n      return source;\n    }\n    if (typeof source === 'string') {\n      return new OfIterable([source]);\n    }\n    if (isIterable(source)) {\n      return new FromIterable(source, identity);\n    }\n    if (isArrayLike(source)) {\n      return new FromIterable(source, identity);\n    }\n    return new OfIterable([source]);\n    /* tslint:enable */\n  }\n\n  /** @nocollapse */\n  static from<TSource, TResult = TSource>(\n    source: Iterable<TSource> | Iterator<TSource> | ArrayLike<TSource>,\n    selector: (value: TSource, index: number) => TResult = identity,\n    thisArg?: any\n  ): IterableX<TResult> {\n    const fn = bindCallback(selector, thisArg, 2);\n    /* tslint:disable */\n    if (isIterable(source)) {\n      return new FromIterable<TSource, TResult>(source, fn);\n    }\n    if (isArrayLike(source)) {\n      return new FromIterable<TSource, TResult>(source, fn);\n    }\n    if (isIterator(source)) {\n      return new FromIterable<TSource, TResult>({ [Symbol.iterator]: () => source }, fn);\n    }\n    throw new TypeError('Input type not supported');\n    /* tslint:enable */\n  }\n\n  /** @nocollapse */\n  static of<TSource>(...args: TSource[]): IterableX<TSource> {\n    //tslint:disable-next-line\n    return new OfIterable<TSource>(args);\n  }\n}\n\nclass FromIterable<TSource, TResult = TSource> extends IterableX<TResult> {\n  private _source: Iterable<TSource> | ArrayLike<TSource>;\n  private _fn: (value: TSource, index: number) => TResult;\n\n  constructor(\n    source: Iterable<TSource> | ArrayLike<TSource>,\n    fn: (value: TSource, index: number) => TResult\n  ) {\n    super();\n    this._source = source;\n    this._fn = fn;\n  }\n\n  *[Symbol.iterator]() {\n    const iterable = isIterable(this._source);\n    let i = 0;\n    if (iterable) {\n      for (let item of <Iterable<TSource>>this._source) {\n        yield this._fn(item, i++);\n      }\n    } else {\n      let length = toLength((<ArrayLike<TSource>>this._source).length);\n      while (i < length) {\n        let val = (<ArrayLike<TSource>>this._source)[i];\n        yield this._fn(val, i++);\n      }\n    }\n  }\n}\n\nclass OfIterable<TSource> extends IterableX<TSource> {\n  private _args: TSource[];\n\n  constructor(args: TSource[]) {\n    super();\n    this._args = args;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this._args;\n  }\n}\n\ntype WritableOrOperatorFunction<T, R> =\n  | NodeJS.WritableStream\n  | NodeJS.ReadWriteStream\n  | OperatorFunction<T, R>;\n\ndeclare module '../iterable/iterablex' {\n  interface IterableX<T> extends Iterable<T> {\n    pipe(): IterableX<T>;\n    pipe<A>(op1: OperatorFunction<T, A>): IterableX<A>;\n    pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): IterableX<B>;\n    pipe<A, B, C>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>\n    ): IterableX<C>;\n    pipe<A, B, C, D>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>\n    ): IterableX<D>;\n    pipe<A, B, C, D, E>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>\n    ): IterableX<E>;\n    pipe<A, B, C, D, E, F>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>\n    ): IterableX<F>;\n    pipe<A, B, C, D, E, F, G>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>,\n      op7: OperatorFunction<F, G>\n    ): IterableX<G>;\n    pipe<A, B, C, D, E, F, G, H>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>,\n      op7: OperatorFunction<F, G>,\n      op8: OperatorFunction<G, H>\n    ): IterableX<H>;\n    pipe<A, B, C, D, E, F, G, H, I>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>,\n      op7: OperatorFunction<F, G>,\n      op8: OperatorFunction<G, H>,\n      op9: OperatorFunction<H, I>\n    ): IterableX<I>;\n    pipe<R>(...operations: OperatorFunction<T, R>[]): IterableX<R>;\n    pipe<A extends NodeJS.WritableStream>(op1: A, options?: { end?: boolean }): A;\n  }\n}\n\ntry {\n  (isBrowser => {\n    if (isBrowser) {\n      return;\n    }\n\n    const as = IterableX.as;\n    IterableX.prototype.pipe = nodePipe;\n    const readableOpts = (x: any, opts = x._writableState || { objectMode: true }) => opts;\n\n    function nodePipe<T>(this: IterableX<T>, ...args: any[]) {\n      let i = -1;\n      let end: boolean;\n      let n = args.length;\n      let prev: any = this;\n      let next: WritableOrOperatorFunction<T, any>;\n      while (++i < n) {\n        next = args[i];\n        if (typeof next === 'function') {\n          prev = as(next(prev));\n        } else if (isWritableNodeStream(next)) {\n          ({ end = true } = args[i + 1] || {});\n          // prettier-ignore\n          return isReadableNodeStream(prev) ? prev.pipe(next, {end}) :\n             prev.toNodeStream(readableOpts(next)).pipe(next, {end});\n        }\n      }\n      return prev;\n    }\n  })(typeof window === 'object' && typeof document === 'object' && document.nodeType === 9);\n} catch (e) {\n  /* */\n}\n"]}