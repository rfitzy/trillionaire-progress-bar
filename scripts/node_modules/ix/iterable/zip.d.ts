import { IterableX } from './iterablex';
export declare class ZipIterable<TSource, TResult> extends IterableX<TResult> {
    private _sources;
    private _fn;
    constructor(sources: Iterable<TSource>[], fn: (values: any[]) => TResult);
    [Symbol.iterator](): IterableIterator<TResult>;
}
export declare function zip<T, T2>(source: Iterable<T>, source2: Iterable<T2>): IterableX<[T, T2]>;
export declare function zip<T, T2, T3>(source: Iterable<T>, source2: Iterable<T2>, source3: Iterable<T3>): IterableX<[T, T2, T3]>;
export declare function zip<T, T2, T3, T4>(source: Iterable<T>, source2: Iterable<T2>, source3: Iterable<T3>, source4: Iterable<T4>): IterableX<[T, T2, T3, T4]>;
export declare function zip<T, T2, T3, T4, T5>(source: Iterable<T>, source2: Iterable<T2>, source3: Iterable<T3>, source4: Iterable<T4>, source5: Iterable<T5>): IterableX<[T, T2, T3, T4, T5]>;
export declare function zip<T, T2, T3, T4, T5, T6>(source: Iterable<T>, source2: Iterable<T2>, source3: Iterable<T3>, source4: Iterable<T4>, source5: Iterable<T5>, source6: Iterable<T6>): IterableX<[T, T2, T3, T4, T5, T6]>;
export declare function zip<T, R>(project: (values: [T]) => R, source: Iterable<T>): IterableX<R>;
export declare function zip<T, T2, R>(project: (values: [T, T2]) => R, source: Iterable<T>, source2: Iterable<T2>): IterableX<R>;
export declare function zip<T, T2, T3, R>(project: (values: [T, T2, T3]) => R, source: Iterable<T>, source2: Iterable<T2>, source3: Iterable<T3>): IterableX<R>;
export declare function zip<T, T2, T3, T4, R>(project: (values: [T, T2, T3, T4]) => R, source: Iterable<T>, source2: Iterable<T2>, source3: Iterable<T3>, source4: Iterable<T4>): IterableX<R>;
export declare function zip<T, T2, T3, T4, T5, R>(project: (values: [T, T2, T3, T4, T5]) => R, source: Iterable<T>, source2: Iterable<T2>, source3: Iterable<T3>, source4: Iterable<T4>, source5: Iterable<T5>): IterableX<R>;
export declare function zip<T, T2, T3, T4, T5, T6, R>(project: (values: [T, T2, T3, T4, T5, T6]) => R, source: Iterable<T>, source2: Iterable<T2>, source3: Iterable<T3>, source4: Iterable<T4>, source5: Iterable<T5>, source6: Iterable<T6>): IterableX<R>;
export declare function zip<T>(...sources: Iterable<T>[]): IterableX<T[]>;
export declare function zip<T, R>(project: (values: T[]) => R, ...sources: Iterable<T>[]): IterableX<R>;
