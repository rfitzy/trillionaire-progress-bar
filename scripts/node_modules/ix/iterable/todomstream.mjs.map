{"version":3,"sources":["iterable/todomstream.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,iCAAiC,CAAC;AACjE,OAAO,EACL,WAAW,IAAI,wBAAwB,EAGxC,MAAM,8BAA8B,CAAC;AAEtC,+DAA+D;AAC/D,+DAA+D;AAC/D,OAAO,mCAAmC,CAAC;AAC3C,OAAO,uCAAuC,CAAC;AAc/C,MAAM,UAAU,WAAW,CACzB,MAAqB,EACrB,OAAsF;IAEtF,IAAI,CAAC,OAAO,IAAI,CAAC,CAAC,MAAM,IAAI,OAAO,CAAC,IAAI,OAAO,CAAC,MAAM,CAAC,KAAK,OAAO,EAAE;QACnE,OAAO,wBAAwB,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC,CAAC;KACvE;IACD,OAAO,wBAAwB,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC,CAAC;AACxE,CAAC","file":"todomstream.js","sourcesContent":["import { AsyncIterableX } from '../asynciterable/asynciterablex';\nimport {\n  toDOMStream as asyncIterableToDOMStream,\n  ReadableBYOBStreamOptions,\n  ReadableByteStreamOptions\n} from '../asynciterable/todomstream';\n\n// To work around circular-dependency hell, these need to be on\n// the AsyncIterable prototype for tee, pipeTo, and pipeThrough\nimport '../add/iterable-operators/publish';\nimport '../add/iterable-operators/todomstream';\n\nexport function toDOMStream<T>(\n  source: Iterable<T>,\n  strategy?: QueuingStrategy<T>\n): ReadableStream<T>;\nexport function toDOMStream<T>(\n  source: Iterable<T>,\n  options: ReadableBYOBStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStream<T>(\n  source: Iterable<T>,\n  options: ReadableByteStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStream(\n  source: Iterable<any>,\n  options?: QueuingStrategy<any> | ReadableBYOBStreamOptions | ReadableByteStreamOptions\n) {\n  if (!options || !('type' in options) || options['type'] !== 'bytes') {\n    return asyncIterableToDOMStream(AsyncIterableX.from(source), options);\n  }\n  return asyncIterableToDOMStream(AsyncIterableX.from(source), options);\n}\n"]}