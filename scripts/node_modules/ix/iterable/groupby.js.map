{"version":3,"sources":["iterable/groupby.ts"],"names":[],"mappings":";;AAAA,2CAAwC;AACxC,mDAAgD;AAChD,2CAA6C;AAE7C,MAAa,eAA8B,SAAQ,qBAAiB;IAIlE,YAAY,GAAS,EAAE,MAAwB;QAC7C,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IACxB,CAAC;IAED,CAAC,MAAM,CAAC,QAAQ,CAAC;QACf,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;IACzC,CAAC;CACF;AAbD,0CAaC;AAED,MAAa,eAAgD,SAAQ,qBAAkB;IAMrF,YACE,MAAyB,EACzB,WAAqC,EACrC,eAA2C,EAC3C,cAAgE;QAEhE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;QAChC,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;QACxC,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;IACxC,CAAC;IAED,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC;QAChB,MAAM,GAAG,GAAG,0BAAc,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;QACnF,KAAK,IAAI,CAAC,GAAG,EAAE,MAAM,CAAC,IAAI,GAAG,EAAE;YAC7B,MAAM,IAAI,CAAC,eAAe,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;SACzC;IACH,CAAC;CACF;AAzBD,0CAyBC;AAED,SAAgB,qBAAqB,CAAe,GAAS,EAAE,MAAwB;IACrF,OAAO,IAAI,eAAe,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;AAC1C,CAAC;AAFD,sDAEC;AAiBD,SAAgB,OAAO,CACrB,MAAyB,EACzB,WAAqC,EACrC,kBAA8C,mBAAQ,EACtD,iBAAmE,qBAAqB;IAExF,OAAO,IAAI,eAAe,CACxB,MAAM,EACN,WAAW,EACX,eAAe,EACf,cAAc,CACf,CAAC;AACJ,CAAC;AAZD,0BAYC","file":"groupby.js","sourcesContent":["import { IterableX } from './iterablex';\nimport { identity } from '../internal/identity';\nimport { createGrouping } from './_grouping';\n\nexport class GroupedIterable<TKey, TValue> extends IterableX<TValue> {\n  public readonly key: TKey;\n  private _source: Iterable<TValue>;\n\n  constructor(key: TKey, source: Iterable<TValue>) {\n    super();\n    this.key = key;\n    this._source = source;\n  }\n\n  [Symbol.iterator]() {\n    return this._source[Symbol.iterator]();\n  }\n}\n\nexport class GroupByIterable<TSource, TKey, TValue, TResult> extends IterableX<TResult> {\n  private _source: Iterable<TSource>;\n  private _keySelector: (value: TSource) => TKey;\n  private _elementSelector: (value: TSource) => TValue;\n  private _resultSelector: (key: TKey, values: Iterable<TValue>) => TResult;\n\n  constructor(\n    source: Iterable<TSource>,\n    keySelector: (value: TSource) => TKey,\n    elementSelector: (value: TSource) => TValue,\n    resultSelector: (key: TKey, values: Iterable<TValue>) => TResult\n  ) {\n    super();\n    this._source = source;\n    this._keySelector = keySelector;\n    this._elementSelector = elementSelector;\n    this._resultSelector = resultSelector;\n  }\n\n  *[Symbol.iterator]() {\n    const map = createGrouping(this._source, this._keySelector, this._elementSelector);\n    for (let [key, values] of map) {\n      yield this._resultSelector(key, values);\n    }\n  }\n}\n\nexport function groupByResultIdentity<TKey, TValue>(key: TKey, values: Iterable<TValue>): any {\n  return new GroupedIterable(key, values);\n}\n\nexport function groupBy<TSource, TKey>(\n  source: Iterable<TSource>,\n  keySelector: (value: TSource) => TKey\n): IterableX<GroupedIterable<TKey, TSource>>;\nexport function groupBy<TSource, TKey, TValue>(\n  source: Iterable<TSource>,\n  keySelector: (value: TSource) => TKey,\n  elementSelector?: (value: TSource) => TValue\n): IterableX<GroupedIterable<TKey, TValue>>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  source: Iterable<TSource>,\n  keySelector: (value: TSource) => TKey,\n  elementSelector?: (value: TSource) => TValue,\n  resultSelector?: (key: TKey, values: Iterable<TValue>) => TResult\n): IterableX<TResult>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  source: Iterable<TSource>,\n  keySelector: (value: TSource) => TKey,\n  elementSelector: (value: TSource) => TValue = identity,\n  resultSelector: (key: TKey, values: Iterable<TValue>) => TResult = groupByResultIdentity\n): IterableX<TResult> {\n  return new GroupByIterable<TSource, TKey, TValue, TResult>(\n    source,\n    keySelector,\n    elementSelector,\n    resultSelector\n  );\n}\n"]}