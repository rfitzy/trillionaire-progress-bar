import { IterableX } from './iterablex';
export declare abstract class OrderedIterableBaseX<TSource> extends IterableX<TSource> {
    _source: Iterable<TSource>;
    constructor(source: Iterable<TSource>);
    [Symbol.iterator](): IterableIterator<TSource>;
    thenBy<TKey>(keySelector: (item: TSource) => TKey, comparer?: (fst: TKey, snd: TKey) => number): OrderedIterableBaseX<TSource>;
    thenByDescending<TKey>(keySelector: (item: TSource) => TKey, comparer?: (fst: TKey, snd: TKey) => number): OrderedIterableBaseX<TSource>;
    abstract _getSorter(elements: TSource[], next?: (x: number, y: number) => number): (x: number, y: number) => number;
}
export declare class OrderedIterableX<TKey, TSource> extends OrderedIterableBaseX<TSource> {
    private _keySelector;
    private _comparer;
    private _descending;
    private _parent?;
    constructor(source: Iterable<TSource>, keySelector: (item: TSource) => TKey, comparer: (fst: TKey, snd: TKey) => number, descending: boolean, parent?: OrderedIterableBaseX<TSource>);
    _getSorter(elements: TSource[], next?: (x: number, y: number) => number): (x: number, y: number) => number;
}
export declare function orderBy<TKey, TSource>(source: Iterable<TSource>, keySelector: (item: TSource) => TKey, comparer?: (fst: TKey, snd: TKey) => number): OrderedIterableX<TKey, TSource>;
export declare function orderByDescending<TKey, TSource>(source: Iterable<TSource>, keySelector: (item: TSource) => TKey, comparer?: (fst: TKey, snd: TKey) => number): OrderedIterableX<TKey, TSource>;
export declare function thenBy<TKey, TSource>(source: OrderedIterableBaseX<TSource>, keySelector: (item: TSource) => TKey, comparer?: (fst: TKey, snd: TKey) => number): OrderedIterableX<TKey, TSource>;
export declare function thenByDescending<TKey, TSource>(source: OrderedIterableBaseX<TSource>, keySelector: (item: TSource) => TKey, comparer?: (fst: TKey, snd: TKey) => number): OrderedIterableX<TKey, TSource>;
