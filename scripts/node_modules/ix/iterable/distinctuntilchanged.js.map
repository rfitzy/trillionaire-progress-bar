{"version":3,"sources":["iterable/distinctuntilchanged.ts"],"names":[],"mappings":";;AAAA,2CAAwC;AACxC,mDAAgD;AAChD,mDAAmE;AAEnE,MAAa,4BAA4C,SAAQ,qBAAkB;IAKjF,YACE,MAAyB,EACzB,WAAqC,EACrC,QAAgD;QAEhD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;QAChC,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;IAC5B,CAAC;IAED,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC;QAChB,IAAI,UAAU,GAAS,EAAE,EACvB,aAAa,GAAG,KAAK,CAAC;QACxB,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,OAAO,EAAE;YAC7B,IAAI,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YAClC,IAAI,cAAc,GAAG,KAAK,CAAC;YAC3B,IAAI,aAAa,EAAE;gBACjB,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;aAClD;YACD,IAAI,CAAC,aAAa,IAAI,CAAC,cAAc,EAAE;gBACrC,aAAa,GAAG,IAAI,CAAC;gBACrB,UAAU,GAAG,GAAG,CAAC;gBACjB,MAAM,IAAI,CAAC;aACZ;SACF;IACH,CAAC;CACF;AAhCD,oEAgCC;AAED;;;;;;GAMG;AACH,SAAgB,oBAAoB,CAClC,MAAyB,EACzB,cAAwC,mBAAQ,EAChD,WAAmD,mBAAe;IAElE,OAAO,IAAI,4BAA4B,CAAgB,MAAM,EAAE,WAAW,EAAE,QAAQ,CAAC,CAAC;AACxF,CAAC;AAND,oDAMC","file":"distinctuntilchanged.js","sourcesContent":["import { IterableX } from './iterablex';\nimport { identity } from '../internal/identity';\nimport { comparer as defaultComparer } from '../internal/comparer';\n\nexport class DistinctUntilChangedIterable<TSource, TKey> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _keySelector: (value: TSource) => TKey;\n  private _comparer: (x: TKey, y: TKey) => boolean;\n\n  constructor(\n    source: Iterable<TSource>,\n    keySelector: (value: TSource) => TKey,\n    comparer: (first: TKey, second: TKey) => boolean\n  ) {\n    super();\n    this._source = source;\n    this._keySelector = keySelector;\n    this._comparer = comparer;\n  }\n\n  *[Symbol.iterator]() {\n    let currentKey = <TKey>{},\n      hasCurrentKey = false;\n    for (let item of this._source) {\n      let key = this._keySelector(item);\n      let comparerEquals = false;\n      if (hasCurrentKey) {\n        comparerEquals = this._comparer(currentKey, key);\n      }\n      if (!hasCurrentKey || !comparerEquals) {\n        hasCurrentKey = true;\n        currentKey = key;\n        yield item;\n      }\n    }\n  }\n}\n\n/**\n * Returns consecutive distinct elements based on a key value by using the specified equality comparer to compare key values.\n * @param {Iterable<TSource>} source Source sequence.\n * @param {function(value: TSource): TKey} [keySelector] Key selector.\n * @param {function(x: TKey, y: TKey): boolean} [comparer] Comparer used to compare key values.\n * @return {Iterable<TSource>} Sequence without adjacent non-distinct elements.\n */\nexport function distinctUntilChanged<TSource, TKey>(\n  source: Iterable<TSource>,\n  keySelector: (value: TSource) => TKey = identity,\n  comparer: (first: TKey, second: TKey) => boolean = defaultComparer\n): IterableX<TSource> {\n  return new DistinctUntilChangedIterable<TSource, TKey>(source, keySelector, comparer);\n}\n"]}