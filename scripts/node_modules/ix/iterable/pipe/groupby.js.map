{"version":3,"sources":["iterable/pipe/groupby.ts"],"names":[],"mappings":";;AAEA,wCAAqF;AACrF,sDAAmD;AAcnD,SAAgB,OAAO,CACrB,WAAqC,EACrC,kBAA8C,mBAAQ,EACtD,iBAAmE,+BAAqB;IAExF,OAAO,SAAS,uBAAuB,CAAC,MAAyB;QAC/D,OAAO,IAAI,yBAAe,CACxB,MAAM,EACN,WAAW,EACX,eAAe,EACf,cAAc,CACf,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC;AAbD,0BAaC","file":"groupby.js","sourcesContent":["import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { GroupByIterable, GroupedIterable, groupByResultIdentity } from '../groupby';\nimport { identity } from '../../internal/identity';\n\nexport function groupBy<TSource, TKey>(\n  keySelector: (value: TSource) => TKey\n): OperatorFunction<TSource, GroupedIterable<TKey, TSource>>;\nexport function groupBy<TSource, TKey, TValue>(\n  keySelector: (value: TSource) => TKey,\n  elementSelector?: (value: TSource) => TValue\n): OperatorFunction<TSource, GroupedIterable<TKey, TValue>>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  keySelector: (value: TSource) => TKey,\n  elementSelector?: (value: TSource) => TValue,\n  resultSelector?: (key: TKey, values: Iterable<TValue>) => TResult\n): OperatorFunction<TSource, TResult>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  keySelector: (value: TSource) => TKey,\n  elementSelector: (value: TSource) => TValue = identity,\n  resultSelector: (key: TKey, values: Iterable<TValue>) => TResult = groupByResultIdentity\n): OperatorFunction<TSource, TResult> {\n  return function groupByOperatorFunction(source: Iterable<TSource>): IterableX<TResult> {\n    return new GroupByIterable<TSource, TKey, TValue, TResult>(\n      source,\n      keySelector,\n      elementSelector,\n      resultSelector\n    );\n  };\n}\n"]}