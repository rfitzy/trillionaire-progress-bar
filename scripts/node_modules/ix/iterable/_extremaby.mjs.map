{"version":3,"sources":["iterable/_extremaby.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AAExC;;GAEG;AACH,MAAM,UAAU,cAAc,CAAI,GAAM,EAAE,QAAW;IACnD,OAAO,GAAG,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,CAAC;AAED;;GAEG;AACH,MAAM,iBAAiC,SAAQ,SAAkB;IAK/D,YACE,MAAyB,EACzB,KAA2B,EAC3B,GAAiC;QAEjC,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;IAClB,CAAC;IAED,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC;QAChB,IAAI,MAAM,GAAc,EAAE,EACxB,IAAI,CAAC;QACP,MAAM,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;QAC3C,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE;YAC3B,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;SAClD;QAED,IAAI,OAAO,GAAG,IAAI,CAAC,KAAK,EACtB,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QAChC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACrB,OAAO,CAAC,CAAC,IAAI,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE;YAC/B,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,EACnB,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAC1B,MAAM,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;YACjC,IAAI,CAAC,KAAK,CAAC,EAAE;gBACX,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACnB;iBAAM,IAAI,CAAC,GAAG,CAAC,EAAE;gBAChB,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC;gBAChB,MAAM,GAAG,GAAG,CAAC;aACd;SACF;QAED,KAAK,CAAC,CAAC,MAAM,CAAC;IAChB,CAAC;CACF;AAED;;GAEG;AACH,MAAM,UAAU,SAAS,CACvB,MAAyB,EACzB,KAA2B,EAC3B,GAAiC;IAEjC,OAAO,IAAI,iBAAiB,CAAgB,MAAM,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;AAClE,CAAC","file":"_extremaby.js","sourcesContent":["import { IterableX } from './iterablex';\n\n/**\n * @ignore\n */\nexport function defaultCompare<T>(key: T, minValue: T): number {\n  return key > minValue ? 1 : key < minValue ? -1 : 0;\n}\n\n/**\n * @ignore\n */\nclass ExtremaByIterable<TSource, TKey> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _keyFn: (x: TSource) => TKey;\n  private _cmp: (x: TKey, y: TKey) => number;\n\n  constructor(\n    source: Iterable<TSource>,\n    keyFn: (x: TSource) => TKey,\n    cmp: (x: TKey, y: TKey) => number\n  ) {\n    super();\n    this._source = source;\n    this._keyFn = keyFn;\n    this._cmp = cmp;\n  }\n\n  *[Symbol.iterator]() {\n    let result: TSource[] = [],\n      next;\n    const it = this._source[Symbol.iterator]();\n    if ((next = it.next()).done) {\n      throw new Error('Sequence contains no elements');\n    }\n\n    let current = next.value,\n      resKey = this._keyFn(current);\n    result.push(current);\n    while (!(next = it.next()).done) {\n      let curr = next.value,\n        key = this._keyFn(curr);\n      const c = this._cmp(key, resKey);\n      if (c === 0) {\n        result.push(curr);\n      } else if (c > 0) {\n        result = [curr];\n        resKey = key;\n      }\n    }\n\n    yield* result;\n  }\n}\n\n/**\n * @ignore\n */\nexport function extremaBy<TSource, TKey>(\n  source: Iterable<TSource>,\n  keyFn: (x: TSource) => TKey,\n  cmp: (x: TKey, y: TKey) => number\n): IterableX<TSource> {\n  return new ExtremaByIterable<TSource, TKey>(source, keyFn, cmp);\n}\n"]}