{"version":3,"sources":["add/iterable-operators/groupby.ts"],"names":[],"mappings":";;AAAA,wDAAqD;AACrD,oDAAyF;AACzF,sDAAmD;AAiBnD;;GAEG;AACH,SAAgB,YAAY,CAE1B,WAAqC,EACrC,kBAA8C,mBAAQ,EACtD,iBAAmE,+BAAqB;IAExF,OAAO,iBAAO,CACZ,IAAI,EACJ,WAAW,EACX,eAAe,EACf,cAAc,CACf,CAAC;AACJ,CAAC;AAZD,oCAYC;AAED,qBAAS,CAAC,SAAS,CAAC,OAAO,GAAG,YAAY,CAAC","file":"groupby.js","sourcesContent":["import { IterableX } from '../../iterable/iterablex';\nimport { groupBy, GroupedIterable, groupByResultIdentity } from '../../iterable/groupby';\nimport { identity } from '../../internal/identity';\n\nexport function groupByProto<TSource, TKey>(\n  this: IterableX<TSource>,\n  keySelector: (value: TSource) => TKey\n): IterableX<GroupedIterable<TKey, TSource>>;\nexport function groupByProto<TSource, TKey, TValue>(\n  this: IterableX<TSource>,\n  keySelector: (value: TSource) => TKey,\n  elementSelector?: (value: TSource) => TValue\n): IterableX<GroupedIterable<TKey, TValue>>;\nexport function groupByProto<TSource, TKey, TValue, TResult>(\n  this: IterableX<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (value: TSource) => TValue | Promise<TValue>,\n  resultSelector?: (key: TKey, values: Iterable<TValue>) => TResult\n): IterableX<TResult>;\n/**\n * @ignore\n */\nexport function groupByProto<TSource, TKey, TValue, TResult>(\n  this: IterableX<TSource>,\n  keySelector: (value: TSource) => TKey,\n  elementSelector: (value: TSource) => TValue = identity,\n  resultSelector: (key: TKey, values: Iterable<TValue>) => TResult = groupByResultIdentity\n): IterableX<TResult> {\n  return groupBy<TSource, TKey, TValue, TResult>(\n    this,\n    keySelector,\n    elementSelector,\n    resultSelector\n  );\n}\n\nIterableX.prototype.groupBy = groupByProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    groupBy: typeof groupByProto;\n  }\n}\n"]}