{"version":3,"sources":["add/iterable-operators/groupby.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAC;AACrD,OAAO,EAAE,OAAO,EAAmB,qBAAqB,EAAE,MAAM,wBAAwB,CAAC;AACzF,OAAO,EAAE,QAAQ,EAAE,MAAM,yBAAyB,CAAC;AAiBnD;;GAEG;AACH,MAAM,UAAU,YAAY,CAE1B,WAAqC,EACrC,kBAA8C,QAAQ,EACtD,iBAAmE,qBAAqB;IAExF,OAAO,OAAO,CACZ,IAAI,EACJ,WAAW,EACX,eAAe,EACf,cAAc,CACf,CAAC;AACJ,CAAC;AAED,SAAS,CAAC,SAAS,CAAC,OAAO,GAAG,YAAY,CAAC","file":"groupby.js","sourcesContent":["import { IterableX } from '../../iterable/iterablex';\nimport { groupBy, GroupedIterable, groupByResultIdentity } from '../../iterable/groupby';\nimport { identity } from '../../internal/identity';\n\nexport function groupByProto<TSource, TKey>(\n  this: IterableX<TSource>,\n  keySelector: (value: TSource) => TKey\n): IterableX<GroupedIterable<TKey, TSource>>;\nexport function groupByProto<TSource, TKey, TValue>(\n  this: IterableX<TSource>,\n  keySelector: (value: TSource) => TKey,\n  elementSelector?: (value: TSource) => TValue\n): IterableX<GroupedIterable<TKey, TValue>>;\nexport function groupByProto<TSource, TKey, TValue, TResult>(\n  this: IterableX<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (value: TSource) => TValue | Promise<TValue>,\n  resultSelector?: (key: TKey, values: Iterable<TValue>) => TResult\n): IterableX<TResult>;\n/**\n * @ignore\n */\nexport function groupByProto<TSource, TKey, TValue, TResult>(\n  this: IterableX<TSource>,\n  keySelector: (value: TSource) => TKey,\n  elementSelector: (value: TSource) => TValue = identity,\n  resultSelector: (key: TKey, values: Iterable<TValue>) => TResult = groupByResultIdentity\n): IterableX<TResult> {\n  return groupBy<TSource, TKey, TValue, TResult>(\n    this,\n    keySelector,\n    elementSelector,\n    resultSelector\n  );\n}\n\nIterableX.prototype.groupBy = groupByProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    groupBy: typeof groupByProto;\n  }\n}\n"]}