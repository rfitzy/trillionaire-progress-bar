{"version":3,"sources":["webpack/universalModuleDefinition","webpack/bootstrap","internal/bindcallback.ts","internal/identity.ts","internal/tolength.ts","internal/tointeger.ts","internal/isiterable.ts","iterable/iterablex.ts","iterable/average.ts","iterable/buffer.ts","iterable/defer.ts","iterable/empty.ts","iterable/case.ts","internal/returniterator.ts","iterable/catch.ts","iterable/catchwith.ts","iterable/chain.ts","iterable/concat.ts","iterable/concatall.ts","iterable/count.ts","iterable/create.ts","iterable/defaultifempty.ts","internal/arrayindexof.ts","internal/comparer.ts","iterable/distinct.ts","iterable/distinctuntilchanged.ts","iterable/while.ts","iterable/dowhile.ts","iterable/elementat.ts","iterable/endwith.ts","iterable/every.ts","iterable/except.ts","iterable/expand.ts","iterable/filter.ts","iterable/finally.ts","iterable/find.ts","iterable/findindex.ts","iterable/first.ts","iterable/flatmap.ts","iterable/flatten.ts","iterable/map.ts","iterable/for.ts","iterable/generate.ts","iterable/_grouping.ts","iterable/groupby.ts","iterable/groupjoin.ts","iterable/if.ts","iterable/ignoreelements.ts","iterable/includes.ts","iterable/innerjoin.ts","iterable/intersect.ts","iterable/isempty.ts","iterable/last.ts","iterable/max.ts","iterable/_extremaby.ts","iterable/maxby.ts","iterable/_refcountlist.ts","iterable/memoize.ts","iterable/min.ts","iterable/minby.ts","iterable/ofentries.ts","iterable/ofkeys.ts","iterable/ofvalues.ts","iterable/onerrorresumenext.ts","internal/sorter.ts","iterable/orderby.ts","iterable/pairwise.ts","iterable/partition.ts","iterable/pipe.ts","iterable/pluck.ts","iterable/publish.ts","iterable/range.ts","iterable/reduce.ts","iterable/toarray.ts","iterable/reduceright.ts","iterable/repeat.ts","iterable/retry.ts","iterable/reverse.ts","iterable/scan.ts","iterable/scanright.ts","iterable/sequenceequal.ts","iterable/share.ts","iterable/single.ts","iterable/skip.ts","iterable/skiplast.ts","iterable/skipwhile.ts","iterable/slice.ts","iterable/some.ts","iterable/startwith.ts","iterable/sum.ts","iterable/take.ts","iterable/takelast.ts","iterable/takewhile.ts","iterable/tap.ts","iterable/throw.ts","asyncsink.ts","asynciterable/asynciterablex.ts","asynciterable/create.ts","asynciterable/memoize.ts","asynciterable/publish.ts","add/asynciterable-operators/publish.ts","add/asynciterable-operators/todomstream.ts","asynciterable/fromdomstream.ts","asynciterable/todomstream.ts","iterable/todomstream.ts","iterable/tomap.ts","iterable/toset.ts","add/iterable-operators/publish.ts","add/iterable-operators/todomstream.ts","iterable/union.ts","iterable/zip.ts","iterable/pipe/buffer.ts","iterable/pipe/catch.ts","iterable/pipe/catchwith.ts","iterable/pipe/concat.ts","iterable/pipe/concatall.ts","iterable/pipe/defaultifempty.ts","iterable/pipe/distinct.ts","iterable/pipe/distinctuntilchanged.ts","iterable/pipe/dowhile.ts","iterable/pipe/endwith.ts","iterable/pipe/except.ts","iterable/pipe/expand.ts","iterable/pipe/filter.ts","iterable/pipe/finally.ts","iterable/pipe/flatmap.ts","iterable/pipe/flatten.ts","iterable/pipe/groupby.ts","iterable/pipe/groupjoin.ts","iterable/pipe/ignoreelements.ts","iterable/pipe/innerjoin.ts","iterable/pipe/intersect.ts","iterable/pipe/map.ts","iterable/pipe/maxby.ts","iterable/pipe/memoize.ts","iterable/pipe/minby.ts","iterable/pipe/onerrorresumenext.ts","iterable/pipe/orderby.ts","iterable/pipe/pairwise.ts","iterable/pipe/pluck.ts","iterable/pipe/publish.ts","iterable/pipe/repeat.ts","iterable/pipe/retry.ts","iterable/pipe/reverse.ts","iterable/pipe/scan.ts","iterable/pipe/scanright.ts","iterable/pipe/share.ts","iterable/pipe/skip.ts","iterable/pipe/skiplast.ts","iterable/pipe/skipwhile.ts","iterable/pipe/slice.ts","iterable/pipe/startwith.ts","iterable/pipe/take.ts","iterable/pipe/takelast.ts","iterable/pipe/takewhile.ts","iterable/pipe/tap.ts","iterable/pipe/todomstream.ts","iterable/pipe/union.ts","iterable/pipe/zip.ts","asynciterable/asyncify.ts","asynciterable/asyncifyerrback.ts","asynciterable/average.ts","asynciterable/batch.ts","asynciterable/buffer.ts","asynciterable/defer.ts","asynciterable/empty.ts","asynciterable/case.ts","asynciterable/catch.ts","asynciterable/catchwith.ts","asynciterable/chain.ts","asynciterable/combinelatest.ts","asynciterable/concat.ts","asynciterable/concatall.ts","asynciterable/count.ts","asynciterable/debounce.ts","asynciterable/defaultifempty.ts","asynciterable/distinct.ts","asynciterable/distinctuntilchanged.ts","asynciterable/while.ts","asynciterable/dowhile.ts","asynciterable/elementat.ts","asynciterable/endwith.ts","asynciterable/every.ts","asynciterable/except.ts","asynciterable/expand.ts","asynciterable/filter.ts","asynciterable/finally.ts","asynciterable/find.ts","asynciterable/findindex.ts","asynciterable/first.ts","asynciterable/flatmap.ts","asynciterable/flatten.ts","asynciterable/map.ts","asynciterable/for.ts","asynciterable/forkjoin.ts","asynciterable/fromeventpattern.ts","asynciterable/fromevent.ts","asynciterable/generate.ts","asynciterable/_sleep.ts","asynciterable/generatetime.ts","asynciterable/_grouping.ts","asynciterable/groupby.ts","asynciterable/groupjoin.ts","asynciterable/if.ts","asynciterable/ignoreelements.ts","asynciterable/includes.ts","asynciterable/innerjoin.ts","asynciterable/intersect.ts","asynciterable/isempty.ts","asynciterable/last.ts","asynciterable/max.ts","asynciterable/_extremaby.ts","asynciterable/maxby.ts","asynciterable/merge.ts","asynciterable/mergeall.ts","asynciterable/min.ts","asynciterable/minby.ts","asynciterable/ofentries.ts","asynciterable/ofkeys.ts","asynciterable/ofvalues.ts","asynciterable/onerrorresumenext.ts","asynciterable/toarray.ts","asynciterable/orderby.ts","asynciterable/pairwise.ts","asynciterable/partition.ts","asynciterable/pluck.ts","asynciterable/race.ts","asynciterable/range.ts","asynciterable/reduce.ts","asynciterable/reduceright.ts","asynciterable/repeat.ts","asynciterable/retry.ts","asynciterable/reverse.ts","asynciterable/scan.ts","asynciterable/scanright.ts","asynciterable/sequenceequal.ts","asynciterable/share.ts","asynciterable/single.ts","asynciterable/skip.ts","asynciterable/skiplast.ts","asynciterable/skipuntil.ts","asynciterable/skipwhile.ts","asynciterable/slice.ts","asynciterable/some.ts","asynciterable/startwith.ts","asynciterable/sum.ts","asynciterable/take.ts","asynciterable/takelast.ts","asynciterable/takeuntil.ts","asynciterable/takewhile.ts","internal/toobserver.ts","asynciterable/tap.ts","asynciterable/throttle.ts","asynciterable/timeinterval.ts","asynciterable/timeout.ts","asynciterable/timestamp.ts","asynciterable/throw.ts","asynciterable/tomap.ts","observer.ts","asynciterable/toobservable.ts","asynciterable/toset.ts","asynciterable/union.ts","asynciterable/zip.ts","asynciterable/pipe/buffer.ts","asynciterable/pipe/catch.ts","asynciterable/pipe/catchwith.ts","asynciterable/pipe/concat.ts","asynciterable/pipe/concatall.ts","asynciterable/pipe/debounce.ts","asynciterable/pipe/defaultifempty.ts","asynciterable/delay.ts","asynciterable/pipe/delay.ts","asynciterable/delayeach.ts","asynciterable/pipe/delayeach.ts","asynciterable/pipe/distinct.ts","asynciterable/pipe/distinctuntilchanged.ts","asynciterable/pipe/dowhile.ts","asynciterable/pipe/endwith.ts","asynciterable/pipe/except.ts","asynciterable/pipe/expand.ts","asynciterable/pipe/filter.ts","asynciterable/pipe/finally.ts","asynciterable/pipe/flatmap.ts","asynciterable/pipe/flatten.ts","asynciterable/pipe/groupby.ts","asynciterable/pipe/groupjoin.ts","asynciterable/pipe/ignoreelements.ts","asynciterable/pipe/innerjoin.ts","asynciterable/pipe/intersect.ts","asynciterable/pipe/map.ts","asynciterable/pipe/maxby.ts","asynciterable/pipe/memoize.ts","asynciterable/pipe/merge.ts","asynciterable/pipe/mergeall.ts","asynciterable/pipe/minby.ts","asynciterable/pipe/onerrorresumenext.ts","asynciterable/pipe/orderby.ts","asynciterable/pipe/pairwise.ts","asynciterable/pipe/pluck.ts","asynciterable/pipe/publish.ts","asynciterable/pipe/repeat.ts","asynciterable/pipe/retry.ts","asynciterable/pipe/reverse.ts","asynciterable/pipe/scan.ts","asynciterable/pipe/scanright.ts","asynciterable/pipe/share.ts","asynciterable/pipe/skip.ts","asynciterable/pipe/skiplast.ts","asynciterable/pipe/skipuntil.ts","asynciterable/pipe/skipwhile.ts","asynciterable/pipe/slice.ts","asynciterable/pipe/startwith.ts","asynciterable/pipe/take.ts","asynciterable/pipe/takelast.ts","asynciterable/pipe/takeuntil.ts","asynciterable/pipe/takewhile.ts","asynciterable/pipe/tap.ts","asynciterable/pipe/throttle.ts","asynciterable/pipe/timeinterval.ts","asynciterable/pipe/timeout.ts","asynciterable/pipe/timestamp.ts","asynciterable/pipe/todomstream.ts","asynciterable/pipe/union.ts","asynciterable/pipe/zip.ts","add/iterable/case.ts","add/iterable/catch.ts","add/iterable/concat.ts","add/iterable/create.ts","add/iterable/defer.ts","add/iterable/empty.ts","add/iterable/for.ts","add/iterable/generate.ts","add/iterable/if.ts","add/iterable/ofentries.ts","add/iterable/ofkeys.ts","add/iterable/ofvalues.ts","add/iterable/onerrorresumenext.ts","add/iterable/range.ts","add/iterable/repeat.ts","add/iterable/throw.ts","add/iterable/while.ts","add/iterable/zip.ts","add/iterable-operators/average.ts","add/iterable-operators/buffer.ts","add/iterable-operators/catch.ts","add/iterable-operators/catchwith.ts","add/iterable-operators/chain.ts","add/iterable-operators/concatall.ts","add/iterable-operators/concat.ts","add/iterable-operators/count.ts","add/iterable-operators/defaultifempty.ts","add/iterable-operators/distinct.ts","add/iterable-operators/distinctuntilchanged.ts","add/iterable-operators/dowhile.ts","add/iterable-operators/elementat.ts","add/iterable-operators/endwith.ts","add/iterable-operators/every.ts","add/iterable-operators/except.ts","add/iterable-operators/expand.ts","add/iterable-operators/filter.ts","add/iterable-operators/finally.ts","add/iterable-operators/findindex.ts","add/iterable-operators/find.ts","add/iterable-operators/first.ts","add/iterable-operators/flatmap.ts","add/iterable-operators/flatten.ts","add/iterable-operators/groupby.ts","add/iterable-operators/groupjoin.ts","add/iterable-operators/ignoreelements.ts","add/iterable-operators/includes.ts","add/iterable-operators/innerjoin.ts","add/iterable-operators/intersect.ts","add/iterable-operators/isempty.ts","add/iterable-operators/last.ts","add/iterable-operators/map.ts","add/iterable-operators/maxby.ts","add/iterable-operators/max.ts","add/iterable-operators/memoize.ts","add/iterable-operators/minby.ts","add/iterable-operators/min.ts","add/iterable-operators/onerrorresumenext.ts","add/iterable-operators/orderby.ts","add/iterable-operators/pairwise.ts","add/iterable-operators/partition.ts","add/iterable-operators/pluck.ts","add/iterable-operators/reduceright.ts","add/iterable-operators/reduce.ts","add/iterable-operators/repeat.ts","add/iterable-operators/retry.ts","add/iterable-operators/reverse.ts","add/iterable-operators/scanright.ts","add/iterable-operators/scan.ts","add/iterable-operators/sequenceequal.ts","add/iterable-operators/share.ts","add/iterable-operators/single.ts","add/iterable-operators/skiplast.ts","add/iterable-operators/skip.ts","add/iterable-operators/skipwhile.ts","add/iterable-operators/slice.ts","add/iterable-operators/some.ts","add/iterable-operators/startwith.ts","add/iterable-operators/sum.ts","add/iterable-operators/takelast.ts","add/iterable-operators/take.ts","add/iterable-operators/takewhile.ts","add/iterable-operators/tap.ts","add/iterable-operators/toarray.ts","add/iterable-operators/tomap.ts","add/iterable-operators/toset.ts","add/iterable-operators/union.ts","add/iterable-operators/zip.ts","add/asynciterable/asyncifyerrback.ts","add/asynciterable/asyncify.ts","add/asynciterable/case.ts","add/asynciterable/catch.ts","add/asynciterable/combinelatest.ts","add/asynciterable/concat.ts","add/asynciterable/create.ts","add/asynciterable/defer.ts","add/asynciterable/empty.ts","add/asynciterable/forkjoin.ts","add/asynciterable/for.ts","add/asynciterable/fromeventpattern.ts","add/asynciterable/fromevent.ts","add/asynciterable/generatetime.ts","add/asynciterable/generate.ts","add/asynciterable/if.ts","add/asynciterable/merge.ts","add/asynciterable/ofentries.ts","add/asynciterable/ofkeys.ts","add/asynciterable/onerrorresumenext.ts","add/asynciterable/race.ts","add/asynciterable/range.ts","add/asynciterable/repeat.ts","add/asynciterable/throw.ts","add/asynciterable/while.ts","add/asynciterable/zip.ts","add/asynciterable-operators/average.ts","add/asynciterable-operators/batch.ts","add/asynciterable-operators/buffer.ts","add/asynciterable-operators/catch.ts","add/asynciterable-operators/catchwith.ts","add/asynciterable-operators/chain.ts","add/asynciterable-operators/combinelatest.ts","add/asynciterable-operators/concatall.ts","add/asynciterable-operators/concat.ts","add/asynciterable-operators/count.ts","add/asynciterable-operators/debounce.ts","add/asynciterable-operators/defaultifempty.ts","add/asynciterable-operators/distinct.ts","add/asynciterable-operators/distinctuntilchanged.ts","add/asynciterable-operators/dowhile.ts","add/asynciterable-operators/elementat.ts","add/asynciterable-operators/endwith.ts","add/asynciterable-operators/every.ts","add/asynciterable-operators/except.ts","add/asynciterable-operators/expand.ts","add/asynciterable-operators/filter.ts","add/asynciterable-operators/finally.ts","add/asynciterable-operators/findindex.ts","add/asynciterable-operators/find.ts","add/asynciterable-operators/first.ts","add/asynciterable-operators/flatmap.ts","add/asynciterable-operators/flatten.ts","add/asynciterable-operators/forkjoin.ts","add/asynciterable-operators/groupby.ts","add/asynciterable-operators/groupjoin.ts","add/asynciterable-operators/ignoreelements.ts","add/asynciterable-operators/includes.ts","add/asynciterable-operators/innerjoin.ts","add/asynciterable-operators/intersect.ts","add/asynciterable-operators/isempty.ts","add/asynciterable-operators/last.ts","add/asynciterable-operators/map.ts","add/asynciterable-operators/maxby.ts","add/asynciterable-operators/max.ts","add/asynciterable-operators/memoize.ts","add/asynciterable-operators/mergeall.ts","add/asynciterable-operators/merge.ts","add/asynciterable-operators/minby.ts","add/asynciterable-operators/min.ts","add/asynciterable-operators/onerrorresumenext.ts","add/asynciterable-operators/orderby.ts","add/asynciterable-operators/pairwise.ts","add/asynciterable-operators/partition.ts","add/asynciterable-operators/pluck.ts","add/asynciterable-operators/reduceright.ts","add/asynciterable-operators/reduce.ts","add/asynciterable-operators/repeat.ts","add/asynciterable-operators/retry.ts","add/asynciterable-operators/reverse.ts","add/asynciterable-operators/scanright.ts","add/asynciterable-operators/scan.ts","add/asynciterable-operators/sequenceequal.ts","add/asynciterable-operators/share.ts","add/asynciterable-operators/single.ts","add/asynciterable-operators/skiplast.ts","add/asynciterable-operators/skip.ts","add/asynciterable-operators/skipuntil.ts","add/asynciterable-operators/skipwhile.ts","add/asynciterable-operators/slice.ts","add/asynciterable-operators/some.ts","add/asynciterable-operators/startwith.ts","add/asynciterable-operators/sum.ts","add/asynciterable-operators/takelast.ts","add/asynciterable-operators/take.ts","add/asynciterable-operators/takeuntil.ts","add/asynciterable-operators/takewhile.ts","add/asynciterable-operators/tap.ts","add/asynciterable-operators/throttle.ts","add/asynciterable-operators/toarray.ts","add/asynciterable-operators/tomap.ts","add/asynciterable-operators/toobservable.ts","add/asynciterable-operators/toset.ts","add/asynciterable-operators/union.ts","add/asynciterable-operators/zip.ts","Ix.ts","add/asynciterable/fromdomstream.ts","Ix.dom.internal.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","bindCallback","func","thisArg","argCount","arg","index","collection","apply","arguments","identity","x","async","identityAsync","maxSafeInteger","Math","toLength","len","number","isNaN","isFinite","floor","abs","toInteger","min","max","isNumber","isBoolean","isFunction","isObject","isArrayLike","isIterable","iterator","isIterator","isAsyncIterable","asyncIterator","isReadableNodeStream","isWritableNodeStream","iterablex_IterableX","[object Object]","projection","fn","item","this","args","length","acc","as","_getDOMStream","tee","writable","options","pipeTo","duplex","pipeThrough","_DOMStream","publish","toDOMStream","source","OfIterable","iterablex_FromIterable","selector","TypeError","super","_source","_fn","val","_args","isBrowser","document","nodeType","pipe","end","next","prev","toNodeStream","readableOpts","opts","_writableState","objectMode","e","average","sum","count","Error","buffer_BufferIterable","skip","_count","_skip","buffers","push","buffer","shift","defer_DeferIterable","defer","empty_EmptyIterable","empty","_case","sources","defaultSource","has","returnIterator","it","return","returnAsyncIterator","catch_CatchIterable","error","hasError","done","_catch","_catchStatic","catchwith_CatchWithIterable","handler","_handler","err","catchWith","chain_ChainIterable","result","_result","chain","concat_ConcatIterable","outer","concat","concatStatic","concatAll","count_count","predicate","create_AnonymousIterable","getIterator","defaultifempty_DefaultIfEmptyIterable","defaultValue","_defaultValue","state","defaultIfEmpty","arrayIndexOf","array","comparer","arrayIndexOfAsync","comparer_comparer","y","comparerAsync","distinct_DistinctIterable","keySelector","cmp","_keySelector","_cmp","set","distinct","distinctuntilchanged_DistinctUntilChangedIterable","_comparer","currentKey","hasCurrentKey","comparerEquals","distinctUntilChanged","while_WhileIterable","condition","_condition","_while","doWhile","elementAt","endwith_EndWithIterable","endWith","every","except_ExceptIterable","first","second","_first","_second","map","secondItem","firstItem","except","expand_ExpandIterable","q","src","expand","filter_FilterIterable","_predicate","filter","finally_FinallyIterable","action","_action","_finally","find","f","findIndex","first_first","flatmap_FlatMapIterable","outerItem","innerItem","flatMap","flatten_FlattenIterable","depth","_depth","_flatten","flatten","Infinity","map_MapIterable","_selector","map_map","_for","resultSelector","generate_GenerateIterable","initialState","iterate","_initialState","_iterate","_resultSelector","generate","createGrouping","elementSelector","Map","grouping","groupby_GroupedIterable","groupby_GroupByIterable","_elementSelector","values","groupByResultIdentity","groupBy","groupjoin_GroupJoinIterable","inner","outerSelector","innerSelector","_outer","_inner","_outerSelector","_innerSelector","outerElement","outerKey","innerElements","groupJoin","_if","thenSource","elseSource","ignoreelements_IgnoreElementsIterable","ignoreElements","includes","searchElement","fromIndex","innerjoin_JoinIterable","innerElement","innerJoin","arrayRemove","idx","splice","intersect_IntersectIterable","intersect","isEmpty","_","last","atleastOnce","defaultCompare","minValue","_extremaby_ExtremaByIterable","keyFn","_keyFn","current","resKey","curr","extremaBy","maxBy","MaxRefCountList","_list","RefCountList","readerCount","_readerCount","clear","res","delete","memoize_MemoizeBuffer","_stopped","_buffer","hasValue","_error","memoize","minBy","ofentries_OfEntriesIterable","keys","makeTuple","ofEntries","ofkeys_OfKeysIterable","ofKeys","ofvalues_OfValuesIterable","ofValues","onerrorresumenext_OnErrorResumeNextIterable","onErrorResumeNext","sorter","fst","snd","orderby_OrderedIterableBaseX","Array","from","indices","sort","_getSorter","OrderedIterableX","descending","parent","_descending","_parent","elements","orderBy","orderByDescending","thenBy","thenByDescending","pairwise_PairwiseIterable","pairwise","partition","operations","input","reduce","piped","pluck","props","currentProp","publish_PublishedBuffer","_getIterable","range_RangeIterable","start","_start","range","accumulator","seed","hasSeed","toArray","results","reduceRight","offset","repeat_RepeatIterable","repeat","repeatStatic","of","retry","_catchAll","reverse_ReverseIterable","unshift","reverse","scan_ScanIterable","_hasSeed","_seed","scan","scanright_ScanRightIterable","scanRight","sequenceEqual","other","it1","it2","next1","next2","share_SharedIterable","_it","share","single","hasResult","skip_SkipIterable","skip_skip","skiplast_SkipLastIterable","skipLast","skipwhile_SkipWhileIterable","yielding","element","skipWhile","slice_SliceIterable","begin","_begin","_end","slice","some","startwith_StartWithIterable","startWith","sum_sum","take_TakeIterable","take","takelast_TakeLastIterable","takeLast","takewhile_TakeWhileIterable","takeWhile","tap_TapIterable","observer","_observer","complete","tap","throw_ThrowIterable","_throw","ARRAY_VALUE","ARRAY_ERROR","AsyncSink","_ended","_values","_resolvers","_push","type","resolve","reject","Promise","asynciterablex_AsyncIterableX","OfAsyncIterable","FromAsyncIterable","asynciterablex_isPromise","FromPromiseIterable","isObservable","asynciterablex_FromObservableAsyncIterable","asynciterablex_FromArrayIterable","observable","_observable","sink","subscription","subscribe","write","unsubscribe","create_AnonymousAsyncIterable","create_create","memoize_MemoizeAsyncBuffer","_shared","then","catch","memoize_memoize","publish_PublishedAsyncBuffer","publish_publish","SharedArrayBuf","SharedArrayBuffer","ArrayBuffer","fromdomstream_AsyncIterableReadableStream","_stream","stream","reader","_consumeReader","read","defaultReaderToAsyncIterator","fromdomstream_AsyncIterableReadableByteStream","readNext","byobReaderToAsyncIterator","threw","locked","closed","releaseLock","bufferOrLen","size","byteLength","undefined","readInto","Uint8Array","fromDOMStream","AbstractUnderlyingSource","UnderlyingAsyncIterableDefaultSource","controller","desiredSize","enqueue","close","UnderlyingAsyncIterableByteSource","autoAllocateChunkSize","fallbackDefaultSource","byobRequest","pull","view","respond","isView","respondWithNewView","target","targetByteOffset","sourceByteLength","targetByteLength","dst","byteOffset","memcpy","asyncIterableReadableStream","AsyncIterableReadableByteStream_","AsyncIterableDefaultReadableStream_","createAsyncIterableReadableStream","ReadableStream","createAsyncIterableReadableStreamEveryOtherTime","todomstream_toDOMStream","toMap","toSet","Set","add","union_UnionIterable","left","right","_left","_right","lItem","rItem","union","zip_ZipIterable","_sources","sourcesLength","its","forEach","zip","buffer_buffer","catch_catch","catchwith_catchWith","concat_concat","concatall_concatAll","defaultifempty_defaultIfEmpty","distinct_distinct","distinctuntilchanged_distinctUntilChanged","dowhile_doWhile","endwith_endWith","except_except","expand_expand","filter_filter","finally_finally","flatmap_flatMap","flatten_flatten","groupby_groupBy","groupjoin_groupJoin","ignoreelements_ignoreElements","innerjoin_innerJoin","intersect_intersect","pipe_map_map","maxby_maxBy","pipe_memoize_memoize","minby_minBy","onerrorresumenext_onErrorResumeNext","orderby_orderBy","orderby_orderByDescending","orderby_thenBy","orderSource","orderby_thenByDescending","pairwise_pairwise","pluck_pluck","pipe_publish_publish","repeat_repeat","retry_retry","reverse_reverse","scan_scan","scanright_scanRight","share_share","pipe_skip_skip","skiplast_skipLast","skipwhile_skipWhile","slice_slice","startwith_startWith","take_take","takelast_takeLast","takewhile_takeWhile","tap_tap","pipe_todomstream_toDOMStream","union_union","zip_zip","asyncify","innerArgs","asyncifyErrback","average_average","batch_BatchAsyncIterable","ended","consumeNext","resolver","assertNever","batch","buffer_BufferAsyncIterable","asynciterable_buffer_buffer","defer_DeferAsyncIterable","items","defer_defer","empty_EmptyAsyncIterable","empty_empty","case_case","catch_CatchAllAsyncIterable","catch_catchAll","asynciterable_catch_catch","catch_catchStatic","catchwith_CatchWithAsyncIterable","asynciterable_catchwith_catchWith","chain_ChainAsyncIterable","chain_chain","NEVER_PROMISE","wrapPromiseWithIndex","promise","combinelatest_CombineLatestAsyncIterable","iterators","nexts","hasValueAll","hasValues","active","fill","race","next$","iterator$","combineLatest","concat_ConcatAsyncIterable","asynciterable_concat_concat","concat_concatStatic","concatall_ConcatAllAsyncIterable","asynciterable_concatall_concatAll","asynciterable_count_count","debounce_DebounceAsyncIterable","time","_time","noValue","lastItem","deferred","reset","hasNoValue","run","setTimeout","debounce","defaultifempty_DefaultIfEmptyAsyncIterable","asynciterable_defaultifempty_defaultIfEmpty","distinct_DistinctAsyncIterable","asynciterable_distinct_distinct","distinctuntilchanged_DistinctUntilChangedAsyncIterable","asynciterable_distinctuntilchanged_distinctUntilChanged","while_WhileAsyncIterable","while_while","asynciterable_dowhile_doWhile","elementat_elementAt","endwith_EndWithAsyncIterable","asynciterable_endwith_endWith","every_every","except_ExceptAsyncIterable","asynciterable_except_except","expand_ExpandAsyncIterable","asynciterable_expand_expand","filter_FilterAsyncIterable","asynciterable_filter_filter","finally_FinallyAsyncIterable","asynciterable_finally_finally","find_find","findindex_findIndex","asynciterable_first_first","flatmap_FlatMapAsyncIterable","inners","asynciterable_flatmap_flatMap","flatten_FlattenAsyncIterable","asynciterable_flatten_flatten","map_MapAsyncIterable","asynciterable_map_map","for_for","forkjoin_NEVER_PROMISE","forkjoin_wrapPromiseWithIndex","forkJoin","fromEventPattern","addHandler","removeHandler","fromEvent","obj","addEventListener","removeEventListener","isEventTarget","h","addListener","removeListener","isNodeEventEmitter","generate_GenerateAsyncIterable","generate_generate","sleep","dueTime","generatetime_GenerateTimeAsyncIterable","timeSelector","_timeSelector","generateTime","_grouping_createGrouping","groupby_GroupedAsyncIterable","groupby_GroupByAsyncIterable","groupByResultIdentityAsync","asynciterable_groupby_groupBy","groupjoin_GroupJoinAsyncIterable","asynciterable_groupjoin_groupJoin","if_if","ignoreelements_IgnoreElementsAsyncIterable","asynciterable_ignoreelements_ignoreElements","includes_includes","innerjoin_JoinAsyncIterable","asynciterable_innerjoin_innerJoin","intersect_arrayRemove","intersect_IntersectAsyncIterable","asynciterable_intersect_intersect","isempty_isEmpty","last_last","max_max","defaultCompareAsync","_extremaby_ExtremaByAsyncIterator","_extremaby_extremaBy","asynciterable_maxby_maxBy","merge_NEVER_PROMISE","merge_wrapPromiseWithIndex","merge_MergeAsyncIterable","merge","mergeAll","min_min","asynciterable_minby_minBy","ofentries_OfEntriesAsyncIterable","ofentries_makeTuple","ofentries_ofEntries","ofkeys_OfKeysAsyncIterable","ofkeys_ofKeys","ofvalues_OfValuesAsyncIterable","ofvalues_ofValues","onerrorresumenext_OnErrorResumeNextAsyncIterable","asynciterable_onerrorresumenext_onErrorResumeNext","onerrorresumenext_onErrorResumeNextStatic","toarray_toArray","orderby_OrderedAsyncIterableBaseX","OrderedAsyncIterableX","asynciterable_orderby_orderBy","asynciterable_orderby_orderByDescending","asynciterable_orderby_thenBy","asynciterable_orderby_thenByDescending","pairwise_PairwiseAsyncIterable","asynciterable_pairwise_pairwise","partition_partition","asynciterable_pluck_pluck","race_RaceAsyncIterable","leftIt","rightIt","otherIterator","resultIterator","range_RangeAsyncIterable","range_range","reduce_reduce","reduceright_reduceRight","repeat_RepeatAsyncIterable","asynciterable_repeat_repeat","repeat_repeatStatic","asynciterable_retry_retry","reverse_ReverseAsyncIterable","asynciterable_reverse_reverse","scan_ScanAsyncIterable","asynciterable_scan_scan","scanright_ScanRightAsyncIterable","asynciterable_scanright_scanRight","sequenceequal_sequenceEqual","share_SharedAsyncIterable","asynciterable_share_share","single_single","skip_SkipAsyncIterable","asynciterable_skip_skip","skiplast_SkipLastAsyncIterable","asynciterable_skiplast_skipLast","skipuntil_SkipUntilAsyncIterable","_other","otherDone","skipUntil","skipwhile_SkipWhileAsyncIterable","asynciterable_skipwhile_skipWhile","slice_SliceAsyncIterable","asynciterable_slice_slice","some_some","startwith_StartWithAsyncIterable","asynciterable_startwith_startWith","asynciterable_sum_sum","take_TakeAsyncIterable","asynciterable_take_take","takelast_TakeLastAsyncIterable","asynciterable_takelast_takeLast","takeuntil_TakeUntilAsyncIterable","takeUntil","takewhile_TakeWhileAsyncIterable","asynciterable_takewhile_takeWhile","noop","toObserver","tap_TapAsyncIterable","asynciterable_tap_tap","observerOrNext","throttle_ThrottleAsyncIterable","currentTime","previousTime","Date","now","throttle","timeinterval_TimeIntervalAsyncIterable","span","elapsed","timeInterval","TimeoutError","setPrototypeOf","message","VALUE_TYPE","ERROR_TYPE","timeout_TimeoutAsyncIterable","_dueTime","timeout","timestamp_TimestampAsyncIterable","timestamp","throw_ThrowAsyncIterable","throw_throw","tomap_toMap","BooleanSubscription","isUnsubscribed","toobservable_AsyncIterableObservable","toObservable","toset_toSet","union_UnionAsyncIterable","asynciterable_union_union","zip_ZipAsyncIterable","all","asynciterable_zip_zip","pipe_buffer_buffer","pipe_catch_catch","pipe_catchwith_catchWith","pipe_concat_concat","pipe_concatall_concatAll","debounce_debounce","pipe_defaultifempty_defaultIfEmpty","delay_DelayAsyncIterable","delay_delay","delayeach_DelayEachAsyncIterable","delayeach_delayEach","pipe_distinct_distinct","pipe_distinctuntilchanged_distinctUntilChanged","pipe_dowhile_doWhile","pipe_endwith_endWith","pipe_except_except","pipe_expand_expand","pipe_filter_filter","pipe_finally_finally","pipe_flatmap_flatMap","pipe_flatten_flatten","pipe_groupby_groupBy","pipe_groupjoin_groupJoin","pipe_ignoreelements_ignoreElements","pipe_innerjoin_innerJoin","pipe_intersect_intersect","asynciterable_pipe_map_map","pipe_maxby_maxBy","asynciterable_pipe_memoize_memoize","merge_merge","mergeall_mergeAll","pipe_minby_minBy","pipe_onerrorresumenext_onErrorResumeNext","pipe_orderby_orderBy","pipe_orderby_orderByDescending","pipe_orderby_thenBy","pipe_orderby_thenByDescending","pipe_pairwise_pairwise","pipe_pluck_pluck","asynciterable_pipe_publish_publish","pipe_repeat_repeat","pipe_retry_retry","pipe_reverse_reverse","pipe_scan_scan","pipe_scanright_scanRight","pipe_share_share","asynciterable_pipe_skip_skip","pipe_skiplast_skipLast","skipuntil_skipUntil","pipe_skipwhile_skipWhile","pipe_slice_slice","pipe_startwith_startWith","pipe_take_take","pipe_takelast_takeLast","takeuntil_takeUntil","pipe_takewhile_takeWhile","pipe_tap_tap","throttle_throttle","timeinterval_timeInterval","timeout_timeout","timestamp_timestamp","asynciterable_pipe_todomstream_toDOMStream","pipe_union_union","pipe_zip_zip","case","for","if","throw","while","finally","arg1","Ix","Iterable","AsyncIterable","symbolObservable","__webpack_exports__","iterable_namespaceObject","iterable_pipe_namespaceObject","asynciterable_namespaceObject","asynciterable_pipe_namespaceObject"],"mappings":"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","file":"Ix.dom.internal.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Ix\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Ix\"] = factory();\n\telse\n\t\troot[\"Ix\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * @ignore\n */\nexport function bindCallback(func: any, thisArg: any, argCount: number) {\n  if (typeof thisArg === 'undefined') {\n    return func;\n  }\n  switch (argCount) {\n    case 0:\n      return function() {\n        return func.call(thisArg);\n      };\n    case 1:\n      return function(arg: any) {\n        return func.call(thisArg, arg);\n      };\n    case 2:\n      return function(value: any, index: number) {\n        return func.call(thisArg, value, index);\n      };\n    case 3:\n      return function(value: any, index: number, collection: any[]) {\n        return func.call(thisArg, value, index, collection);\n      };\n  }\n\n  return function() {\n    return func.apply(thisArg, arguments);\n  };\n}\n","/**\n * @ignore\n */\nexport function identity(x: any) {\n  return x;\n}\n\n/**\n * @ignore\n */\nexport async function identityAsync(x: any) {\n  return x;\n}\n","import { toInteger } from './tointeger';\nconst maxSafeInteger = Math.pow(2, 53) - 1;\n\n/**\n * @ignore\n */\nexport function toLength(value: any): number {\n  const len = toInteger(value);\n  return Math.min(Math.max(len, 0), maxSafeInteger);\n}\n","/**\n * @ignore\n */\nexport function toInteger(value: any): number {\n  const number = Number(value);\n  if (isNaN(number)) {\n    return 0;\n  }\n  if (number === 0 || !isFinite(number)) {\n    return number;\n  }\n  return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));\n}\n","/** @ignore */\nconst isNumber = (x: any) => typeof x === 'number';\n/** @ignore */\nconst isBoolean = (x: any) => typeof x === 'boolean';\n/** @ignore */\nexport const isFunction = (x: any): x is Function => typeof x === 'function';\n/** @ignore */\nexport const isObject = (x: any): x is Object => x != null && Object(x) === x;\n\n/** @ignore */\nexport const isPromise = (x: any): x is PromiseLike<any> => {\n  return isObject(x) && isFunction(x.then);\n};\n\n/** @ignore */\nexport function isArrayLike(x: any): x is ArrayLike<any> {\n  return isObject(x) && isNumber(x['length']);\n}\n\n/** @ignore */\nexport function isIterable(x: any): x is Iterable<any> {\n  return isObject(x) && isFunction(x[Symbol.iterator]);\n}\n\n/** @ignore */\nexport function isIterator(x: any): x is Iterable<any> {\n  return isObject(x) && !isFunction(x[Symbol.iterator]) && isFunction(x['next']);\n}\n\n/** @ignore */\nexport function isAsyncIterable(x: any): x is AsyncIterable<any> {\n  return isObject(x) && isFunction(x[Symbol.asyncIterator]);\n}\n\n/** @ignore */\nexport const isReadableNodeStream = (x: any): x is NodeJS.ReadableStream => {\n  return (\n    isObject(x) &&\n    isFunction(x['pipe']) &&\n    isFunction(x['_read']) &&\n    isBoolean(x['readable']) &&\n    isObject(x['_readableState'])\n  );\n};\n\n/** @ignore */\nexport const isWritableNodeStream = (x: any): x is NodeJS.WritableStream => {\n  return (\n    isObject(x) &&\n    isFunction(x['end']) &&\n    isFunction(x['_write']) &&\n    isBoolean(x['writable']) &&\n    isObject(x['_writableState'])\n  );\n};\n\n/** @ignore */\nexport const isReadableDOMStream = <T = any>(x: any): x is ReadableStream<T> => {\n  return isObject(x) && isFunction(x['cancel']) && isFunction(x['getReader']);\n};\n\n/** @ignore */\nexport const isWritableDOMStream = <T = any>(x: any): x is WritableStream<T> => {\n  return isObject(x) && isFunction(x['abort']) && isFunction(x['getWriter']);\n};\n\n/** @ignore */\nexport const isFetchResponse = (x: any): x is Response => {\n  return isObject(x) && isReadableDOMStream(x['body']);\n};\n","import { OperatorFunction } from '../interfaces';\nimport { bindCallback } from '../internal/bindcallback';\nimport { identity } from '../internal/identity';\nimport { toLength } from '../internal/tolength';\nimport {\n  isArrayLike,\n  isIterable,\n  isIterator,\n  isReadableNodeStream,\n  isWritableNodeStream\n} from '../internal/isiterable';\n\n/**\n * This clas serves as the base for all operations which support [Symbol.iterator].\n */\nexport abstract class IterableX<T> implements Iterable<T> {\n  abstract [Symbol.iterator](): Iterator<T>;\n\n  forEach(projection: (value: T, index: number) => void, thisArg?: any): void {\n    const fn = bindCallback(projection, thisArg, 2);\n    let i = 0;\n    for (let item of this) {\n      fn(item, i++);\n    }\n  }\n\n  pipe<R>(...operations: OperatorFunction<T, R>[]): IterableX<R>;\n  pipe<R extends NodeJS.WritableStream>(writable: R, options?: { end?: boolean }): R;\n  pipe<R>(...args: any[]) {\n    let i = -1;\n    let n = args.length;\n    let acc: any = this;\n    let as = IterableX.as;\n    while (++i < n) {\n      acc = as(args[i](acc));\n    }\n    return acc;\n  }\n\n  tee(): [ReadableStream<T>, ReadableStream<T>] {\n    return this._getDOMStream().tee();\n  }\n\n  pipeTo(writable: WritableStream<T>, options?: PipeOptions) {\n    return this._getDOMStream().pipeTo(writable, options);\n  }\n\n  pipeThrough<R extends ReadableStream<any>>(\n    duplex: { writable: WritableStream<T>; readable: R },\n    options?: PipeOptions\n  ) {\n    return this._getDOMStream().pipeThrough(duplex, options);\n  }\n\n  private _DOMStream?: ReadableStream<T>;\n  private _getDOMStream(): ReadableStream<T> {\n    return this._DOMStream || (this._DOMStream = this.publish().toDOMStream());\n  }\n\n  static as(source: string): IterableX<string>;\n  static as<T extends IterableX<any>>(source: T): T;\n  static as<T>(source: Iterable<T> | Iterator<T> | ArrayLike<T>): IterableX<T>;\n  static as<T>(source: T): IterableX<T>;\n  /** @nocollapse */\n  static as(source: any) {\n    /* tslint:disable */\n    if (source instanceof IterableX) {\n      return source;\n    }\n    if (typeof source === 'string') {\n      return new OfIterable([source]);\n    }\n    if (isIterable(source)) {\n      return new FromIterable(source, identity);\n    }\n    if (isArrayLike(source)) {\n      return new FromIterable(source, identity);\n    }\n    return new OfIterable([source]);\n    /* tslint:enable */\n  }\n\n  /** @nocollapse */\n  static from<TSource, TResult = TSource>(\n    source: Iterable<TSource> | Iterator<TSource> | ArrayLike<TSource>,\n    selector: (value: TSource, index: number) => TResult = identity,\n    thisArg?: any\n  ): IterableX<TResult> {\n    const fn = bindCallback(selector, thisArg, 2);\n    /* tslint:disable */\n    if (isIterable(source)) {\n      return new FromIterable<TSource, TResult>(source, fn);\n    }\n    if (isArrayLike(source)) {\n      return new FromIterable<TSource, TResult>(source, fn);\n    }\n    if (isIterator(source)) {\n      return new FromIterable<TSource, TResult>({ [Symbol.iterator]: () => source }, fn);\n    }\n    throw new TypeError('Input type not supported');\n    /* tslint:enable */\n  }\n\n  /** @nocollapse */\n  static of<TSource>(...args: TSource[]): IterableX<TSource> {\n    //tslint:disable-next-line\n    return new OfIterable<TSource>(args);\n  }\n}\n\nclass FromIterable<TSource, TResult = TSource> extends IterableX<TResult> {\n  private _source: Iterable<TSource> | ArrayLike<TSource>;\n  private _fn: (value: TSource, index: number) => TResult;\n\n  constructor(\n    source: Iterable<TSource> | ArrayLike<TSource>,\n    fn: (value: TSource, index: number) => TResult\n  ) {\n    super();\n    this._source = source;\n    this._fn = fn;\n  }\n\n  *[Symbol.iterator]() {\n    const iterable = isIterable(this._source);\n    let i = 0;\n    if (iterable) {\n      for (let item of <Iterable<TSource>>this._source) {\n        yield this._fn(item, i++);\n      }\n    } else {\n      let length = toLength((<ArrayLike<TSource>>this._source).length);\n      while (i < length) {\n        let val = (<ArrayLike<TSource>>this._source)[i];\n        yield this._fn(val, i++);\n      }\n    }\n  }\n}\n\nclass OfIterable<TSource> extends IterableX<TSource> {\n  private _args: TSource[];\n\n  constructor(args: TSource[]) {\n    super();\n    this._args = args;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this._args;\n  }\n}\n\ntype WritableOrOperatorFunction<T, R> =\n  | NodeJS.WritableStream\n  | NodeJS.ReadWriteStream\n  | OperatorFunction<T, R>;\n\ndeclare module '../iterable/iterablex' {\n  interface IterableX<T> extends Iterable<T> {\n    pipe(): IterableX<T>;\n    pipe<A>(op1: OperatorFunction<T, A>): IterableX<A>;\n    pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): IterableX<B>;\n    pipe<A, B, C>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>\n    ): IterableX<C>;\n    pipe<A, B, C, D>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>\n    ): IterableX<D>;\n    pipe<A, B, C, D, E>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>\n    ): IterableX<E>;\n    pipe<A, B, C, D, E, F>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>\n    ): IterableX<F>;\n    pipe<A, B, C, D, E, F, G>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>,\n      op7: OperatorFunction<F, G>\n    ): IterableX<G>;\n    pipe<A, B, C, D, E, F, G, H>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>,\n      op7: OperatorFunction<F, G>,\n      op8: OperatorFunction<G, H>\n    ): IterableX<H>;\n    pipe<A, B, C, D, E, F, G, H, I>(\n      op1: OperatorFunction<T, A>,\n      op2: OperatorFunction<A, B>,\n      op3: OperatorFunction<B, C>,\n      op4: OperatorFunction<C, D>,\n      op5: OperatorFunction<D, E>,\n      op6: OperatorFunction<E, F>,\n      op7: OperatorFunction<F, G>,\n      op8: OperatorFunction<G, H>,\n      op9: OperatorFunction<H, I>\n    ): IterableX<I>;\n    pipe<R>(...operations: OperatorFunction<T, R>[]): IterableX<R>;\n    pipe<A extends NodeJS.WritableStream>(op1: A, options?: { end?: boolean }): A;\n  }\n}\n\ntry {\n  (isBrowser => {\n    if (isBrowser) {\n      return;\n    }\n\n    const as = IterableX.as;\n    IterableX.prototype.pipe = nodePipe;\n    const readableOpts = (x: any, opts = x._writableState || { objectMode: true }) => opts;\n\n    function nodePipe<T>(this: IterableX<T>, ...args: any[]) {\n      let i = -1;\n      let end: boolean;\n      let n = args.length;\n      let prev: any = this;\n      let next: WritableOrOperatorFunction<T, any>;\n      while (++i < n) {\n        next = args[i];\n        if (typeof next === 'function') {\n          prev = as(next(prev));\n        } else if (isWritableNodeStream(next)) {\n          ({ end = true } = args[i + 1] || {});\n          // prettier-ignore\n          return isReadableNodeStream(prev) ? prev.pipe(next, {end}) :\n             prev.toNodeStream(readableOpts(next)).pipe(next, {end});\n        }\n      }\n      return prev;\n    }\n  })(typeof window === 'object' && typeof document === 'object' && document.nodeType === 9);\n} catch (e) {\n  /* */\n}\n","import { identity } from '../internal/identity';\n\nexport function average(source: Iterable<number>, selector?: (x: number) => number): number;\nexport function average<T>(source: Iterable<T>, selector?: (x: T) => number): number;\n\n/**\n * Computes the average of a sequence of values from the sequence either from the sequence itself\n * or from the selector function.\n * @example\n * // Using non chained version\n * const result = average([1, 2, 3]);\n * const result = Ix.Iterable.of(1, 2, 3).average();\n * console.log(result);\n * @param {Iterable<any>} source A sequence of values to calculate the average of.\n * @param {function(x: any): number} [selector] A transform function to apply to each element.\n * @returns {number} The average of the sequence of values.\n */\nexport function average(source: Iterable<any>, selector: (x: any) => number = identity): number {\n  let sum = 0;\n  let count = 0;\n  for (let item of source) {\n    sum += selector(item);\n    count++;\n  }\n\n  if (count === 0) {\n    throw new Error('Empty collection');\n  }\n\n  return sum / count;\n}\n","import { IterableX } from './iterablex';\n\nexport class BufferIterable<TSource> extends IterableX<TSource[]> {\n  private _source: Iterable<TSource>;\n  private _count: number;\n  private _skip: number;\n\n  constructor(source: Iterable<TSource>, count: number, skip: number) {\n    super();\n    this._source = source;\n    this._count = count;\n    this._skip = skip;\n  }\n\n  *[Symbol.iterator]() {\n    let buffers: TSource[][] = [],\n      i = 0;\n    for (let item of this._source) {\n      if (i % this._skip === 0) {\n        buffers.push([]);\n      }\n\n      for (let buffer of buffers) {\n        buffer.push(item);\n      }\n\n      if (buffers.length > 0 && buffers[0].length === this._count) {\n        yield buffers.shift()!;\n      }\n\n      i++;\n    }\n\n    while (buffers.length > 0) {\n      yield buffers.shift()!;\n    }\n  }\n}\n\n/**\n * Generates a sequence of buffers over the source sequence, with specified length and possible overlap.\n * @example <caption>Creates a sequence of buffers with and without skip</caption>\n * const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n *\n * // Without skip\n * const result = buffer(source, 5);\n * const result = Ix.Iterable.from(source).buffer(5);\n * for (const item of result) {\n *   console.log(result);\n * }\n * // => [0, 1, 2, 3, 4]\n * // => [5, 6, 7, 8, 9]\n *\n * // With skip\n * const result = buffer(source, 3, 4);\n * const result = Ix.Iterable.from(source).buffer(3, 4);\n * for (const item of result) {\n *   console.log(result);\n * }\n * // => [0, 1, 2]\n * // => [4, 5, 6]\n * // => [8, 9]\n * @param {Iterabel<TSource>} source Source sequence\n * @param {number} count Number of elements for allocated buffers.\n * @param {number} [skip] Number of elements to skip between the start of consecutive buffers. If not specified, defaults\n * to the count.\n * @return {IterableX<TSource>[]} Sequence of buffers containing source sequence elements\n */\nexport function buffer<TSource>(\n  source: Iterable<TSource>,\n  count: number,\n  skip?: number\n): IterableX<TSource[]> {\n  if (skip == null) {\n    skip = count;\n  }\n  return new BufferIterable(source, count, skip);\n}\n","import { IterableX } from './iterablex';\n\nclass DeferIterable<T> extends IterableX<T> {\n  private _fn: () => Iterable<T>;\n\n  constructor(fn: () => Iterable<T>) {\n    super();\n    this._fn = fn;\n  }\n\n  *[Symbol.iterator]() {\n    for (let item of this._fn()) {\n      yield item;\n    }\n  }\n}\n\n/**\n * Creates an enumerable sequence based on an iterable factory function.\n * @param {function(): Iterable<T>} factory Iterable factory function.\n * @return {Iterable<T>} Sequence that will invoke the iterable factory upon a call to [Symbol.iterator]().\n */\nexport function defer<TSource>(factory: () => Iterable<TSource>): IterableX<TSource> {\n  return new DeferIterable<TSource>(factory);\n}\n","import { IterableX } from './iterablex';\n\nclass EmptyIterable<TSource> extends IterableX<TSource> {\n  *[Symbol.iterator](): Iterator<TSource> {\n    // tslint:disable-next-line:no-empty\n  }\n}\n\n/**\n * Returns an empty iterable.\n * @return {Iterable<T>} The empty iterable.\n */\nexport function empty<TSource>(): IterableX<TSource> {\n  return new EmptyIterable<TSource>();\n}\n","import { IterableX } from './iterablex';\nimport { defer } from './defer';\nimport { empty } from './empty';\n\n/**\n * Returns a sequence from a dictionary based on the result of evaluating a selector function.\n * @example\n * const map = new Map([\n *   [1, [1, 2, 3]],\n *   [2, [2, 3, 4]],\n *   [3, [4, 5, 6]]\n * ]);\n * const result = case(\n *   () => 2,\n *   map,\n *   [5, 6, 7]\n * );\n * const result = Ix.Iterable.case(\n *   () => 2,\n *   map,\n *   [5, 6, 7]\n * );\n * for (const item of result) {\n *   console.log(result);\n * }\n * @param {function(): TSource} selector Selector function used to pick a sequence from the given sources.\n * @param {Map<TSource, Iterable<TResult>>} sources Dictionary mapping selector values onto resulting sequences.\n * @param {Iterable<TResult>} [defaultSource] Default sequence to return in case there's no corresponding source\n * for the computed selector value.  If not specified, defaults to an empty sequence.\n * @return {Iterable<TResult>} The source sequence corresponding with the evaluated selector value; otherwise, the default source.\n */\nexport function _case<TSource, TResult>(\n  selector: () => TSource,\n  sources: Map<TSource, Iterable<TResult>>,\n  defaultSource: Iterable<TResult> = empty<TResult>()\n): IterableX<TResult> {\n  return defer<TResult>(() => {\n    const key = selector();\n    return sources.has(key) ? sources.get(key)! : defaultSource;\n  });\n}\n","/**\n * @ignore\n */\nexport function returnIterator<T>(it: Iterator<T>) {\n  if (typeof it.return === 'function') {\n    it.return();\n  }\n}\n\n/**\n * @ignore\n */\nexport async function returnAsyncIterator<T>(it: AsyncIterator<T>): Promise<void> {\n  if (typeof it.return === 'function') {\n    await it.return();\n  }\n}\n","import { IterableX } from './iterablex';\nimport { returnIterator } from '../internal/returniterator';\n\nexport class CatchIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<Iterable<TSource>>;\n\n  constructor(source: Iterable<Iterable<TSource>>) {\n    super();\n    this._source = source;\n  }\n\n  *[Symbol.iterator]() {\n    let error = null,\n      hasError = false;\n\n    for (let source of this._source) {\n      const it = source[Symbol.iterator]();\n\n      error = null;\n      hasError = false;\n\n      while (1) {\n        let c = <TSource>{};\n\n        try {\n          const { done, value } = it.next();\n          if (done) {\n            returnIterator(it);\n            break;\n          }\n          c = value;\n        } catch (e) {\n          error = e;\n          hasError = true;\n          returnIterator(it);\n          break;\n        }\n\n        yield c;\n      }\n\n      if (!hasError) {\n        break;\n      }\n    }\n\n    if (hasError) {\n      throw error;\n    }\n  }\n}\n\n/**\n * Creates a sequence by concatenating source sequences until a source sequence completes successfully.\n * @param {Iterable<Iterable<TSource>>} source Source sequences.\n * @return {Iterable<TSource>} Sequence that continues to concatenate source sequences while errors occur.\n */\nexport function _catchAll<TSource>(source: Iterable<Iterable<TSource>>): IterableX<TSource> {\n  return new CatchIterable<TSource>(source);\n}\n\n/**\n * Creates a sequence by concatenating source sequences until a source sequence completes successfully.\n * @param {Iterable<TSource>} source The first source.\n * @param {...Iterable<TSource>} args The rest of the sequence that continues to concatenate source sequences while errors occur.\n */\nexport function _catch<TSource>(\n  source: Iterable<TSource>,\n  ...args: Iterable<TSource>[]\n): IterableX<TSource> {\n  return new CatchIterable<TSource>([source, ...args]);\n}\n\n/**\n * Creates a sequence by concatenating source sequences until a source sequence completes successfully.\n * @param {...Iterable<TSource>} source Sequence that continues to concatenate source sequences while errors occur.\n * @return {Iterable<TSource>} Sequence that continues to concatenate source sequences while errors occur.\n */\nexport function _catchStatic<TSource>(...source: Iterable<TSource>[]): IterableX<TSource> {\n  return new CatchIterable<TSource>(source);\n}\n","import { IterableX } from './iterablex';\nimport { returnIterator } from '../internal/returniterator';\n\nexport class CatchWithIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _handler: (error: any) => Iterable<TSource>;\n\n  constructor(source: Iterable<TSource>, handler: (error: any) => Iterable<TSource>) {\n    super();\n    this._source = source;\n    this._handler = handler;\n  }\n\n  *[Symbol.iterator]() {\n    let err: Iterable<TSource> | undefined,\n      hasError = false,\n      it = this._source[Symbol.iterator]();\n    while (1) {\n      let c = <IteratorResult<TSource>>{};\n\n      try {\n        c = it.next();\n        if (c.done) {\n          returnIterator(it);\n          break;\n        }\n      } catch (e) {\n        err = this._handler(e);\n        hasError = true;\n        returnIterator(it);\n        break;\n      }\n\n      yield c.value;\n    }\n\n    if (hasError) {\n      for (let item of err!) {\n        yield item;\n      }\n    }\n  }\n}\n\n/**\n * Creates a sequence that corresponds to the source sequence, concatenating it with the sequence resulting from\n * calling an exception handler function in case of an error.\n * @param {Iterable<TSource>} source Source sequence\n * @param {function(error: any): Iterable<TSource>} handler Handler to invoke when an exception of the specified type occurs.\n * @return {Iterable<TSource>} Source sequence, concatenated with an exception handler result sequence in case of an error.\n */\nexport function catchWith<TSource>(\n  source: Iterable<TSource>,\n  handler: (error: any) => Iterable<TSource>\n): IterableX<TSource> {\n  return new CatchWithIterable<TSource>(source, handler);\n}\n","import { IterableX } from './iterablex';\n\nclass ChainIterable<TResult> extends IterableX<TResult> {\n  private _result: Iterable<TResult>;\n\n  constructor(result: Iterable<TResult>) {\n    super();\n    this._result = result;\n  }\n\n  [Symbol.iterator]() {\n    return this._result[Symbol.iterator]();\n  }\n}\n\n/**\n * Returns an iterable sequence that is the result of invoking the selector on the source sequence,\n * without sharing subscriptions.  This operator allows for a fluent style of writing queries that use\n * the same sequence multiple times.\n * @param {Iterable<TSource>} source Source sequence that will be shared in the selector function.\n * @param {function(source: Iterable<TSource>): Iterable<TResult>} selector Selector function which can use\n * the source sequence as many times as needed, without sharing subscriptions to the source sequence.\n * @returns An iterable sequence that contains the elements of a sequence produced by multicasting the source\n * sequence within a selector function.\n */\nexport function chain<TSource, TResult>(\n  source: Iterable<TSource>,\n  selector: (source: Iterable<TSource>) => Iterable<TResult>\n): IterableX<TResult> {\n  return new ChainIterable<TResult>(selector(source));\n}\n","import { IterableX } from './iterablex';\n\nexport class ConcatIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<Iterable<TSource>>;\n\n  constructor(source: Iterable<Iterable<TSource>>) {\n    super();\n    this._source = source;\n  }\n\n  *[Symbol.iterator]() {\n    for (let outer of this._source) {\n      yield* outer;\n    }\n  }\n}\n\n/* tslint:disable:max-line-length */\nexport function concat<T>(source: Iterable<T>): IterableX<T>;\nexport function concat<T, T2>(source: Iterable<T>, v2: Iterable<T2>): IterableX<T | T2>;\nexport function concat<T, T2, T3>(\n  source: Iterable<T>,\n  v2: Iterable<T2>,\n  v3: Iterable<T3>\n): IterableX<T | T2 | T3>;\nexport function concat<T, T2, T3, T4>(\n  source: Iterable<T>,\n  v2: Iterable<T2>,\n  v3: Iterable<T3>,\n  v4: Iterable<T4>\n): IterableX<T | T2 | T3 | T4>;\nexport function concat<T, T2, T3, T4, T5>(\n  source: Iterable<T>,\n  v2: Iterable<T2>,\n  v3: Iterable<T3>,\n  v4: Iterable<T4>,\n  v5: Iterable<T5>\n): Iterable<T | T2 | T3 | T4 | T5>;\nexport function concat<T, T2, T3, T4, T5, T6>(\n  source: Iterable<T>,\n  v2: Iterable<T2>,\n  v3: Iterable<T3>,\n  v4: Iterable<T4>,\n  v5: Iterable<T5>,\n  v6: Iterable<T6>\n): Iterable<T | T2 | T3 | T4 | T5 | T6>;\nexport function concat<T>(source: Iterable<T>, ...args: Iterable<T>[]): IterableX<T>;\n/* tslint:enable:max-line-length */\n\nexport function concat<T>(source: Iterable<T>, ...args: Iterable<T>[]): IterableX<T> {\n  return new ConcatIterable<T>([source, ...args]);\n}\n\n/* tslint:disable:max-line-length */\nexport function concatStatic<T>(v1: Iterable<T>): IterableX<T>;\nexport function concatStatic<T, T2>(v1: Iterable<T>, v2: Iterable<T2>): IterableX<T | T2>;\nexport function concatStatic<T, T2, T3>(\n  v1: Iterable<T>,\n  v2: Iterable<T2>,\n  v3: Iterable<T3>\n): IterableX<T | T2 | T3>;\nexport function concatStatic<T, T2, T3, T4>(\n  v1: Iterable<T>,\n  v2: Iterable<T2>,\n  v3: Iterable<T3>,\n  v4: Iterable<T4>\n): IterableX<T | T2 | T3 | T4>;\nexport function concatStatic<T, T2, T3, T4, T5>(\n  v1: Iterable<T>,\n  v2: Iterable<T2>,\n  v3: Iterable<T3>,\n  v4: Iterable<T4>,\n  v5: Iterable<T5>\n): Iterable<T | T2 | T3 | T4 | T5>;\nexport function concatStatic<T, T2, T3, T4, T5, T6>(\n  v1: Iterable<T>,\n  v2: Iterable<T2>,\n  v3: Iterable<T3>,\n  v4: Iterable<T4>,\n  v5: Iterable<T5>,\n  v6: Iterable<T6>\n): Iterable<T | T2 | T3 | T4 | T5 | T6>;\n/* tslint:enable:max-line-length */\n\nexport function concatStatic<T>(...args: Iterable<T>[]): IterableX<T> {\n  return new ConcatIterable<T>(args);\n}\n","import { IterableX } from './iterablex';\nimport { ConcatIterable } from './concat';\n\n/**\n * Concatenates the input sequences.\n * @param {Iterable<Iterable<TSource>>} source Source sequences.\n * @return {Iterable<TSource>} Sequence with the elements of the source sequences concatenated.\n */\nexport function concatAll<TSource>(source: Iterable<Iterable<TSource>>): IterableX<TSource> {\n  return new ConcatIterable<TSource>(source);\n}\n","/**\n * Returns a number that represents how many elements in the specified sequence satisfy a condition if present,\n * else the number of items in the collection.\n * @param {Iterable<T>} source A sequence that contains elements to be tested and counted.\n * @param {function(value: T): boolean} [predicate] A function to test each element for a condition.\n */\nexport function count<T>(\n  source: Iterable<T>,\n  predicate: (value: T) => boolean = () => true\n): number {\n  let i = 0;\n\n  for (let item of source) {\n    if (predicate(item)) {\n      i++;\n    }\n  }\n\n  return i;\n}\n","import { IterableX } from './iterablex';\n\nclass AnonymousIterable<T> extends IterableX<T> {\n  private _fn: () => Iterator<T>;\n\n  constructor(fn: () => Iterator<T>) {\n    super();\n    this._fn = fn;\n  }\n\n  [Symbol.iterator]() {\n    return this._fn();\n  }\n}\n\n/**\n * Creates an enumerable sequence based on an enumerator factory function.\n * @param {function(): Iterator<T>} getIterator The iterator factory function.\n * @return {Iterable<T>} Sequence that will invoke the iterator factory upon a call to [Symbol.iterator]().\n */\nexport function create<T>(getIterator: () => Iterator<T>): IterableX<T> {\n  return new AnonymousIterable(getIterator);\n}\n","import { IterableX } from './iterablex';\n\nexport class DefaultIfEmptyIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _defaultValue: TSource;\n\n  constructor(source: Iterable<TSource>, defaultValue: TSource) {\n    super();\n    this._source = source;\n    this._defaultValue = defaultValue;\n  }\n\n  *[Symbol.iterator]() {\n    let state = 1;\n    for (let item of this._source) {\n      state = 2;\n      yield item;\n    }\n    if (state === 1) {\n      yield this._defaultValue;\n    }\n  }\n}\n\n/**\n * Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the sequence is empty.\n * @param {Iterable<T>} source The sequence to return a default value for if it is empty.\n * @param {T} defaultValue The default value if the sequence is empty.\n * @return An that contains the default value if source is empty; otherwise, source.\n */\nexport function defaultIfEmpty<T>(source: Iterable<T>, defaultValue: T): IterableX<T> {\n  return new DefaultIfEmptyIterable<T>(source, defaultValue);\n}\n","/**\n * @ignore\n */\nexport function arrayIndexOf<T>(array: T[], item: T, comparer: (a: T, b: T) => boolean) {\n  for (let i = 0, len = array.length; i < len; i++) {\n    if (comparer(item, array[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * @ignore\n */\nexport async function arrayIndexOfAsync<T>(\n  array: T[],\n  item: T,\n  comparer: (a: T, b: T) => boolean | Promise<boolean>\n): Promise<number> {\n  for (let i = 0, len = array.length; i < len; i++) {\n    if (await comparer(item, array[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n","'use strict';\n/**\n * @ignore\n */\nexport function comparer(x: any, y: any) {\n  return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));\n}\n\n/**\n * @ignore\n */\nexport async function comparerAsync(x: any, y: any) {\n  return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));\n}\n","import { IterableX } from './iterablex';\nimport { identity } from '../internal/identity';\nimport { arrayIndexOf } from '../internal/arrayindexof';\nimport { comparer as defaultComparer } from '../internal/comparer';\n\nexport class DistinctIterable<TSource, TKey> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _keySelector: (value: TSource) => TKey;\n  private _cmp: (x: TKey, y: TKey) => boolean;\n\n  constructor(\n    source: Iterable<TSource>,\n    keySelector: (value: TSource) => TKey,\n    cmp: (x: TKey, y: TKey) => boolean\n  ) {\n    super();\n    this._source = source;\n    this._keySelector = keySelector;\n    this._cmp = cmp;\n  }\n\n  *[Symbol.iterator]() {\n    let set = [] as TKey[];\n\n    for (let item of this._source) {\n      let key = this._keySelector(item);\n      if (arrayIndexOf(set, key, this._cmp) === -1) {\n        set.push(key);\n        yield item;\n      }\n    }\n  }\n}\n\n/**\n * Returns elements with a distinct key value by using the specified comparer to compare key values.\n * @param source Source sequence.\n * @param {function(value: TSource): TKey} [keySelector] Key selector.\n * @param {function(x: TKey, y: TKey): boolean} [comparer] Comparer used to compare key values.\n * @return {Iterable<T>} Sequence that contains the elements from the source sequence with distinct key values.\n */\nexport function distinct<TSource, TKey>(\n  source: Iterable<TSource>,\n  keySelector: (value: TSource) => TKey = identity,\n  comparer: (x: TKey, y: TKey) => boolean = defaultComparer\n): IterableX<TSource> {\n  return new DistinctIterable(source, keySelector, comparer);\n}\n","import { IterableX } from './iterablex';\nimport { identity } from '../internal/identity';\nimport { comparer as defaultComparer } from '../internal/comparer';\n\nexport class DistinctUntilChangedIterable<TSource, TKey> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _keySelector: (value: TSource) => TKey;\n  private _comparer: (x: TKey, y: TKey) => boolean;\n\n  constructor(\n    source: Iterable<TSource>,\n    keySelector: (value: TSource) => TKey,\n    comparer: (first: TKey, second: TKey) => boolean\n  ) {\n    super();\n    this._source = source;\n    this._keySelector = keySelector;\n    this._comparer = comparer;\n  }\n\n  *[Symbol.iterator]() {\n    let currentKey = <TKey>{},\n      hasCurrentKey = false;\n    for (let item of this._source) {\n      let key = this._keySelector(item);\n      let comparerEquals = false;\n      if (hasCurrentKey) {\n        comparerEquals = this._comparer(currentKey, key);\n      }\n      if (!hasCurrentKey || !comparerEquals) {\n        hasCurrentKey = true;\n        currentKey = key;\n        yield item;\n      }\n    }\n  }\n}\n\n/**\n * Returns consecutive distinct elements based on a key value by using the specified equality comparer to compare key values.\n * @param {Iterable<TSource>} source Source sequence.\n * @param {function(value: TSource): TKey} [keySelector] Key selector.\n * @param {function(x: TKey, y: TKey): boolean} [comparer] Comparer used to compare key values.\n * @return {Iterable<TSource>} Sequence without adjacent non-distinct elements.\n */\nexport function distinctUntilChanged<TSource, TKey>(\n  source: Iterable<TSource>,\n  keySelector: (value: TSource) => TKey = identity,\n  comparer: (first: TKey, second: TKey) => boolean = defaultComparer\n): IterableX<TSource> {\n  return new DistinctUntilChangedIterable<TSource, TKey>(source, keySelector, comparer);\n}\n","import { IterableX } from './iterablex';\n\nclass WhileIterable<TSource> extends IterableX<TSource> {\n  private _condition: () => boolean;\n  private _source: Iterable<TSource>;\n\n  constructor(condition: () => boolean, source: Iterable<TSource>) {\n    super();\n    this._condition = condition;\n    this._source = source;\n  }\n\n  *[Symbol.iterator]() {\n    while (this._condition()) {\n      yield* this._source;\n    }\n  }\n}\n\nexport function _while<TSource>(\n  condition: () => boolean,\n  source: Iterable<TSource>\n): IterableX<TSource> {\n  return new WhileIterable<TSource>(condition, source);\n}\n","import { IterableX } from './iterablex';\nimport { concatStatic } from './concat';\nimport { _while } from './while';\n\n/**\n * Generates an iterable sequence by repeating a source sequence as long as the given loop postcondition holds.\n * @param {Iterable<T>} source Source sequence to repeat while the condition evaluates true.\n * @param {function(): boolean} condition Loop condition.\n * @return {Iterable<T>} Sequence generated by repeating the given sequence until the condition evaluates to false.\n */\nexport function doWhile<TSource>(\n  source: Iterable<TSource>,\n  condition: () => boolean\n): IterableX<TSource> {\n  return concatStatic(source, _while(condition, source));\n}\n","/**\n * Returns the element at a specified index in a sequence or undefined if the index is out of range.\n * @param {Iterable<T>} source The source sequence.\n * @param {number} index The zero-based index of the element to retrieve.\n * @return {T} undefined if the index is outside the bounds of the source sequence; otherwise, the element at the\n * specified position in the source sequence.\n */\nexport function elementAt<T>(source: Iterable<T>, index: number) {\n  for (let item of source) {\n    if (index === 0) {\n      return item;\n    }\n    index--;\n  }\n  return undefined;\n}\n","import { IterableX } from './iterablex';\n\nexport class EndWithIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _args: TSource[];\n\n  constructor(source: Iterable<TSource>, args: TSource[]) {\n    super();\n    this._source = source;\n    this._args = args;\n  }\n\n  *[Symbol.iterator]() {\n    for (let item of this._source) {\n      yield item;\n    }\n    for (let x of this._args) {\n      yield x;\n    }\n  }\n}\n\nexport function endWith<TSource>(\n  source: Iterable<TSource>,\n  ...args: TSource[]\n): IterableX<TSource> {\n  return new EndWithIterable<TSource>(source, args);\n}\n","/**\n * Determines whether every element of a sequence satisfy a condition.\n * @param {Iterable<T>} source Source sequence.\n * @param {function(value: T, index: number): boolean} predicate A function to test each element for a condition.\n * @return {boolean} true if every element of the source sequence passes the test in the specified predicate, or\n * if the sequence is empty; otherwise, false.\n */\nexport function every<T, S extends T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => value is S\n): boolean;\nexport function every<T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => boolean\n): boolean;\nexport function every<T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => boolean\n): boolean {\n  let i = 0;\n  for (let item of source) {\n    if (!predicate(item, i++)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { IterableX } from './iterablex';\nimport { arrayIndexOf } from '../internal/arrayindexof';\nimport { comparer as defaultComparer } from '../internal/comparer';\n\nexport class ExceptIterable<TSource> extends IterableX<TSource> {\n  private _first: Iterable<TSource>;\n  private _second: Iterable<TSource>;\n  private _comparer: (x: TSource, y: TSource) => boolean;\n\n  constructor(\n    first: Iterable<TSource>,\n    second: Iterable<TSource>,\n    comparer: (x: TSource, y: TSource) => boolean\n  ) {\n    super();\n    this._first = first;\n    this._second = second;\n    this._comparer = comparer;\n  }\n\n  *[Symbol.iterator]() {\n    let map = [] as TSource[];\n    for (let secondItem of this._second) {\n      map.push(secondItem);\n    }\n\n    for (let firstItem of this._first) {\n      if (arrayIndexOf(map, firstItem, this._comparer) === -1) {\n        map.push(firstItem);\n        yield firstItem;\n      }\n    }\n  }\n}\n\n/**\n * Produces the set difference of two sequences by using the an equality comparer to compare values.\n * @param {Iterable<T>} first A sequence whose elements that are not also in second will be returned.\n * @param {Iterable<T>} second A sequence whose elements that also occur in the first sequence will cause those\n * elements to be removed from the returned sequence.\n * @param {function(x: TKey, y: TKey): boolean} [comparer] Comparer used to compare key values.\n * @return {Iterable<T>} A sequence that contains the set difference of the elements of two sequences.\n */\nexport function except<TSource>(\n  first: Iterable<TSource>,\n  second: Iterable<TSource>,\n  comparer: (x: TSource, y: TSource) => boolean = defaultComparer\n): IterableX<TSource> {\n  return new ExceptIterable<TSource>(first, second, comparer);\n}\n","import { IterableX } from './iterablex';\n\nexport class ExpandIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _fn: (value: TSource) => Iterable<TSource>;\n\n  constructor(source: Iterable<TSource>, fn: (value: TSource) => Iterable<TSource>) {\n    super();\n    this._source = source;\n    this._fn = fn;\n  }\n\n  *[Symbol.iterator]() {\n    let q = [this._source];\n    while (q.length > 0) {\n      let src = q.shift();\n      for (let item of src!) {\n        q.push(this._fn(item));\n        yield item;\n      }\n    }\n  }\n}\n\n/**\n * Expands the sequence by recursively applying a selector function.\n * @param {Iterable<T>} source Source sequence.\n * @param {function(value: T): Iterable<T>} selector Selector function to retrieve the next sequence to expand\n * @return {Iterable<T>} Sequence with results from the recursive expansion of the source sequence.\n */\nexport function expand<TSource>(\n  source: Iterable<TSource>,\n  selector: (value: TSource) => Iterable<TSource>\n): IterableX<TSource> {\n  return new ExpandIterable<TSource>(source, selector);\n}\n","import { IterableX } from './iterablex';\nimport { bindCallback } from '../internal/bindcallback';\n\nexport class FilterIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _predicate: (value: TSource, index: number) => boolean;\n\n  constructor(source: Iterable<TSource>, predicate: (value: TSource, index: number) => boolean) {\n    super();\n    this._source = source;\n    this._predicate = predicate;\n  }\n\n  *[Symbol.iterator]() {\n    let i = 0;\n    for (let item of this._source) {\n      if (this._predicate(item, i++)) {\n        yield item;\n      }\n    }\n  }\n}\n\n/**\n * Filters a sequence of values based on a predicate.\n * @param {Iterable<T>} source Source sequence.\n * @param {function(value: T, index: number): boolean} predicate A function to test each source element for a condition.\n * @param {Object} [thisArg] Value to use as this when executing callback.\n * @return {Iterable<T>} Sequence that contains elements from the input sequence that satisfy the condition.\n */\nexport function filter<T, S extends T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => value is S,\n  thisArg?: any\n): IterableX<S>;\nexport function filter<T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): IterableX<T>;\nexport function filter<T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): IterableX<T> {\n  return new FilterIterable<T>(source, bindCallback(predicate, thisArg, 2));\n}\n","import { IterableX } from './iterablex';\n\nexport class FinallyIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _action: () => void;\n\n  constructor(source: Iterable<TSource>, action: () => void) {\n    super();\n    this._source = source;\n    this._action = action;\n  }\n\n  *[Symbol.iterator]() {\n    try {\n      yield* this._source;\n    } finally {\n      this._action();\n    }\n  }\n}\n\n/**\n * Creates a sequence whose termination or disposal of an iterator causes a finally action to be executed.\n * @param {Iterator<T>} source Source sequence\n * @param {function(): void)} action Action to run upon termination of the sequence, or when an iterator is disposed.\n * @return {Iterable<T>} Source sequence with guarantees on the invocation of the finally action.\n */\nexport function _finally<TSource>(\n  source: Iterable<TSource>,\n  action: () => void\n): IterableX<TSource> {\n  return new FinallyIterable<TSource>(source, action);\n}\n","import { bindCallback } from '../internal/bindcallback';\n\n/**\n * Returns the value of the first element in the sequence that satisfies the provided testing function.\n * Otherwise undefined is returned.\n * @param {Iterable<T>} source Source sequence.\n * @param {function(value: T, index: number): boolean} predicate Function to execute for every item in the sequence.\n * @param {Object} [thisArg] Object to use as this when executing callback.\n * @return {T | undefined} The value of the first element in the sequence that satisfies the provided testing function.\n * Otherwise undefined is returned.\n */\nexport function find<T, S extends T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => value is S,\n  thisArg?: any\n): S | undefined;\nexport function find<T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): T | undefined;\nexport function find<T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): T | undefined {\n  if (typeof predicate !== 'function') {\n    throw new TypeError();\n  }\n  const f = bindCallback(predicate, thisArg, 2);\n  let i = 0;\n\n  for (let item of source) {\n    if (f(item, i++)) {\n      return item;\n    }\n  }\n  return undefined;\n}\n","import { bindCallback } from '../internal/bindcallback';\n\nexport function findIndex<T, S extends T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => value is S,\n  thisArg?: any\n): number;\nexport function findIndex<T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): number;\nexport function findIndex<T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): number {\n  if (typeof predicate !== 'function') {\n    throw new TypeError();\n  }\n  const f = bindCallback(predicate, thisArg, 2);\n  let i = 0;\n\n  for (let item of source) {\n    if (f(item, i++)) {\n      return i;\n    }\n  }\n  return -1;\n}\n","/**\n * Returns the first element in a sequence that satisfies a specified condition if provided, else\n * the first element in the sequence.\n * @param {Iterable<T>} source Source collection\n * @param {function:(value: T): boolean} [selector] An optional function to test each element for a condition.\n * @returns {T | undefined} The first element in the sequence that passes the test in the\n * specified predicate function if provided, else the first element. If there are no elements,\n * undefined is returned.\n */\nexport function first<T, S extends T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => value is S\n): S | undefined;\nexport function first<T>(\n  source: Iterable<T>,\n  predicate?: (value: T, index: number) => boolean\n): T | undefined;\nexport function first<T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => boolean = () => true\n): T | undefined {\n  let i = 0;\n  for (let item of source) {\n    if (predicate(item, i++)) {\n      return item;\n    }\n  }\n\n  return undefined;\n}\n","import { IterableX } from './iterablex';\nimport { bindCallback } from '../internal/bindcallback';\n\nexport class FlatMapIterable<TSource, TResult> extends IterableX<TResult> {\n  private _source: Iterable<TSource>;\n  private _fn: (value: TSource) => Iterable<TResult>;\n\n  constructor(source: Iterable<TSource>, fn: (value: TSource) => Iterable<TResult>) {\n    super();\n    this._source = source;\n    this._fn = fn;\n  }\n\n  *[Symbol.iterator]() {\n    for (let outerItem of this._source) {\n      for (let innerItem of this._fn(outerItem)) {\n        yield innerItem;\n      }\n    }\n  }\n}\n\n/**\n * Projects each element of a sequence to iterable and flattens the resulting sequences into\n * one sequence.\n * @param {Iterable<T>} source Source sequence\n * @param {function:(value: T): Iterable<R>} selector A transform function to apply to each element.\n * @param {Object} [thisArg] An optional \"this\" binding for the selector function.\n * @returns {Iterable<R>} An iterable whose elements are the result of invoking the one-to-many\n * transform function on each element of the input sequence.\n */\nexport function flatMap<TSource, TResult>(\n  source: Iterable<TSource>,\n  selector: (value: TSource) => Iterable<TResult>,\n  thisArg?: any\n): IterableX<TResult> {\n  return new FlatMapIterable<TSource, TResult>(source, bindCallback(selector, thisArg, 1));\n}\n","import { IterableX } from './iterablex';\nimport { isIterable } from '../internal/isiterable';\n\nexport class FlattenIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _depth: number;\n\n  constructor(source: Iterable<TSource>, depth: number) {\n    super();\n    this._source = source;\n    this._depth = depth;\n  }\n\n  private *_flatten(source: Iterable<TSource>, depth: number): Iterable<TSource> {\n    if (depth === 0) {\n      for (let item of source) {\n        yield item;\n      }\n      return undefined;\n    }\n    for (let item of source) {\n      if (isIterable(item)) {\n        for (let innerItem of this._flatten(item, depth - 1)) {\n          yield innerItem;\n        }\n      } else {\n        yield item;\n      }\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this._flatten(this._source, this._depth)[Symbol.iterator]();\n  }\n}\n\n/**\n * Flattens the source sequence until the specified depth.\n * @param {Iterable<T>} source Source sequence.\n * @param {Number} depth The depth to flatten the source sequence.\n * @returns {Iterable<T>} The flattened sequence, flattened to the specified depth.\n */\nexport function flatten<T>(source: Iterable<T>, depth: number = Infinity): IterableX<T> {\n  return new FlattenIterable<T>(source, depth);\n}\n","import { IterableX } from './iterablex';\nimport { bindCallback } from '../internal/bindcallback';\n\nexport class MapIterable<TSource, TResult> extends IterableX<TResult> {\n  private _source: Iterable<TSource>;\n  private _selector: (value: TSource, index: number) => TResult;\n\n  constructor(source: Iterable<TSource>, selector: (value: TSource, index: number) => TResult) {\n    super();\n    this._source = source;\n    this._selector = selector;\n  }\n\n  *[Symbol.iterator]() {\n    let i = 0;\n    for (let item of this._source) {\n      yield this._selector(item, i++);\n    }\n  }\n}\n\nexport function map<TSource, TResult>(\n  source: Iterable<TSource>,\n  selector: (value: TSource, index: number) => TResult,\n  thisArg?: any\n): IterableX<TResult> {\n  return new MapIterable<TSource, TResult>(source, bindCallback(selector, thisArg, 2));\n}\n","import { IterableX } from './iterablex';\nimport { concatAll } from './concatall';\nimport { map } from './map';\n\n/**\n * Concatenates the iterable sequences obtained by running the result selector for each\n * element in the given source sequence.\n * @param {Iterable<T>} source Iterable source for which each element will be mapped onto an\n * iterable source that will be concatenated in the result sequence.\n * @param {function:(value: T) => Iterable<R>} resultSelector Function to select an iterable source\n * for each element in the source sequence.\n * @returns {Iterable<R>} The iterable sequence obtained by concatenating the sources returned by\n * result selector for each element in the source.\n */\nexport function _for<TSource, TResult>(\n  source: Iterable<TSource>,\n  resultSelector: (value: TSource) => Iterable<TResult>\n): IterableX<TResult> {\n  return concatAll(map(source, resultSelector));\n}\n","import { IterableX } from './iterablex';\n\nclass GenerateIterable<TState, TResult> extends IterableX<TResult> {\n  private _initialState: TState;\n  private _condition: (value: TState) => boolean;\n  private _iterate: (value: TState) => TState;\n  private _resultSelector: (value: TState) => TResult;\n\n  constructor(\n    initialState: TState,\n    condition: (value: TState) => boolean,\n    iterate: (value: TState) => TState,\n    resultSelector: (value: TState) => TResult\n  ) {\n    super();\n    this._initialState = initialState;\n    this._condition = condition;\n    this._iterate = iterate;\n    this._resultSelector = resultSelector;\n  }\n\n  *[Symbol.iterator]() {\n    for (let i = this._initialState; this._condition(i); i = this._iterate(i)) {\n      yield this._resultSelector(i);\n    }\n  }\n}\n\nexport function generate<TState, TResult>(\n  initialState: TState,\n  condition: (value: TState) => boolean,\n  iterate: (value: TState) => TState,\n  resultSelector: (value: TState) => TResult\n): IterableX<TResult> {\n  return new GenerateIterable<TState, TResult>(initialState, condition, iterate, resultSelector);\n}\n","/**\n * @ignore\n */\nexport function createGrouping<TSource, TKey, TValue>(\n  source: Iterable<TSource>,\n  keySelector: (value: TSource) => TKey,\n  elementSelector: (value: TSource) => TValue\n): Map<TKey, TValue[]> {\n  let map = new Map<TKey, TValue[]>();\n  for (let item of source) {\n    let key = keySelector(item);\n    let grouping = map.get(key);\n    if (!map.has(key)) {\n      grouping = [];\n      map.set(key, grouping);\n    }\n    grouping!.push(elementSelector(item));\n  }\n\n  return map;\n}\n","import { IterableX } from './iterablex';\nimport { identity } from '../internal/identity';\nimport { createGrouping } from './_grouping';\n\nexport class GroupedIterable<TKey, TValue> extends IterableX<TValue> {\n  public readonly key: TKey;\n  private _source: Iterable<TValue>;\n\n  constructor(key: TKey, source: Iterable<TValue>) {\n    super();\n    this.key = key;\n    this._source = source;\n  }\n\n  [Symbol.iterator]() {\n    return this._source[Symbol.iterator]();\n  }\n}\n\nexport class GroupByIterable<TSource, TKey, TValue, TResult> extends IterableX<TResult> {\n  private _source: Iterable<TSource>;\n  private _keySelector: (value: TSource) => TKey;\n  private _elementSelector: (value: TSource) => TValue;\n  private _resultSelector: (key: TKey, values: Iterable<TValue>) => TResult;\n\n  constructor(\n    source: Iterable<TSource>,\n    keySelector: (value: TSource) => TKey,\n    elementSelector: (value: TSource) => TValue,\n    resultSelector: (key: TKey, values: Iterable<TValue>) => TResult\n  ) {\n    super();\n    this._source = source;\n    this._keySelector = keySelector;\n    this._elementSelector = elementSelector;\n    this._resultSelector = resultSelector;\n  }\n\n  *[Symbol.iterator]() {\n    const map = createGrouping(this._source, this._keySelector, this._elementSelector);\n    for (let [key, values] of map) {\n      yield this._resultSelector(key, values);\n    }\n  }\n}\n\nexport function groupByResultIdentity<TKey, TValue>(key: TKey, values: Iterable<TValue>): any {\n  return new GroupedIterable(key, values);\n}\n\nexport function groupBy<TSource, TKey>(\n  source: Iterable<TSource>,\n  keySelector: (value: TSource) => TKey\n): IterableX<GroupedIterable<TKey, TSource>>;\nexport function groupBy<TSource, TKey, TValue>(\n  source: Iterable<TSource>,\n  keySelector: (value: TSource) => TKey,\n  elementSelector?: (value: TSource) => TValue\n): IterableX<GroupedIterable<TKey, TValue>>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  source: Iterable<TSource>,\n  keySelector: (value: TSource) => TKey,\n  elementSelector?: (value: TSource) => TValue,\n  resultSelector?: (key: TKey, values: Iterable<TValue>) => TResult\n): IterableX<TResult>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  source: Iterable<TSource>,\n  keySelector: (value: TSource) => TKey,\n  elementSelector: (value: TSource) => TValue = identity,\n  resultSelector: (key: TKey, values: Iterable<TValue>) => TResult = groupByResultIdentity\n): IterableX<TResult> {\n  return new GroupByIterable<TSource, TKey, TValue, TResult>(\n    source,\n    keySelector,\n    elementSelector,\n    resultSelector\n  );\n}\n","import { IterableX } from './iterablex';\nimport { createGrouping } from './_grouping';\nimport { empty } from './empty';\nimport { identity } from '../internal/identity';\n\nexport class GroupJoinIterable<TOuter, TInner, TKey, TResult> extends IterableX<TResult> {\n  private _outer: Iterable<TOuter>;\n  private _inner: Iterable<TInner>;\n  private _outerSelector: (value: TOuter) => TKey;\n  private _innerSelector: (value: TInner) => TKey;\n  private _resultSelector: (outer: TOuter, inner: Iterable<TInner>) => TResult;\n\n  constructor(\n    outer: Iterable<TOuter>,\n    inner: Iterable<TInner>,\n    outerSelector: (value: TOuter) => TKey,\n    innerSelector: (value: TInner) => TKey,\n    resultSelector: (outer: TOuter, inner: Iterable<TInner>) => TResult\n  ) {\n    super();\n    this._outer = outer;\n    this._inner = inner;\n    this._outerSelector = outerSelector;\n    this._innerSelector = innerSelector;\n    this._resultSelector = resultSelector;\n  }\n\n  *[Symbol.iterator]() {\n    const map = createGrouping(this._inner, this._innerSelector, identity);\n    for (let outerElement of this._outer) {\n      const outerKey = this._outerSelector(outerElement);\n      const innerElements = map.has(outerKey)\n        ? <Iterable<TInner>>map.get(outerKey)\n        : empty<TInner>();\n      yield this._resultSelector(outerElement, innerElements);\n    }\n  }\n}\n\nexport function groupJoin<TOuter, TInner, TKey, TResult>(\n  outer: Iterable<TOuter>,\n  inner: Iterable<TInner>,\n  outerSelector: (value: TOuter) => TKey,\n  innerSelector: (value: TInner) => TKey,\n  resultSelector: (outer: TOuter, inner: Iterable<TInner>) => TResult\n): IterableX<TResult> {\n  return new GroupJoinIterable<TOuter, TInner, TKey, TResult>(\n    outer,\n    inner,\n    outerSelector,\n    innerSelector,\n    resultSelector\n  );\n}\n","import { IterableX } from './iterablex';\nimport { defer } from './defer';\nimport { empty } from './empty';\n\nexport function _if<TSource>(\n  fn: () => boolean,\n  thenSource: Iterable<TSource>,\n  elseSource: Iterable<TSource> = empty<TSource>()\n): IterableX<TSource> {\n  return defer<TSource>(() => (fn() ? thenSource : elseSource));\n}\n","import { IterableX } from './iterablex';\n\nexport class IgnoreElementsIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n\n  constructor(source: Iterable<TSource>) {\n    super();\n    this._source = source;\n  }\n\n  *[Symbol.iterator](): Iterator<TSource> {\n    const it = this._source[Symbol.iterator]();\n    while (!it.next().done) {\n      /* intentionally empty */\n    }\n  }\n}\n\nexport function ignoreElements<TSource>(source: Iterable<TSource>): IterableX<TSource> {\n  return new IgnoreElementsIterable<TSource>(source);\n}\n","import { comparer } from '../internal/comparer';\n\nexport function includes<T>(source: Iterable<T>, searchElement: T, fromIndex: number = 0): boolean {\n  let i = 0;\n  if (Math.abs(fromIndex)) {\n    fromIndex = 0;\n  }\n  for (let item of source) {\n    if (i++ > fromIndex && comparer(item, searchElement)) {\n      return true;\n    }\n  }\n  return false;\n}\n","import { IterableX } from './iterablex';\nimport { createGrouping } from './_grouping';\nimport { identity } from '../internal/identity';\n\nexport class JoinIterable<TOuter, TInner, TKey, TResult> extends IterableX<TResult> {\n  private _outer: Iterable<TOuter>;\n  private _inner: Iterable<TInner>;\n  private _outerSelector: (value: TOuter) => TKey;\n  private _innerSelector: (value: TInner) => TKey;\n  private _resultSelector: (outer: TOuter, inner: TInner) => TResult;\n\n  constructor(\n    outer: Iterable<TOuter>,\n    inner: Iterable<TInner>,\n    outerSelector: (value: TOuter) => TKey,\n    innerSelector: (value: TInner) => TKey,\n    resultSelector: (outer: TOuter, inner: TInner) => TResult\n  ) {\n    super();\n    this._outer = outer;\n    this._inner = inner;\n    this._outerSelector = outerSelector;\n    this._innerSelector = innerSelector;\n    this._resultSelector = resultSelector;\n  }\n\n  *[Symbol.iterator]() {\n    const map = createGrouping(this._inner, this._innerSelector, identity);\n    for (let outerElement of this._outer) {\n      const outerKey = this._outerSelector(outerElement);\n      if (map.has(outerKey)) {\n        for (let innerElement of map.get(outerKey)!) {\n          yield this._resultSelector(outerElement, innerElement);\n        }\n      }\n    }\n  }\n}\n\nexport function innerJoin<TOuter, TInner, TKey, TResult>(\n  outer: Iterable<TOuter>,\n  inner: Iterable<TInner>,\n  outerSelector: (value: TOuter) => TKey,\n  innerSelector: (value: TInner) => TKey,\n  resultSelector: (outer: TOuter, inner: TInner) => TResult\n): IterableX<TResult> {\n  return new JoinIterable<TOuter, TInner, TKey, TResult>(\n    outer,\n    inner,\n    outerSelector,\n    innerSelector,\n    resultSelector\n  );\n}\n","import { IterableX } from './iterablex';\nimport { arrayIndexOf } from '../internal/arrayindexof';\nimport { comparer as defaultComparer } from '../internal/comparer';\n\nfunction arrayRemove<T>(array: T[], item: T, comparer: (x: T, y: T) => boolean): boolean {\n  let idx = arrayIndexOf(array, item, comparer);\n  if (idx === -1) {\n    return false;\n  }\n  array.splice(idx, 1);\n  return true;\n}\n\nexport class IntersectIterable<TSource> extends IterableX<TSource> {\n  private _first: Iterable<TSource>;\n  private _second: Iterable<TSource>;\n  private _comparer: (x: TSource, y: TSource) => boolean;\n\n  constructor(\n    first: Iterable<TSource>,\n    second: Iterable<TSource>,\n    comparer: (x: TSource, y: TSource) => boolean\n  ) {\n    super();\n    this._first = first;\n    this._second = second;\n    this._comparer = comparer;\n  }\n\n  *[Symbol.iterator]() {\n    let map = [] as TSource[];\n    for (let secondItem of this._second) {\n      map.push(secondItem);\n    }\n\n    for (let firstItem of this._first) {\n      if (arrayRemove(map, firstItem, this._comparer)) {\n        yield firstItem;\n      }\n    }\n  }\n}\n\nexport function intersect<TSource>(\n  first: Iterable<TSource>,\n  second: Iterable<TSource>,\n  comparer: (x: TSource, y: TSource) => boolean = defaultComparer\n): IterableX<TSource> {\n  return new IntersectIterable<TSource>(first, second, comparer);\n}\n","export function isEmpty<T>(source: Iterable<T>): boolean {\n  for (let _ of source) {\n    return false;\n  }\n  return true;\n}\n","export function last<T, S extends T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => value is S\n): S | undefined;\nexport function last<T>(\n  source: Iterable<T>,\n  predicate?: (value: T, index: number) => boolean\n): T | undefined;\nexport function last<T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => boolean = () => true\n): T | undefined {\n  let i = 0,\n    result: T | undefined;\n  for (let item of source) {\n    if (predicate(item, i++)) {\n      result = item;\n    }\n  }\n\n  return result;\n}\n","import { identity } from '../internal/identity';\n\nexport function max(source: Iterable<number>, fn?: (x: number) => number): number;\nexport function max<T>(source: Iterable<T>, fn: (x: T) => number): number;\nexport function max(source: Iterable<any>, fn: (x: any) => number = identity): number {\n  let atleastOnce = false;\n  let value = -Infinity;\n  for (let item of source) {\n    if (!atleastOnce) {\n      atleastOnce = true;\n    }\n    let x = fn(item);\n    if (x > value) {\n      value = x;\n    }\n  }\n  if (!atleastOnce) {\n    throw new Error('Sequence contains no elements');\n  }\n\n  return value;\n}\n","import { IterableX } from './iterablex';\n\n/**\n * @ignore\n */\nexport function defaultCompare<T>(key: T, minValue: T): number {\n  return key > minValue ? 1 : key < minValue ? -1 : 0;\n}\n\n/**\n * @ignore\n */\nclass ExtremaByIterable<TSource, TKey> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _keyFn: (x: TSource) => TKey;\n  private _cmp: (x: TKey, y: TKey) => number;\n\n  constructor(\n    source: Iterable<TSource>,\n    keyFn: (x: TSource) => TKey,\n    cmp: (x: TKey, y: TKey) => number\n  ) {\n    super();\n    this._source = source;\n    this._keyFn = keyFn;\n    this._cmp = cmp;\n  }\n\n  *[Symbol.iterator]() {\n    let result: TSource[] = [],\n      next;\n    const it = this._source[Symbol.iterator]();\n    if ((next = it.next()).done) {\n      throw new Error('Sequence contains no elements');\n    }\n\n    let current = next.value,\n      resKey = this._keyFn(current);\n    result.push(current);\n    while (!(next = it.next()).done) {\n      let curr = next.value,\n        key = this._keyFn(curr);\n      const c = this._cmp(key, resKey);\n      if (c === 0) {\n        result.push(curr);\n      } else if (c > 0) {\n        result = [curr];\n        resKey = key;\n      }\n    }\n\n    yield* result;\n  }\n}\n\n/**\n * @ignore\n */\nexport function extremaBy<TSource, TKey>(\n  source: Iterable<TSource>,\n  keyFn: (x: TSource) => TKey,\n  cmp: (x: TKey, y: TKey) => number\n): IterableX<TSource> {\n  return new ExtremaByIterable<TSource, TKey>(source, keyFn, cmp);\n}\n","import { IterableX } from './iterablex';\nimport { extremaBy, defaultCompare } from './_extremaby';\n\nexport function maxBy<TSource, TKey>(\n  source: Iterable<TSource>,\n  keySelector: (x: TSource) => TKey,\n  comparer: (x: TKey, y: TKey) => number = defaultCompare\n): IterableX<TSource> {\n  return extremaBy(source, keySelector, comparer);\n}\n","/**\n * @ignore\n */\nexport interface RefCount<T> {\n  value: T;\n  count: number;\n}\n\n/**\n * @ignore\n */\nexport interface IRefCountList<T> {\n  clear(): void;\n  readonly count: number;\n  get(index: number): T;\n  push(value: T): void;\n  done(): void;\n}\n\n/**\n * @ignore\n */\nexport class MaxRefCountList<T> implements IRefCountList<T> {\n  private _list: T[] = [];\n\n  clear() {\n    this._list = [];\n  }\n  get count() {\n    return this._list.length;\n  }\n  get(index: number): T {\n    return this._list[index];\n  }\n  push(value: T) {\n    this._list.push(value);\n  }\n\n  // tslint:disable-next-line:no-empty\n  done() {}\n}\n\n/**\n * @ignore\n */\nexport class RefCountList<T> implements IRefCountList<T> {\n  private _readerCount: number;\n  private _list: Map<number, RefCount<T>>;\n  private _count: number = 0;\n\n  constructor(readerCount: number) {\n    this._readerCount = readerCount;\n    this._list = new Map<number, RefCount<T>>();\n  }\n\n  clear() {\n    this._list.clear();\n  }\n  get count() {\n    return this._count;\n  }\n  get readerCount() {\n    return this._readerCount;\n  }\n  set readerCount(value: number) {\n    this._readerCount = value;\n  }\n  done() {\n    this._readerCount--;\n  }\n\n  get(index: number): T {\n    if (!this._list.has(index)) {\n      throw new Error('Element no longer available in the buffer.');\n    }\n    const res = this._list.get(index)!;\n    const val = res.value;\n    if (--res.count === 0) {\n      this._list.delete(index);\n    }\n    return val;\n  }\n\n  push(value: T) {\n    this._list.set(this._count++, { value: value, count: this._readerCount });\n  }\n}\n","import { IterableX } from './iterablex';\nimport { IRefCountList, MaxRefCountList, RefCountList } from './_refcountlist';\nimport { create } from './create';\n\nclass MemoizeBuffer<T> extends IterableX<T> {\n  private _source: Iterator<T>;\n  private _buffer: IRefCountList<T>;\n  private _error: any;\n  private _stopped: boolean = false;\n\n  constructor(source: Iterator<T>, buffer: IRefCountList<T>) {\n    super();\n    this._source = source;\n    this._buffer = buffer;\n  }\n\n  *[Symbol.iterator]() {\n    let i = 0;\n    try {\n      while (1) {\n        let hasValue = false,\n          current = <T>{};\n        if (i >= this._buffer.count) {\n          if (!this._stopped) {\n            try {\n              let next = this._source.next();\n              hasValue = !next.done;\n              if (hasValue) {\n                current = next.value;\n              }\n            } catch (e) {\n              this._error = e;\n              this._stopped = true;\n            }\n          }\n\n          if (this._stopped) {\n            throw this._error;\n          }\n\n          if (hasValue) {\n            this._buffer.push(current);\n          }\n        } else {\n          hasValue = true;\n        }\n\n        if (hasValue) {\n          yield this._buffer.get(i);\n        } else {\n          break;\n        }\n\n        i++;\n      }\n    } finally {\n      this._buffer.done();\n    }\n  }\n}\nexport function memoize<TSource>(\n  source: Iterable<TSource>,\n  readerCount?: number\n): IterableX<TSource>;\nexport function memoize<TSource, TResult>(\n  source: Iterable<TSource>,\n  readerCount?: number,\n  selector?: (value: Iterable<TSource>) => Iterable<TResult>\n): IterableX<TResult>;\nexport function memoize<TSource, TResult = TSource>(\n  source: Iterable<TSource>,\n  readerCount: number = -1,\n  selector?: (value: Iterable<TSource>) => Iterable<TResult>\n): IterableX<TSource | TResult> {\n  if (!selector) {\n    return readerCount === -1\n      ? new MemoizeBuffer<TSource>(source[Symbol.iterator](), new MaxRefCountList<TSource>())\n      : new MemoizeBuffer<TSource>(\n          source[Symbol.iterator](),\n          new RefCountList<TSource>(readerCount)\n        );\n  }\n  return create<TSource | TResult>(() =>\n    selector!(memoize(source, readerCount))[Symbol.iterator]()\n  );\n}\n","'use strict';\nimport { identity } from '../internal/identity';\n\nexport function min(source: Iterable<number>, fn?: (x: number) => number): number;\nexport function min<T>(source: Iterable<T>, fn: (x: T) => number): number;\nexport function min(source: Iterable<any>, fn: (x: any) => number = identity): number {\n  let atleastOnce = false;\n  let value = Infinity;\n  for (let item of source) {\n    if (!atleastOnce) {\n      atleastOnce = true;\n    }\n    let x = fn(item);\n    if (x < value) {\n      value = x;\n    }\n  }\n  if (!atleastOnce) {\n    throw new Error('Sequence contains no elements');\n  }\n\n  return value;\n}\n","import { IterableX } from './iterablex';\nimport { extremaBy, defaultCompare } from './_extremaby';\n\nexport function minBy<TSource, TKey>(\n  source: Iterable<TSource>,\n  keySelector: (x: TSource) => TKey,\n  comparer: (x: TKey, y: TKey) => number = defaultCompare\n): IterableX<TSource> {\n  return extremaBy(source, keySelector, (key, minValue) => -comparer(key, minValue));\n}\n","import { IterableX } from './iterablex';\nimport { map } from './map';\n\nfunction makeTuple<TFirst, TSecond>(x: TFirst, y: TSecond): [TFirst, TSecond] {\n  return [x, y];\n}\n\nclass OfEntriesIterable<TSource> extends IterableX<[string, TSource]> {\n  private _source: { [key: string]: TSource };\n\n  constructor(source: { [key: string]: TSource }) {\n    super();\n    this._source = source;\n  }\n\n  [Symbol.iterator]() {\n    return map(Object.keys(this._source), key => makeTuple(key, this._source[key]))[\n      Symbol.iterator\n    ]();\n  }\n}\n\nexport function ofEntries<TSource>(source: {\n  [key: string]: TSource;\n}): IterableX<[string, TSource]> {\n  return new OfEntriesIterable<TSource>(source);\n}\n","import { IterableX } from './iterablex';\n\nclass OfKeysIterable<TSource> extends IterableX<string> {\n  private _source: { [key: string]: TSource };\n\n  constructor(source: { [key: string]: TSource }) {\n    super();\n    this._source = source;\n  }\n\n  [Symbol.iterator]() {\n    return Object.keys(this._source)[Symbol.iterator]();\n  }\n}\n\nexport function ofKeys<TSource>(source: { [key: string]: TSource }): IterableX<string> {\n  return new OfKeysIterable<TSource>(source);\n}\n","import { IterableX } from './iterablex';\nimport { map } from './map';\n\nclass OfValuesIterable<TSource> extends IterableX<TSource> {\n  private _source: { [key: string]: TSource };\n\n  constructor(source: { [key: string]: TSource }) {\n    super();\n    this._source = source;\n  }\n\n  [Symbol.iterator]() {\n    return map(Object.keys(this._source), key => this._source[key])[Symbol.iterator]();\n  }\n}\n\nexport function ofValues<TSource>(source: { [key: string]: TSource }): IterableX<TSource> {\n  return new OfValuesIterable<TSource>(source);\n}\n","import { IterableX } from './iterablex';\n\nexport class OnErrorResumeNextIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<Iterable<TSource>>;\n\n  constructor(source: Iterable<Iterable<TSource>>) {\n    super();\n    this._source = source;\n  }\n\n  *[Symbol.iterator]() {\n    for (let item of this._source) {\n      let it = item[Symbol.iterator]();\n      while (1) {\n        let next;\n        try {\n          next = it.next();\n        } catch (e) {\n          break;\n        }\n\n        if (next.done) {\n          break;\n        }\n        yield next.value;\n      }\n    }\n  }\n}\n\nexport function onErrorResumeNext<T>(source: Iterable<T>, ...args: Iterable<T>[]): IterableX<T> {\n  return new OnErrorResumeNextIterable<T>([source, ...args]);\n}\n\nexport function onErrorResumeNextStatic<T>(...source: Iterable<T>[]): IterableX<T> {\n  return new OnErrorResumeNextIterable<T>(source);\n}\n","/**\n * @ignore\n */\nexport function sorter<TElement>(fst: TElement, snd: TElement): number {\n  return fst > snd ? 1 : fst < snd ? -1 : 0;\n}\n","import { IterableX } from './iterablex';\nimport { sorter as defaultSorter } from '../internal/sorter';\n\nexport abstract class OrderedIterableBaseX<TSource> extends IterableX<TSource> {\n  _source: Iterable<TSource>;\n\n  constructor(source: Iterable<TSource>) {\n    super();\n    this._source = source;\n  }\n\n  *[Symbol.iterator]() {\n    const array = Array.from<TSource>(this._source);\n    const len = array.length;\n    const indices = new Array<number>(len);\n    for (let i = 0, len = array.length; i < len; i++) {\n      indices[i] = i;\n    }\n\n    indices.sort(this._getSorter(array));\n    for (const index of indices) {\n      yield array[index];\n    }\n  }\n\n  thenBy<TKey>(\n    keySelector: (item: TSource) => TKey,\n    comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n  ): OrderedIterableBaseX<TSource> {\n    /* tslint:disable-next-line: no-use-before-declare */\n    return new OrderedIterableX<TKey, TSource>(this._source, keySelector, comparer, false, this);\n  }\n\n  thenByDescending<TKey>(\n    keySelector: (item: TSource) => TKey,\n    comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n  ): OrderedIterableBaseX<TSource> {\n    /* tslint:disable-next-line: no-use-before-declare */\n    return new OrderedIterableX<TKey, TSource>(this._source, keySelector, comparer, true, this);\n  }\n\n  abstract _getSorter(\n    elements: TSource[],\n    next?: (x: number, y: number) => number\n  ): (x: number, y: number) => number;\n}\n\nexport class OrderedIterableX<TKey, TSource> extends OrderedIterableBaseX<TSource> {\n  private _keySelector: (item: TSource) => TKey;\n  private _comparer: (fst: TKey, snd: TKey) => number;\n  private _descending: boolean;\n  private _parent?: OrderedIterableBaseX<TSource>;\n\n  constructor(\n    source: Iterable<TSource>,\n    keySelector: (item: TSource) => TKey,\n    comparer: (fst: TKey, snd: TKey) => number,\n    descending: boolean,\n    parent?: OrderedIterableBaseX<TSource>\n  ) {\n    super(source);\n    this._keySelector = keySelector;\n    this._comparer = comparer;\n    this._descending = descending;\n    this._parent = parent;\n  }\n\n  _getSorter(\n    elements: TSource[],\n    next?: (x: number, y: number) => number\n  ): (x: number, y: number) => number {\n    const keys = elements.map(this._keySelector);\n    const comparer = this._comparer;\n    const parent = this._parent;\n    const descending = this._descending;\n    const sorter = (x: number, y: number): number => {\n      const result = comparer(keys[x], keys[y]);\n      if (result === 0) {\n        return next ? next(x, y) : x - y;\n      }\n\n      return descending ? -result : result;\n    };\n\n    return parent ? parent._getSorter(elements, sorter) : sorter;\n  }\n}\n\nexport function orderBy<TKey, TSource>(\n  source: Iterable<TSource>,\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): OrderedIterableX<TKey, TSource> {\n  return new OrderedIterableX<TKey, TSource>(source, keySelector, comparer, false);\n}\n\nexport function orderByDescending<TKey, TSource>(\n  source: Iterable<TSource>,\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): OrderedIterableX<TKey, TSource> {\n  return new OrderedIterableX<TKey, TSource>(source, keySelector, comparer, true);\n}\n\nexport function thenBy<TKey, TSource>(\n  source: OrderedIterableBaseX<TSource>,\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): OrderedIterableX<TKey, TSource> {\n  return new OrderedIterableX<TKey, TSource>(source._source, keySelector, comparer, false, source);\n}\n\nexport function thenByDescending<TKey, TSource>(\n  source: OrderedIterableBaseX<TSource>,\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): OrderedIterableX<TKey, TSource> {\n  return new OrderedIterableX<TKey, TSource>(source._source, keySelector, comparer, true, source);\n}\n","import { IterableX } from './iterablex';\n\nexport class PairwiseIterable<TSource> extends IterableX<TSource[]> {\n  private _source: Iterable<TSource>;\n\n  constructor(source: Iterable<TSource>) {\n    super();\n    this._source = source;\n  }\n\n  *[Symbol.iterator]() {\n    let value: TSource | undefined,\n      hasValue = false;\n    for (const item of this._source) {\n      if (!hasValue) {\n        hasValue = true;\n      } else {\n        yield [value!, item];\n      }\n      value = item;\n    }\n  }\n}\n\n/**\n * Returns a new sequence that triggers on the second and subsequent triggerings of the input sequence.\n * @param {Iterable<T>} source Source sequence.\n * @return {Iterable<T[]>} A sequence that triggers on successive pairs of iterations from the input sequence.\n */\nexport function pairwise<TSource>(source: Iterable<TSource>): IterableX<TSource[]> {\n  return new PairwiseIterable<TSource>(source);\n}\n","import { IterableX } from './iterablex';\nimport { filter } from './filter';\n\nexport function partition<T, S extends T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => value is S,\n  thisArg?: any\n): IterableX<S>[];\nexport function partition<T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): IterableX<T>[];\nexport function partition<T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): IterableX<T>[] {\n  return [filter(source, predicate, thisArg), filter(source, (x, i) => !predicate(x, i), thisArg)];\n}\n","import { OperatorFunction } from '../interfaces';\nimport { IterableX } from './iterablex';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(source: Iterable<T>): IterableX<T>;\nexport function pipe<T, A>(source: Iterable<T>, op1: OperatorFunction<T, A>): IterableX<A>;\nexport function pipe<T, A, B>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>\n): IterableX<B>;\nexport function pipe<T, A, B, C>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>\n): IterableX<C>;\nexport function pipe<T, A, B, C, D>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>\n): IterableX<D>;\nexport function pipe<T, A, B, C, D, E>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>\n): IterableX<E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>,\n  op6: OperatorFunction<E, F>\n): IterableX<F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>,\n  op6: OperatorFunction<E, F>,\n  op7: OperatorFunction<F, G>\n): IterableX<G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>,\n  op6: OperatorFunction<E, F>,\n  op7: OperatorFunction<F, G>,\n  op8: OperatorFunction<G, H>\n): IterableX<H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  source: Iterable<T>,\n  op1: OperatorFunction<T, A>,\n  op2: OperatorFunction<A, B>,\n  op3: OperatorFunction<B, C>,\n  op4: OperatorFunction<C, D>,\n  op5: OperatorFunction<D, E>,\n  op6: OperatorFunction<E, F>,\n  op7: OperatorFunction<F, G>,\n  op8: OperatorFunction<G, H>,\n  op9: OperatorFunction<H, I>\n): IterableX<I>;\n/* tslint:enable:max-line-length */\n\nexport function pipe<TSource, TResult>(\n  source: Iterable<TSource>,\n  ...operations: OperatorFunction<TSource, TResult>[]\n): IterableX<TResult> {\n  if (operations.length === 0) {\n    return source instanceof IterableX ? source : IterableX.from(source);\n  }\n\n  const piped = (input: Iterable<TSource>): IterableX<TResult> => {\n    return operations.reduce(\n      (prev: any, fn: OperatorFunction<TSource, TResult>) => fn(prev),\n      input as any\n    );\n  };\n\n  return piped(source);\n}\n","import { IterableX } from './iterablex';\nimport { map } from './map';\n\nfunction plucker(props: string[], length: number): (x: any) => any {\n  const mapper = (x: any) => {\n    let currentProp = x;\n    for (let i = 0; i < length; i++) {\n      const p = currentProp[props[i]];\n      if (typeof p !== 'undefined') {\n        currentProp = p;\n      } else {\n        return undefined;\n      }\n    }\n    return currentProp;\n  };\n\n  return mapper;\n}\n\nexport function pluck<TSource, TResult>(\n  source: Iterable<TSource>,\n  ...args: string[]\n): IterableX<TResult> {\n  return map<TSource, TResult>(source, (plucker(args, args.length) as any) as (\n    value: TSource\n  ) => TResult);\n}\n","import { IterableX } from './iterablex';\nimport { RefCountList } from './_refcountlist';\nimport { create } from './create';\n\nclass PublishedBuffer<T> extends IterableX<T> {\n  private _buffer: RefCountList<T>;\n  private _source: Iterator<T>;\n  private _error: any;\n  private _stopped: boolean = false;\n\n  constructor(source: Iterator<T>) {\n    super();\n    this._source = source;\n    this._buffer = new RefCountList<T>(0);\n  }\n\n  private *_getIterable(i: number): Iterable<T> {\n    try {\n      while (1) {\n        let hasValue = false,\n          current = <T>{};\n        if (i >= this._buffer.count) {\n          if (!this._stopped) {\n            try {\n              let next = this._source.next();\n              hasValue = !next.done;\n              if (hasValue) {\n                current = next.value;\n              }\n            } catch (e) {\n              this._error = e;\n              this._stopped = true;\n            }\n          }\n\n          if (this._stopped) {\n            if (this._error) {\n              throw this._error;\n            } else {\n              break;\n            }\n          }\n\n          if (hasValue) {\n            this._buffer.push(current);\n          }\n        } else {\n          hasValue = true;\n        }\n\n        if (hasValue) {\n          yield this._buffer.get(i);\n        } else {\n          break;\n        }\n\n        i++;\n      }\n    } finally {\n      this._buffer.done();\n    }\n  }\n\n  [Symbol.iterator](): Iterator<T> {\n    this._buffer.readerCount++;\n    return this._getIterable(this._buffer.count)[Symbol.iterator]();\n  }\n}\n\nexport function publish<TSource>(source: Iterable<TSource>): IterableX<TSource>;\nexport function publish<TSource, TResult>(\n  source: Iterable<TSource>,\n  selector?: (value: Iterable<TSource>) => Iterable<TResult>\n): IterableX<TResult>;\nexport function publish<TSource, TResult>(\n  source: Iterable<TSource>,\n  selector?: (value: Iterable<TSource>) => Iterable<TResult>\n): IterableX<TSource | TResult> {\n  return selector\n    ? create(() => selector(publish(source))[Symbol.iterator]())\n    : new PublishedBuffer<TSource>(source[Symbol.iterator]());\n}\n","import { IterableX } from './iterablex';\n\nclass RangeIterable extends IterableX<number> {\n  private _start: number;\n  private _count: number;\n\n  constructor(start: number, count: number) {\n    super();\n    this._start = start;\n    this._count = count;\n  }\n\n  *[Symbol.iterator]() {\n    for (let current = this._start, end = this._start + this._count; current < end; current++) {\n      yield current;\n    }\n  }\n}\n\nexport function range(start: number, count: number): IterableX<number> {\n  return new RangeIterable(start, count);\n}\n","export function reduce<T, R = T>(\n  source: Iterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: never[]\n): R;\nexport function reduce<T, R = T>(\n  source: Iterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: R\n): R;\nexport function reduce<T, R = T>(\n  source: Iterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  ...seed: R[]\n): R {\n  const hasSeed = seed.length === 1;\n  let i = 0,\n    hasValue = false,\n    acc = seed[0] as T | R;\n  for (let item of source) {\n    if (hasValue || (hasValue = hasSeed)) {\n      acc = accumulator(<R>acc, item, i++);\n    } else {\n      acc = item;\n      hasValue = true;\n      i++;\n    }\n  }\n\n  if (!(hasSeed || hasValue)) {\n    throw new Error('Sequence contains no elements');\n  }\n\n  return acc as R;\n}\n","export function toArray<TSource>(source: Iterable<TSource>): TSource[] {\n  let results = [] as TSource[];\n  for (let item of source) {\n    results.push(item);\n  }\n  return results;\n}\n","import { toArray } from './toarray';\nexport function reduceRight<T, R = T>(\n  source: Iterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: never[]\n): R;\nexport function reduceRight<T, R = T>(\n  source: Iterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: R\n): R;\nexport function reduceRight<T, R = T>(\n  source: Iterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  ...seed: R[]\n): R {\n  const array = toArray(source);\n  const hasSeed = seed.length === 1;\n  let hasValue = false,\n    acc = seed[0] as T | R;\n  for (let offset = array.length - 1; offset >= 0; offset--) {\n    const item = array[offset];\n    if (hasValue || (hasValue = hasSeed)) {\n      acc = accumulator(<R>acc, item, offset);\n    } else {\n      acc = item;\n      hasValue = true;\n    }\n  }\n\n  if (!(hasSeed || hasValue)) {\n    throw new Error('Sequence contains no elements');\n  }\n\n  return acc as R;\n}\n","import { IterableX } from './iterablex';\n\nexport class RepeatIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _count: number;\n\n  constructor(source: Iterable<TSource>, count: number) {\n    super();\n    this._source = source;\n    this._count = count;\n  }\n\n  *[Symbol.iterator]() {\n    if (this._count === -1) {\n      while (1) {\n        for (let item of this._source) {\n          yield item;\n        }\n      }\n    } else {\n      for (let i = 0; i < this._count; i++) {\n        for (let item of this._source) {\n          yield item;\n        }\n      }\n    }\n  }\n}\n\nexport function repeat<TSource>(source: Iterable<TSource>, count: number = -1): IterableX<TSource> {\n  return new RepeatIterable<TSource>(source, count);\n}\n\nexport function repeatStatic<TSource>(value: TSource, count: number = -1): IterableX<TSource> {\n  return new RepeatIterable<TSource>(IterableX.of(value), count);\n}\n","import { IterableX } from './iterablex';\nimport { repeatStatic } from './repeat';\nimport { _catchAll } from './catch';\n\nexport function retry<TSource>(source: Iterable<TSource>, count: number = -1): IterableX<TSource> {\n  return _catchAll<TSource>(repeatStatic<Iterable<TSource>>(source, count));\n}\n","import { IterableX } from './iterablex';\n\nexport class ReverseIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n\n  constructor(source: Iterable<TSource>) {\n    super();\n    this._source = source;\n  }\n\n  *[Symbol.iterator]() {\n    let results = [] as TSource[];\n    for (let item of this._source) {\n      results.unshift(item);\n    }\n    yield* results;\n  }\n}\n\nexport function reverse<TSource>(source: Iterable<TSource>): IterableX<TSource> {\n  return new ReverseIterable<TSource>(source);\n}\n","import { IterableX } from './iterablex';\n\nexport class ScanIterable<T, R> extends IterableX<R> {\n  private _source: Iterable<T>;\n  private _fn: (acc: R, x: T, index: number) => R;\n  private _seed?: T | R;\n  private _hasSeed: boolean;\n\n  constructor(source: Iterable<T>, fn: (acc: R, x: T, index: number) => R, seed: R[]) {\n    super();\n    this._source = source;\n    this._fn = fn;\n    this._hasSeed = seed.length === 1;\n    this._seed = seed[0];\n  }\n\n  *[Symbol.iterator]() {\n    let i = 0,\n      hasValue = false,\n      acc = this._seed;\n    for (let item of this._source) {\n      if (hasValue || (hasValue = this._hasSeed)) {\n        acc = this._fn(<R>acc, item, i++);\n        yield acc;\n      } else {\n        acc = item;\n        hasValue = true;\n        i++;\n      }\n    }\n    if (i === 1 && !this._hasSeed) {\n      yield acc as R;\n    }\n  }\n}\n\nexport function scan<T, R = T>(\n  source: Iterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: never[]\n): IterableX<R>;\nexport function scan<T, R = T>(\n  source: Iterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: R\n): IterableX<R>;\nexport function scan<T, R = T>(\n  source: Iterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  ...seed: R[]\n): IterableX<R> {\n  return new ScanIterable(source, accumulator, seed);\n}\n","import { IterableX } from './iterablex';\nimport { toArray } from './toarray';\n\nexport class ScanRightIterable<T, R> extends IterableX<R> {\n  private _source: Iterable<T>;\n  private _fn: (acc: R, x: T, index: number) => R;\n  private _seed?: T | R;\n  private _hasSeed: boolean;\n\n  constructor(source: Iterable<T>, fn: (acc: R, x: T, index: number) => R, seed: R[]) {\n    super();\n    this._source = source;\n    this._fn = fn;\n    this._hasSeed = seed.length === 1;\n    this._seed = seed[0];\n  }\n\n  *[Symbol.iterator]() {\n    let hasValue = false,\n      acc = this._seed;\n    const source = toArray(this._source);\n    for (let offset = source.length - 1; offset >= 0; offset--) {\n      const item = source[offset];\n      if (hasValue || (hasValue = this._hasSeed)) {\n        acc = this._fn(<R>acc, item, offset);\n        yield acc;\n      } else {\n        acc = item;\n        hasValue = true;\n      }\n    }\n  }\n}\n\nexport function scanRight<T, R = T>(\n  source: Iterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: never[]\n): IterableX<R>;\nexport function scanRight<T, R = T>(\n  source: Iterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: R\n): IterableX<R>;\nexport function scanRight<T, R = T>(\n  source: Iterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  ...seed: R[]\n): IterableX<R> {\n  return new ScanRightIterable(source, accumulator, seed);\n}\n","import { comparer as defaultComparer } from '../internal/comparer';\n\nexport function sequenceEqual<T>(\n  source: Iterable<T>,\n  other: Iterable<T>,\n  comparer: (first: T, second: T) => boolean = defaultComparer\n): boolean {\n  const it1 = source[Symbol.iterator](),\n    it2 = other[Symbol.iterator]();\n  let next1: IteratorResult<T>, next2: IteratorResult<T>;\n  while (!(next1 = it1.next()).done) {\n    if (!(!(next2 = it2.next()).done && comparer(next1.value, next2.value))) {\n      return false;\n    }\n  }\n\n  return it2.next().done;\n}\n","import { IterableX } from './iterablex';\nimport { create } from './create';\n\nclass SharedIterable<T> extends IterableX<T> {\n  private _it: Iterator<T>;\n\n  constructor(it: Iterator<T>) {\n    super();\n    this._it = it;\n  }\n\n  [Symbol.iterator]() {\n    return this._it;\n  }\n}\n\nexport function share<TSource>(source: Iterable<TSource>): IterableX<TSource>;\nexport function share<TSource, TResult>(\n  source: Iterable<TSource>,\n  fn?: (value: Iterable<TSource>) => Iterable<TResult>\n): IterableX<TResult>;\nexport function share<TSource, TResult>(\n  source: Iterable<TSource>,\n  fn?: (value: Iterable<TSource>) => Iterable<TResult>\n): IterableX<TSource | TResult> {\n  return fn\n    ? create(() => fn(new SharedIterable(source[Symbol.iterator]()))[Symbol.iterator]())\n    : new SharedIterable(source[Symbol.iterator]());\n}\n","export function single<T, S extends T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => value is S\n): S | undefined;\nexport function single<T>(\n  source: Iterable<T>,\n  predicate?: (value: T, index: number) => boolean\n): T | undefined;\nexport function single<T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => boolean = () => true\n): T | undefined {\n  let result: T | undefined;\n  let hasResult = false;\n  let i = 0;\n  for (let item of source) {\n    if (hasResult && predicate(item, i++)) {\n      throw new Error('More than one element was found');\n    }\n    if (predicate(item, i++)) {\n      result = item;\n      hasResult = true;\n    }\n  }\n\n  return result;\n}\n","import { IterableX } from './iterablex';\n\nexport class SkipIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _count: number;\n\n  constructor(source: Iterable<TSource>, count: number) {\n    super();\n    this._source = source;\n    this._count = count;\n  }\n\n  *[Symbol.iterator]() {\n    let it = this._source[Symbol.iterator](),\n      count = this._count,\n      next;\n    while (count > 0 && !(next = it.next()).done) {\n      count--;\n    }\n    if (count <= 0) {\n      while (!(next = it.next()).done) {\n        yield next.value;\n      }\n    }\n  }\n}\n\nexport function skip<TSource>(source: Iterable<TSource>, count: number): IterableX<TSource> {\n  return new SkipIterable<TSource>(source, count);\n}\n","import { IterableX } from './iterablex';\n\nexport class SkipLastIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _count: number;\n\n  constructor(source: Iterable<TSource>, count: number) {\n    super();\n    this._source = source;\n    this._count = count;\n  }\n\n  *[Symbol.iterator]() {\n    let q = [] as TSource[];\n    for (let item of this._source) {\n      q.push(item);\n      if (q.length > this._count) {\n        yield q.shift()!;\n      }\n    }\n  }\n}\n\nexport function skipLast<TSource>(source: Iterable<TSource>, count: number): IterableX<TSource> {\n  return new SkipLastIterable<TSource>(source, count);\n}\n","import { IterableX } from './iterablex';\n\nexport class SkipWhileIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _predicate: (value: TSource, index: number) => boolean;\n\n  constructor(source: Iterable<TSource>, predicate: (value: TSource, index: number) => boolean) {\n    super();\n    this._source = source;\n    this._predicate = predicate;\n  }\n\n  *[Symbol.iterator]() {\n    let yielding = false,\n      i = 0;\n    for (let element of this._source) {\n      if (!yielding && !this._predicate(element, i++)) {\n        yielding = true;\n      }\n      if (yielding) {\n        yield element;\n      }\n    }\n  }\n}\n\nexport function skipWhile<T, S extends T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => value is S\n): IterableX<S>;\nexport function skipWhile<TSource>(\n  source: Iterable<TSource>,\n  predicate: (value: TSource, index: number) => boolean\n): IterableX<TSource>;\nexport function skipWhile<TSource>(\n  source: Iterable<TSource>,\n  predicate: (value: TSource, index: number) => boolean\n): IterableX<TSource> {\n  return new SkipWhileIterable<TSource>(source, predicate);\n}\n","import { IterableX } from './iterablex';\n\nexport class SliceIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _begin: number;\n  private _end: number;\n\n  constructor(source: Iterable<TSource>, begin: number, end: number) {\n    super();\n    this._source = source;\n    this._begin = begin;\n    this._end = end;\n  }\n\n  *[Symbol.iterator]() {\n    let it = this._source[Symbol.iterator](),\n      begin = this._begin,\n      next;\n    while (begin > 0 && !(next = it.next()).done) {\n      begin--;\n    }\n\n    let end = this._end;\n    if (end > 0) {\n      while (!(next = it.next()).done) {\n        yield next.value;\n        if (--end === 0) {\n          break;\n        }\n      }\n    }\n  }\n}\n\nexport function slice<TSource>(\n  source: Iterable<TSource>,\n  begin: number,\n  end: number = Infinity\n): IterableX<TSource> {\n  return new SliceIterable<TSource>(source, begin, end);\n}\n","export function some<T, S extends T>(\n  source: Iterable<T>,\n  comparer: (value: T, index: number) => value is S\n): boolean;\nexport function some<T>(\n  source: Iterable<T>,\n  comparer: (value: T, index: number) => boolean\n): boolean;\nexport function some<T>(\n  source: Iterable<T>,\n  comparer: (value: T, index: number) => boolean\n): boolean {\n  let i = 0;\n  for (let item of source) {\n    if (comparer(item, i++)) {\n      return true;\n    }\n  }\n  return false;\n}\n","import { IterableX } from './iterablex';\n\nexport class StartWithIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _args: TSource[];\n\n  constructor(source: Iterable<TSource>, args: TSource[]) {\n    super();\n    this._source = source;\n    this._args = args;\n  }\n\n  *[Symbol.iterator]() {\n    for (let x of this._args) {\n      yield x;\n    }\n    for (let item of this._source) {\n      yield item;\n    }\n  }\n}\n\nexport function startWith<TSource>(\n  source: Iterable<TSource>,\n  ...args: TSource[]\n): IterableX<TSource> {\n  return new StartWithIterable<TSource>(source, args);\n}\n","import { identity } from '../internal/identity';\n\nexport function sum(source: Iterable<number>, fn?: (x: number) => number): number;\nexport function sum<T>(source: Iterable<T>, fn: (x: T) => number): number;\nexport function sum(source: Iterable<any>, fn: (x: any) => number = identity): number {\n  let sum = 0;\n  for (let item of source) {\n    sum += fn(item);\n  }\n\n  return sum;\n}\n","import { IterableX } from './iterablex';\n\nexport class TakeIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _count: number;\n\n  constructor(source: Iterable<TSource>, count: number) {\n    super();\n    this._source = source;\n    this._count = count;\n  }\n\n  *[Symbol.iterator]() {\n    let i = this._count;\n    if (i > 0) {\n      for (let item of this._source) {\n        yield item;\n        if (--i === 0) {\n          break;\n        }\n      }\n    }\n  }\n}\n\nexport function take<TSource>(source: Iterable<TSource>, count: number): IterableX<TSource> {\n  return new TakeIterable<TSource>(source, count);\n}\n","import { IterableX } from './iterablex';\n\nexport class TakeLastIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _count: number;\n\n  constructor(source: Iterable<TSource>, count: number) {\n    super();\n    this._source = source;\n    this._count = count;\n  }\n\n  *[Symbol.iterator]() {\n    if (this._count > 0) {\n      let q = [] as TSource[];\n      for (let item of this._source) {\n        if (q.length >= this._count) {\n          q.shift();\n        }\n        q.push(item);\n      }\n\n      while (q.length > 0) {\n        yield q.shift()!;\n      }\n    }\n  }\n}\n\nexport function takeLast<TSource>(source: Iterable<TSource>, count: number): IterableX<TSource> {\n  return new TakeLastIterable<TSource>(source, count);\n}\n","import { IterableX } from './iterablex';\n\nexport class TakeWhileIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _predicate: (value: TSource, index: number) => boolean;\n\n  constructor(source: Iterable<TSource>, predicate: (value: TSource, index: number) => boolean) {\n    super();\n    this._source = source;\n    this._predicate = predicate;\n  }\n\n  *[Symbol.iterator]() {\n    let i = 0;\n    for (let item of this._source) {\n      if (!this._predicate(item, i++)) {\n        break;\n      }\n      yield item;\n    }\n  }\n}\n\nexport function takeWhile<T, S extends T>(\n  source: Iterable<T>,\n  predicate: (value: T, index: number) => value is S\n): IterableX<S>;\nexport function takeWhile<TSource>(\n  source: Iterable<TSource>,\n  predicate: (value: TSource, index: number) => boolean\n): IterableX<TSource>;\nexport function takeWhile<TSource>(\n  source: Iterable<TSource>,\n  predicate: (value: TSource, index: number) => boolean\n): IterableX<TSource> {\n  return new TakeWhileIterable<TSource>(source, predicate);\n}\n","import { IterableX } from './iterablex';\nimport { PartialObserver } from '../observer';\n\nexport class TapIterable<TSource> extends IterableX<TSource> {\n  private _source: Iterable<TSource>;\n  private _observer: PartialObserver<TSource>;\n\n  constructor(source: Iterable<TSource>, observer: PartialObserver<TSource>) {\n    super();\n    this._source = source;\n    this._observer = observer;\n  }\n\n  *[Symbol.iterator]() {\n    const it = this._source[Symbol.iterator]();\n    while (1) {\n      let next;\n      try {\n        next = it.next();\n        if (next.done) {\n          break;\n        }\n      } catch (e) {\n        if (this._observer.error) {\n          this._observer.error(e);\n        }\n        throw e;\n      }\n\n      if (this._observer.next) {\n        this._observer.next(next.value);\n      }\n      yield next.value;\n    }\n\n    if (this._observer.complete) {\n      this._observer.complete();\n    }\n  }\n}\n\n/**\n * Lazily invokes observer methods for each value in the sequence, and upon successful or exceptional termination.\n * @param {Iterable<TSource>} source Source sequence.\n * @param {PartialObserver<TSource>} observer Observer to invoke notification calls on.<\n * @return {Ierable<TSource>} Sequence exhibiting the side-effects of observer method invocation upon iteration.\n */\nexport function tap<TSource>(\n  source: Iterable<TSource>,\n  observer: PartialObserver<TSource>\n): IterableX<TSource> {\n  return new TapIterable<TSource>(source, observer);\n}\n","import { IterableX } from './iterablex';\n\nclass ThrowIterable<TSource> extends IterableX<TSource> {\n  private _error: any;\n\n  constructor(error: any) {\n    super();\n    this._error = error;\n  }\n\n  *[Symbol.iterator](): Iterator<TSource> {\n    throw this._error;\n  }\n}\n\nexport function _throw<TSource>(error: any): IterableX<TSource> {\n  return new ThrowIterable<TSource>(error);\n}\n","const ARRAY_VALUE = 'value';\nconst ARRAY_ERROR = 'error';\n\ninterface AsyncSinkItem<T> {\n  type: string;\n  value?: T;\n  error?: any;\n}\n\ninterface AsyncResolver<T> {\n  resolve: (value?: T | PromiseLike<T> | undefined) => void;\n  reject: (reason?: any) => void;\n}\n\nexport class AsyncSink<TSource> implements AsyncIterableIterator<TSource> {\n  private _ended: boolean;\n  private _values: AsyncSinkItem<TSource>[];\n  private _resolvers: AsyncResolver<IteratorResult<TSource>>[];\n\n  constructor() {\n    this._ended = false;\n    this._values = [];\n    this._resolvers = [];\n  }\n\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n\n  write(value: TSource) {\n    this._push({ type: ARRAY_VALUE, value });\n  }\n\n  error(error: any) {\n    this._push({ type: ARRAY_ERROR, error });\n  }\n\n  private _push(item: AsyncSinkItem<TSource>) {\n    if (this._ended) {\n      throw new Error('AsyncSink already ended');\n    }\n\n    if (this._resolvers.length > 0) {\n      const { resolve, reject } = this._resolvers.shift()!;\n      if (item.type === ARRAY_ERROR) {\n        reject(item.error!);\n      } else {\n        resolve({ done: false, value: item.value! });\n      }\n    } else {\n      this._values.push(item);\n    }\n  }\n\n  next() {\n    if (this._values.length > 0) {\n      const { type, value, error } = this._values.shift()!;\n      if (type === ARRAY_ERROR) {\n        return Promise.reject(error);\n      } else {\n        return Promise.resolve({ done: false, value } as IteratorResult<TSource>);\n      }\n    }\n\n    if (this._ended) {\n      return Promise.resolve({ done: true } as IteratorResult<TSource>);\n    }\n\n    return new Promise<IteratorResult<TSource>>((resolve, reject) => {\n      this._resolvers.push({ resolve, reject });\n    });\n  }\n\n  end() {\n    while (this._resolvers.length > 0) {\n      this._resolvers.shift()!.resolve({ done: true } as IteratorResult<TSource>);\n    }\n    this._ended = true;\n  }\n}\n","import { AsyncSink } from './../asyncsink';\nimport { OperatorAsyncFunction } from '../interfaces';\nimport { bindCallback } from '../internal/bindcallback';\nimport { identityAsync } from '../internal/identity';\nimport { toLength } from '../internal/tolength';\nimport { Observable } from '../observer';\nimport {\n  isArrayLike,\n  isIterable,\n  isIterator,\n  isAsyncIterable,\n  isReadableNodeStream,\n  isWritableNodeStream\n} from '../internal/isiterable';\n\n/**\n * This class serves as the base for all operations which support [Symbol.asyncIterator].\n */\nexport abstract class AsyncIterableX<T> implements AsyncIterable<T> {\n  abstract [Symbol.asyncIterator](): AsyncIterator<T>;\n\n  async forEach(\n    projection: (value: T, index: number) => void | Promise<void>,\n    thisArg?: any\n  ): Promise<void> {\n    const fn = bindCallback(projection, thisArg, 2);\n    let i = 0;\n    for await (let item of this) {\n      await fn(item, i++);\n    }\n  }\n\n  pipe<R>(...operations: OperatorAsyncFunction<T, R>[]): AsyncIterableX<R>;\n  pipe<R extends NodeJS.WritableStream>(writable: R, options?: { end?: boolean }): R;\n  pipe<R>(...args: any[]) {\n    let i = -1;\n    let n = args.length;\n    let acc: any = this;\n    let as = AsyncIterableX.as;\n    while (++i < n) {\n      acc = as(args[i](acc));\n    }\n    return acc;\n  }\n\n  tee(): [ReadableStream<T>, ReadableStream<T>] {\n    return this._getDOMStream().tee();\n  }\n\n  pipeTo(writable: WritableStream<T>, options?: PipeOptions) {\n    return this._getDOMStream().pipeTo(writable, options);\n  }\n\n  pipeThrough<R extends ReadableStream<any>>(\n    duplex: { writable: WritableStream<T>; readable: R },\n    options?: PipeOptions\n  ) {\n    return this._getDOMStream().pipeThrough(duplex, options);\n  }\n\n  private _DOMStream?: ReadableStream<T>;\n  private _getDOMStream(): ReadableStream<T> {\n    return this._DOMStream || (this._DOMStream = this.publish().toDOMStream());\n  }\n\n  static as(source: string): AsyncIterableX<string>;\n  static as<T extends AsyncIterableX<any>>(source: T): T;\n  static as<T>(source: AsyncIterableInput<T>): AsyncIterableX<T>;\n  static as<T>(source: T): AsyncIterableX<T>;\n  /** @nocollapse */\n  static as(source: any) {\n    /* tslint:disable */\n    if (source instanceof AsyncIterableX) {\n      return source;\n    }\n    if (typeof source === 'string') {\n      return new OfAsyncIterable([source]);\n    }\n    if (isIterable(source) || isAsyncIterable(source)) {\n      return new FromAsyncIterable(source, identityAsync);\n    }\n    if (isPromise(source)) {\n      return new FromPromiseIterable(source, identityAsync);\n    }\n    if (isObservable(source)) {\n      return new FromObservableAsyncIterable(source, identityAsync);\n    }\n    if (isArrayLike(source)) {\n      return new FromArrayIterable(source, identityAsync);\n    }\n    return new OfAsyncIterable([source]);\n    /* tslint:enable */\n  }\n\n  /** @nocollapse */\n  static from<TSource, TResult = TSource>(\n    source: AsyncIterableInput<TSource>,\n    selector: (value: TSource, index: number) => TResult | Promise<TResult> = identityAsync,\n    thisArg?: any\n  ): AsyncIterableX<TResult> {\n    const fn = bindCallback(selector, thisArg, 2);\n    /* tslint:disable */\n    if (isIterable(source) || isAsyncIterable(source)) {\n      return new FromAsyncIterable<TSource, TResult>(source, fn);\n    }\n    if (isPromise(source)) {\n      return new FromPromiseIterable<TSource, TResult>(source, fn);\n    }\n    if (isObservable(source)) {\n      return new FromObservableAsyncIterable<TSource, TResult>(source, fn);\n    }\n    if (isArrayLike(source)) {\n      return new FromArrayIterable<TSource, TResult>(source, fn);\n    }\n    if (isIterator(source)) {\n      return new FromAsyncIterable<TSource, TResult>({ [Symbol.asyncIterator]: () => source }, fn);\n    }\n    throw new TypeError('Input type not supported');\n    /* tslint:enable */\n  }\n\n  /** @nocollapse */\n  static of<TSource>(...args: TSource[]): AsyncIterableX<TSource> {\n    //tslint:disable-next-line\n    return new OfAsyncIterable<TSource>(args);\n  }\n}\n\nclass FromArrayIterable<TSource, TResult = TSource> extends AsyncIterableX<TResult> {\n  private _source: ArrayLike<TSource>;\n  private _selector: (value: TSource, index: number) => TResult | Promise<TResult>;\n\n  constructor(\n    source: ArrayLike<TSource>,\n    selector: (value: TSource, index: number) => TResult | Promise<TResult>\n  ) {\n    super();\n    this._source = source;\n    this._selector = selector;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let i = 0;\n    const length = toLength((<ArrayLike<TSource>>this._source).length);\n    while (i < length) {\n      yield await this._selector(this._source[i], i++);\n    }\n  }\n}\n\nclass FromAsyncIterable<TSource, TResult = TSource> extends AsyncIterableX<TResult> {\n  private _source: Iterable<TSource | PromiseLike<TSource>> | AsyncIterable<TSource>;\n  private _selector: (value: TSource, index: number) => TResult | Promise<TResult>;\n\n  constructor(\n    source: Iterable<TSource | PromiseLike<TSource>> | AsyncIterable<TSource>,\n    selector: (value: TSource, index: number) => TResult | Promise<TResult>\n  ) {\n    super();\n    this._source = source;\n    this._selector = selector;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let i = 0;\n    for await (let item of <AsyncIterable<TSource>>this._source) {\n      yield await this._selector(item, i++);\n    }\n  }\n}\n\nclass FromPromiseIterable<TSource, TResult = TSource> extends AsyncIterableX<TResult> {\n  private _source: PromiseLike<TSource>;\n  private _selector: (value: TSource, index: number) => TResult | Promise<TResult>;\n\n  constructor(\n    source: PromiseLike<TSource>,\n    selector: (value: TSource, index: number) => TResult | Promise<TResult>\n  ) {\n    super();\n    this._source = source;\n    this._selector = selector;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    const item = await this._source;\n    yield await this._selector(item, 0);\n  }\n}\n\nclass FromObservableAsyncIterable<TSource, TResult = TSource> extends AsyncIterableX<TResult> {\n  private _observable: Observable<TSource>;\n  private _selector: (value: TSource, index: number) => TResult | Promise<TResult>;\n\n  constructor(\n    observable: Observable<TSource>,\n    selector: (value: TSource, index: number) => TResult | Promise<TResult>\n  ) {\n    super();\n    this._observable = observable;\n    this._selector = selector;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    const sink: AsyncSink<TSource> = new AsyncSink<TSource>();\n    const subscription = this._observable.subscribe({\n      next(value: TSource) {\n        sink.write(value);\n      },\n      error(err: any) {\n        sink.error(err);\n      },\n      complete() {\n        sink.end();\n      }\n    });\n\n    let i = 0;\n    try {\n      for (let next; !(next = await sink.next()).done; ) {\n        yield await this._selector(next.value!, i++);\n      }\n    } finally {\n      subscription.unsubscribe();\n    }\n  }\n}\n\nexport type AsyncIterableInput<TSource> =\n  | AsyncIterable<TSource>\n  | AsyncIterator<TSource>\n  | Iterable<TSource | PromiseLike<TSource>>\n  | ArrayLike<TSource>\n  | PromiseLike<TSource>\n  | Observable<TSource>;\n\nfunction isPromise(x: any): x is PromiseLike<any> {\n  return x != null && Object(x) === x && typeof x['then'] === 'function';\n}\n\nfunction isObservable(x: any): x is Observable<any> {\n  return x != null && Object(x) === x && typeof x['subscribe'] === 'function';\n}\n\nclass OfAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _args: TSource[];\n\n  constructor(args: TSource[]) {\n    super();\n    this._args = args;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for (let item of this._args) {\n      yield item;\n    }\n  }\n}\n\ntype WritableOrOperatorAsyncFunction<T, R> =\n  | NodeJS.WritableStream\n  | NodeJS.ReadWriteStream\n  | OperatorAsyncFunction<T, R>;\n\ndeclare module '../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    pipe(): AsyncIterableX<T>;\n    pipe<A>(op1: OperatorAsyncFunction<T, A>): AsyncIterableX<A>;\n    pipe<A, B>(\n      op1: OperatorAsyncFunction<T, A>,\n      op2: OperatorAsyncFunction<A, B>\n    ): AsyncIterableX<B>;\n    pipe<A, B, C>(\n      op1: OperatorAsyncFunction<T, A>,\n      op2: OperatorAsyncFunction<A, B>,\n      op3: OperatorAsyncFunction<B, C>\n    ): AsyncIterableX<C>;\n    pipe<A, B, C, D>(\n      op1: OperatorAsyncFunction<T, A>,\n      op2: OperatorAsyncFunction<A, B>,\n      op3: OperatorAsyncFunction<B, C>,\n      op4: OperatorAsyncFunction<C, D>\n    ): AsyncIterableX<D>;\n    pipe<A, B, C, D, E>(\n      op1: OperatorAsyncFunction<T, A>,\n      op2: OperatorAsyncFunction<A, B>,\n      op3: OperatorAsyncFunction<B, C>,\n      op4: OperatorAsyncFunction<C, D>,\n      op5: OperatorAsyncFunction<D, E>\n    ): AsyncIterableX<E>;\n    pipe<A, B, C, D, E, F>(\n      op1: OperatorAsyncFunction<T, A>,\n      op2: OperatorAsyncFunction<A, B>,\n      op3: OperatorAsyncFunction<B, C>,\n      op4: OperatorAsyncFunction<C, D>,\n      op5: OperatorAsyncFunction<D, E>,\n      op6: OperatorAsyncFunction<E, F>\n    ): AsyncIterableX<F>;\n    pipe<A, B, C, D, E, F, G>(\n      op1: OperatorAsyncFunction<T, A>,\n      op2: OperatorAsyncFunction<A, B>,\n      op3: OperatorAsyncFunction<B, C>,\n      op4: OperatorAsyncFunction<C, D>,\n      op5: OperatorAsyncFunction<D, E>,\n      op6: OperatorAsyncFunction<E, F>,\n      op7: OperatorAsyncFunction<F, G>\n    ): AsyncIterableX<G>;\n    pipe<A, B, C, D, E, F, G, H>(\n      op1: OperatorAsyncFunction<T, A>,\n      op2: OperatorAsyncFunction<A, B>,\n      op3: OperatorAsyncFunction<B, C>,\n      op4: OperatorAsyncFunction<C, D>,\n      op5: OperatorAsyncFunction<D, E>,\n      op6: OperatorAsyncFunction<E, F>,\n      op7: OperatorAsyncFunction<F, G>,\n      op8: OperatorAsyncFunction<G, H>\n    ): AsyncIterableX<H>;\n    pipe<A, B, C, D, E, F, G, H, I>(\n      op1: OperatorAsyncFunction<T, A>,\n      op2: OperatorAsyncFunction<A, B>,\n      op3: OperatorAsyncFunction<B, C>,\n      op4: OperatorAsyncFunction<C, D>,\n      op5: OperatorAsyncFunction<D, E>,\n      op6: OperatorAsyncFunction<E, F>,\n      op7: OperatorAsyncFunction<F, G>,\n      op8: OperatorAsyncFunction<G, H>,\n      op9: OperatorAsyncFunction<H, I>\n    ): AsyncIterableX<I>;\n    pipe(...operations: OperatorAsyncFunction<any, any>[]): AsyncIterableX<{}>;\n    pipe<A extends NodeJS.WritableStream>(op1: A, options?: { end?: boolean }): A;\n  }\n}\n\ntry {\n  (isBrowser => {\n    if (isBrowser) {\n      return;\n    }\n\n    const as = AsyncIterableX.as;\n    AsyncIterableX.prototype.pipe = nodePipe;\n    const readableOpts = (x: any, opts = x._writableState || { objectMode: true }) => opts;\n\n    function nodePipe<T>(this: AsyncIterableX<T>, ...args: any[]) {\n      let i = -1;\n      let end: boolean;\n      let n = args.length;\n      let prev: any = this;\n      let next: WritableOrOperatorAsyncFunction<T, any>;\n      while (++i < n) {\n        next = args[i];\n        if (typeof next === 'function') {\n          prev = as(next(prev));\n        } else if (isWritableNodeStream(next)) {\n          ({ end = true } = args[i + 1] || {});\n          // prettier-ignore\n          return isReadableNodeStream(prev) ? prev.pipe(next, {end}) :\n             prev.toNodeStream(readableOpts(next)).pipe(next, {end});\n        }\n      }\n      return prev;\n    }\n  })(typeof window === 'object' && typeof document === 'object' && document.nodeType === 9);\n} catch (e) {\n  /* */\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nclass AnonymousAsyncIterable<T> extends AsyncIterableX<T> {\n  private _fn: () => AsyncIterator<T> | Promise<AsyncIterator<T>>;\n\n  constructor(fn: () => AsyncIterator<T> | Promise<AsyncIterator<T>>) {\n    super();\n    this._fn = fn;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let it = await this._fn(),\n      next: IteratorResult<T> | undefined;\n    while (!(next = await it.next()).done) {\n      yield next.value;\n    }\n  }\n}\n\nexport function create<T>(\n  fn: () => AsyncIterator<T> | Promise<AsyncIterator<T>>\n): AsyncIterableX<T> {\n  return new AnonymousAsyncIterable(fn);\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { IRefCountList, MaxRefCountList, RefCountList } from '../iterable/_refcountlist';\nimport { create } from './create';\n\nexport class MemoizeAsyncBuffer<T> extends AsyncIterableX<T> {\n  protected _source: AsyncIterator<T>;\n  protected _buffer: IRefCountList<T>;\n  protected _shared: Promise<IteratorResult<T>> | null;\n  protected _error: any;\n  protected _stopped: boolean;\n\n  constructor(source: AsyncIterator<T>, buffer: IRefCountList<T>) {\n    super();\n    this._error = null;\n    this._shared = null;\n    this._stopped = false;\n    this._source = source;\n    this._buffer = buffer;\n  }\n\n  [Symbol.asyncIterator]() {\n    return this._getIterable(0);\n  }\n\n  protected async *_getIterable(offset = 0) {\n    let i = offset - 1;\n    let done: boolean = false;\n    let buffer = this._buffer;\n\n    try {\n      do {\n        if (++i < buffer.count) {\n          yield buffer.get(i);\n          continue;\n        }\n\n        if (this._stopped) {\n          throw this._error;\n        }\n\n        if (this._shared === null) {\n          this._shared = this._source.next().then(r => {\n            this._shared = null;\n            if (!r.done) {\n              buffer.push(r.value);\n            }\n            return r;\n          });\n        }\n\n        ({ done } = await this._shared.catch(e => {\n          this._error = e;\n          this._stopped = true;\n          throw e;\n        }));\n\n        if (!done) {\n          yield buffer.get(i);\n        }\n      } while (!done);\n    } finally {\n      buffer.done();\n    }\n  }\n}\n\nexport function memoize<TSource>(\n  source: AsyncIterable<TSource>,\n  readerCount?: number\n): AsyncIterableX<TSource>;\nexport function memoize<TSource, TResult>(\n  source: AsyncIterable<TSource>,\n  readerCount?: number,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): AsyncIterableX<TResult>;\nexport function memoize<TSource, TResult = TSource>(\n  source: AsyncIterable<TSource>,\n  readerCount: number = -1,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): AsyncIterableX<TSource | TResult> {\n  if (!selector) {\n    return readerCount === -1\n      ? new MemoizeAsyncBuffer<TSource>(\n          source[Symbol.asyncIterator](),\n          new MaxRefCountList<TSource>()\n        )\n      : new MemoizeAsyncBuffer<TSource>(\n          source[Symbol.asyncIterator](),\n          new RefCountList<TSource>(readerCount)\n        );\n  }\n  return create<TSource | TResult>(() =>\n    selector!(memoize(source, readerCount))[Symbol.asyncIterator]()\n  );\n}\n","import { create } from './create';\nimport { MemoizeAsyncBuffer } from './memoize';\nimport { AsyncIterableX } from './asynciterablex';\nimport { RefCountList } from '../iterable/_refcountlist';\n\nclass PublishedAsyncBuffer<T> extends MemoizeAsyncBuffer<T> {\n  // @ts-ignore\n  protected _buffer: RefCountList<T>;\n\n  constructor(source: AsyncIterator<T>) {\n    super(source, new RefCountList<T>(0));\n  }\n\n  [Symbol.asyncIterator]() {\n    this._buffer.readerCount++;\n    return this._getIterable(this._buffer.count)[Symbol.asyncIterator]();\n  }\n}\n\nexport function publish<TSource>(source: AsyncIterable<TSource>): AsyncIterableX<TSource>;\nexport function publish<TSource, TResult>(\n  source: AsyncIterable<TSource>,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): AsyncIterableX<TResult>;\nexport function publish<TSource, TResult>(\n  source: AsyncIterable<TSource>,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): AsyncIterableX<TSource | TResult> {\n  return selector\n    ? create(async () => selector(publish(source))[Symbol.asyncIterator]())\n    : new PublishedAsyncBuffer<TSource>(source[Symbol.asyncIterator]());\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { publish } from '../../asynciterable/publish';\n\nexport function publishProto<TSource>(this: AsyncIterableX<TSource>): AsyncIterableX<TSource>;\nexport function publishProto<TSource, TResult>(\n  this: AsyncIterableX<TSource>,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): AsyncIterableX<TResult>;\n/**\n * @ignore\n */\nexport function publishProto<TSource, TResult>(\n  this: AsyncIterableX<TSource>,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): AsyncIterableX<TSource | TResult> {\n  return publish(this, selector);\n}\n\nAsyncIterableX.prototype.publish = publishProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    publish: typeof publishProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport {\n  toDOMStream,\n  ReadableBYOBStreamOptions,\n  ReadableByteStreamOptions\n} from '../../asynciterable/todomstream';\n\n/**\n * @ignore\n */\nexport function toDOMStreamProto<T>(\n  this: AsyncIterable<T>,\n  strategy?: QueuingStrategy<T>\n): ReadableStream<T>;\nexport function toDOMStreamProto<T>(\n  this: AsyncIterable<T>,\n  options: ReadableBYOBStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStreamProto<T>(\n  this: AsyncIterable<T>,\n  options: ReadableByteStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStreamProto(\n  this: AsyncIterable<any>,\n  options?: QueuingStrategy<any> | ReadableBYOBStreamOptions | ReadableByteStreamOptions\n) {\n  return !options ? toDOMStream(this) : toDOMStream(this, options);\n}\n\nAsyncIterableX.prototype.toDOMStream = toDOMStreamProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    toDOMStream: typeof toDOMStreamProto;\n  }\n}\n","import { AsyncIterableX } from './asynciterablex';\n\n// To work around circular-dependency hell, these need to be on\n// the AsyncIterable prototype for tee, pipeTo, and pipeThrough\nimport '../add/asynciterable-operators/publish';\nimport '../add/asynciterable-operators/todomstream';\n\n/** @ignore */\nconst SharedArrayBuf = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer;\n\nexport class AsyncIterableReadableStream<T> extends AsyncIterableX<T> {\n  constructor(protected _stream: ReadableStream<T>) {\n    super();\n  }\n  [Symbol.asyncIterator]() {\n    const stream = this._stream;\n    const reader = stream['getReader']();\n    return _consumeReader(stream, reader, defaultReaderToAsyncIterator(reader));\n  }\n}\n\nexport class AsyncIterableReadableByteStream extends AsyncIterableReadableStream<Uint8Array> {\n  [Symbol.asyncIterator]() {\n    let stream = this._stream;\n    let reader: ReadableStreamBYOBReader;\n    try {\n      reader = stream['getReader']({ mode: 'byob' });\n    } catch (e) {\n      return super[Symbol.asyncIterator]() as AsyncIterableIterator<Uint8Array>;\n    }\n    const iterator = _consumeReader(stream, reader, byobReaderToAsyncIterator(reader));\n    // \"pump\" the iterator once so it initializes and is ready to accept a buffer or bytesToRead\n    iterator.next();\n    return iterator;\n  }\n}\n\nasync function* _consumeReader<T>(\n  stream: ReadableStream<T>,\n  reader: ReadableStreamBYOBReader | ReadableStreamDefaultReader,\n  iterator: AsyncIterableIterator<T>\n) {\n  let threw = false;\n  try {\n    yield* iterator;\n  } catch (e) {\n    if ((threw = true) && reader) {\n      await reader['cancel'](e);\n    }\n  } finally {\n    if (!reader) {\n      return;\n    }\n    if (!threw) {\n      await reader['cancel']();\n    }\n    if (stream.locked) {\n      try {\n        reader.closed.catch(() => {\n          /* */\n        });\n        reader.releaseLock();\n      } catch (e) {\n        /* */\n      }\n    }\n  }\n}\n\n/** @ignore */\nasync function* defaultReaderToAsyncIterator<T = any>(reader: ReadableStreamDefaultReader<T>) {\n  let r: ReadableStreamReadResult<T>;\n  while (!(r = await reader.read()).done) {\n    yield r.value;\n  }\n}\n\n/** @ignore */\nasync function* byobReaderToAsyncIterator(reader: ReadableStreamBYOBReader) {\n  let r: IteratorResult<Uint8Array>;\n  let value: number | ArrayBufferLike = yield null!;\n  while (!(r = await readNext(reader, value, 0)).done) {\n    value = yield r.value;\n  }\n}\n\n/** @ignore */\nasync function readNext(\n  reader: ReadableStreamBYOBReader,\n  bufferOrLen: ArrayBufferLike | number,\n  offset: number\n): Promise<ReadableStreamReadResult<Uint8Array>> {\n  let size: number;\n  let buffer: ArrayBufferLike;\n\n  if (typeof bufferOrLen === 'number') {\n    buffer = new ArrayBuffer((size = bufferOrLen));\n  } else if (bufferOrLen instanceof ArrayBuffer) {\n    size = (buffer = bufferOrLen).byteLength;\n  } else if (bufferOrLen instanceof SharedArrayBuf) {\n    size = (buffer = bufferOrLen).byteLength;\n  } else {\n    return { done: true, value: undefined! };\n  }\n\n  return await readInto(reader, buffer, offset, size);\n}\n\n/** @ignore */\nasync function readInto(\n  reader: ReadableStreamBYOBReader,\n  buffer: ArrayBufferLike,\n  offset: number,\n  size: number\n): Promise<ReadableStreamReadResult<Uint8Array>> {\n  if (offset >= size) {\n    return { done: false, value: new Uint8Array(buffer, 0, size) };\n  }\n  const { done, value } = await reader.read(new Uint8Array(buffer, offset, size - offset));\n  if ((offset += value.byteLength) < size && !done) {\n    return await readInto(reader, value.buffer, offset, size);\n  }\n  return { done, value: new Uint8Array(value.buffer, 0, offset) };\n}\n\nexport function fromDOMStream<TSource>(stream: ReadableStream<TSource>): AsyncIterableX<TSource>;\nexport function fromDOMStream<TSource extends ArrayBufferView>(\n  stream: ReadableStream<TSource>,\n  options: { mode: 'byob' }\n): AsyncIterableX<TSource>;\n\nexport function fromDOMStream(stream: ReadableStream, options?: { mode: 'byob' }) {\n  return !options || options.mode !== 'byob'\n    ? new AsyncIterableReadableStream(stream)\n    : new AsyncIterableReadableByteStream(stream);\n}\n","import { fromDOMStream } from './fromdomstream';\n\nexport type ReadableBYOBStreamOptions<T = any> = QueuingStrategy<T> & { type: 'bytes' };\nexport type ReadableByteStreamOptions<T = any> = QueuingStrategy<T> & {\n  type: 'bytes';\n  autoAllocateChunkSize?: number;\n};\n\n/** @ignore */\nfunction memcpy<TTarget extends ArrayBufferView, TSource extends ArrayBufferView>(\n  target: TTarget,\n  source: TSource,\n  targetByteOffset = 0,\n  sourceByteLength = source.byteLength\n) {\n  const targetByteLength = target.byteLength;\n  const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);\n  const src = new Uint8Array(\n    source.buffer,\n    source.byteOffset,\n    Math.min(sourceByteLength, targetByteLength, source.buffer.byteLength - source.byteOffset)\n  );\n  dst.set(src, targetByteOffset);\n  return src.byteLength;\n}\n\nabstract class AbstractUnderlyingSource<TSource> {\n  constructor(protected _source: AsyncIterator<TSource> | null) {}\n  async cancel() {\n    const source = this._source;\n    if (source && source.return) {\n      await source.return();\n    }\n    this._source = null;\n  }\n}\n\nclass UnderlyingAsyncIterableDefaultSource<TSource = any> extends AbstractUnderlyingSource<TSource>\n  implements UnderlyingSource<TSource> {\n  constructor(source: AsyncIterator<TSource> | null) {\n    super(source);\n  }\n  async pull(controller: ReadableStreamDefaultController<TSource>) {\n    const source = this._source;\n    if (source) {\n      const r = await source.next(controller.desiredSize);\n      if (!r.done) {\n        return controller.enqueue(r.value);\n      }\n    }\n    controller.close();\n  }\n}\n\nclass UnderlyingAsyncIterableByteSource<TSource extends ArrayBufferView = Uint8Array>\n  extends AbstractUnderlyingSource<TSource>\n  implements UnderlyingByteSource {\n  public readonly type: 'bytes';\n  public readonly autoAllocateChunkSize?: number;\n\n  // If we can't create a \"byob\" reader (no browsers currently suppor it),\n  // fallback to pulling values from the source iterator and enqueueing like\n  // object streams\n  private fallbackDefaultSource: UnderlyingAsyncIterableDefaultSource<TSource>;\n\n  constructor(\n    reader: AsyncIterator<TSource> | null,\n    opts: { autoAllocateChunkSize?: number } = {}\n  ) {\n    super(reader);\n    this.type = 'bytes';\n    this.autoAllocateChunkSize = opts.autoAllocateChunkSize;\n    this.fallbackDefaultSource = new UnderlyingAsyncIterableDefaultSource<TSource>(reader);\n  }\n  async pull(controller: ReadableByteStreamController) {\n    if (!controller.byobRequest) {\n      return await this.fallbackDefaultSource.pull(controller);\n    }\n    if (this._source) {\n      const { view } = controller.byobRequest;\n      const { done, value } = await this._source.next(view);\n      if (!done) {\n        // Did the source write into the BYOB view itself,\n        // then yield us the `bytesWritten` value? If so,\n        // pass that along\n        if (typeof value === 'number') {\n          return controller.byobRequest.respond(value);\n        }\n        // otherwise if the source is only producing buffers\n        // but doesn't expect to be given one, we should copy\n        // the produced buffer into the front of the BYOB view\n        if (ArrayBuffer.isView(value)) {\n          return value.buffer === view.buffer\n            ? controller.byobRequest.respondWithNewView(value)\n            : controller.byobRequest.respond(memcpy(view, value));\n        }\n      }\n    }\n    controller.close();\n  }\n}\n\n// Generate subclasses of ReadableStream that conform to the\n// AsyncIterable protocol. These classes are dynamically created\n// the first time a ReadableStream is produced because ReadableStream\n// is a browser-only API, and closure-compiler won't compile if they're\n// statically defined at the module scope.\n/** @ignore */\nconst asyncIterableReadableStream = (() => {\n  let AsyncIterableReadableByteStream_: any;\n  let AsyncIterableDefaultReadableStream_: any;\n\n  // A function that's called the first time someone creates a\n  // ReadableStream via `toDOMStream()`\n  let createFirstTime = <T>(source: any, opts?: any) => {\n    // Generate the subclasses with [Symbol.asyncIterator]() methods\n    class AsyncIterableDefaultReadableStream extends ReadableStream<T> {\n      [Symbol.asyncIterator]() {\n        return fromDOMStream(this)[Symbol.asyncIterator]();\n      }\n    }\n    class AsyncIterableReadableByteStream extends ReadableStream<Uint8Array> {\n      [Symbol.asyncIterator]() {\n        return fromDOMStream(this, { mode: 'byob' })[Symbol.asyncIterator]();\n      }\n    }\n    AsyncIterableReadableByteStream_ = AsyncIterableReadableByteStream;\n    AsyncIterableDefaultReadableStream_ = AsyncIterableDefaultReadableStream;\n    // Now point `createAsyncIterableReadableStream` to the function that\n    // instantiates the classes we just created\n    //tslint:disable-next-line\n    createAsyncIterableReadableStream = createAsyncIterableReadableStreamEveryOtherTime;\n    // Create and return the first ReadableStream<T> instance\n    //tslint:disable-next-line\n    return createAsyncIterableReadableStreamEveryOtherTime<T>(source, opts) as ReadableStream<T>;\n  };\n\n  // Shared function pointer that's called by the wrapper closure we return\n  //tslint:disable-next-line\n  let createAsyncIterableReadableStream = createFirstTime;\n  // Create instances of the classes generated by `createFirstTime`\n  let createAsyncIterableReadableStreamEveryOtherTime = <T>(source: any, opts?: any) => {\n    return source instanceof UnderlyingAsyncIterableByteSource\n      ? (new AsyncIterableReadableByteStream_(source, opts) as ReadableStream<T>)\n      : (new AsyncIterableDefaultReadableStream_(source, opts) as ReadableStream<T>);\n  };\n\n  return <T>(source: any, opts?: any) => createAsyncIterableReadableStream<T>(source, opts);\n})();\n\nexport function toDOMStream<T>(\n  source: AsyncIterable<T>,\n  strategy?: QueuingStrategy<T>\n): ReadableStream<T>;\nexport function toDOMStream<T>(\n  source: AsyncIterable<T>,\n  options: ReadableBYOBStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStream<T>(\n  source: AsyncIterable<T>,\n  options: ReadableByteStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStream(\n  source: AsyncIterable<any>,\n  options?: QueuingStrategy<any> | ReadableBYOBStreamOptions | ReadableByteStreamOptions\n) {\n  if (!options || !('type' in options) || options['type'] !== 'bytes') {\n    return asyncIterableReadableStream(\n      new UnderlyingAsyncIterableDefaultSource(source[Symbol.asyncIterator]()),\n      options\n    );\n  }\n  return asyncIterableReadableStream(\n    new UnderlyingAsyncIterableByteSource(source[Symbol.asyncIterator]()),\n    options\n  );\n}\n","import { AsyncIterableX } from '../asynciterable/asynciterablex';\nimport {\n  toDOMStream as asyncIterableToDOMStream,\n  ReadableBYOBStreamOptions,\n  ReadableByteStreamOptions\n} from '../asynciterable/todomstream';\n\n// To work around circular-dependency hell, these need to be on\n// the AsyncIterable prototype for tee, pipeTo, and pipeThrough\nimport '../add/iterable-operators/publish';\nimport '../add/iterable-operators/todomstream';\n\nexport function toDOMStream<T>(\n  source: Iterable<T>,\n  strategy?: QueuingStrategy<T>\n): ReadableStream<T>;\nexport function toDOMStream<T>(\n  source: Iterable<T>,\n  options: ReadableBYOBStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStream<T>(\n  source: Iterable<T>,\n  options: ReadableByteStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStream(\n  source: Iterable<any>,\n  options?: QueuingStrategy<any> | ReadableBYOBStreamOptions | ReadableByteStreamOptions\n) {\n  if (!options || !('type' in options) || options['type'] !== 'bytes') {\n    return asyncIterableToDOMStream(AsyncIterableX.from(source), options);\n  }\n  return asyncIterableToDOMStream(AsyncIterableX.from(source), options);\n}\n","export function toMap<TSource, TKey>(\n  source: Iterable<TSource>,\n  keySelector: (item: TSource) => TKey\n): Map<TKey, TSource>;\nexport function toMap<TSource, TKey, TElement = TSource>(\n  source: Iterable<TSource>,\n  keySelector: (item: TSource) => TKey,\n  elementSelector?: (item: TSource) => TElement\n): Map<TKey, TElement>;\nexport function toMap<TSource, TKey, TElement = TSource>(\n  source: Iterable<TSource>,\n  keySelector: (item: TSource) => TKey,\n  elementSelector?: (item: TSource) => TElement\n): Map<TKey, TElement | TSource> {\n  let map = new Map<TKey, TElement | TSource>();\n  for (let item of source) {\n    let value = elementSelector ? elementSelector(item) : item;\n    map.set(keySelector(item), value);\n  }\n  return map;\n}\n","export function toSet<TSource>(source: Iterable<TSource>): Set<TSource> {\n  let set = new Set<TSource>();\n  for (let item of source) {\n    set.add(item);\n  }\n  return set;\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { publish } from '../../iterable/publish';\n\nexport function publishProto<TSource>(this: IterableX<TSource>): IterableX<TSource>;\nexport function publishProto<TSource, TResult>(\n  this: IterableX<TSource>,\n  selector?: (value: Iterable<TSource>) => Iterable<TResult>\n): IterableX<TResult>;\n/**\n * @ignore\n */\nexport function publishProto<TSource, TResult>(\n  this: IterableX<TSource>,\n  selector?: (value: Iterable<TSource>) => Iterable<TResult>\n): IterableX<TSource | TResult> {\n  return publish(this, selector);\n}\n\nIterableX.prototype.publish = publishProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    publish: typeof publishProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { toDOMStream } from '../../iterable/todomstream';\nimport {\n  ReadableBYOBStreamOptions,\n  ReadableByteStreamOptions\n} from '../../asynciterable/todomstream';\n\n/**\n * @ignore\n */\nexport function toDOMStreamProto<T>(\n  this: Iterable<T>,\n  strategy?: QueuingStrategy<T>\n): ReadableStream<T>;\nexport function toDOMStreamProto<T>(\n  this: Iterable<T>,\n  options: ReadableBYOBStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStreamProto<T>(\n  this: Iterable<T>,\n  options: ReadableByteStreamOptions<Uint8Array>\n): ReadableStream<Uint8Array>;\nexport function toDOMStreamProto(\n  this: Iterable<any>,\n  options?: QueuingStrategy<any> | ReadableBYOBStreamOptions | ReadableByteStreamOptions\n) {\n  return !options ? toDOMStream(this) : toDOMStream(this, options);\n}\n\nIterableX.prototype.toDOMStream = toDOMStreamProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    toDOMStream: typeof toDOMStreamProto;\n  }\n}\n","import { IterableX } from './iterablex';\nimport { arrayIndexOf } from '../internal/arrayindexof';\nimport { comparer as defaultComparer } from '../internal/comparer';\n\nexport class UnionIterable<TSource> extends IterableX<TSource> {\n  private _left: Iterable<TSource>;\n  private _right: Iterable<TSource>;\n  private _comparer: (x: TSource, y: TSource) => boolean;\n\n  constructor(\n    left: Iterable<TSource>,\n    right: Iterable<TSource>,\n    comparer: (x: TSource, y: TSource) => boolean\n  ) {\n    super();\n    this._left = left;\n    this._right = right;\n    this._comparer = comparer;\n  }\n\n  *[Symbol.iterator]() {\n    let map = [] as TSource[];\n    for (let lItem of this._left) {\n      if (arrayIndexOf(map, lItem, this._comparer) === -1) {\n        map.push(lItem);\n        yield lItem;\n      }\n    }\n\n    for (let rItem of this._right) {\n      if (arrayIndexOf(map, rItem, this._comparer) === -1) {\n        map.push(rItem);\n        yield rItem;\n      }\n    }\n  }\n}\n\nexport function union<TSource>(\n  left: Iterable<TSource>,\n  right: Iterable<TSource>,\n  comparer: (x: TSource, y: TSource) => boolean = defaultComparer\n): IterableX<TSource> {\n  return new UnionIterable<TSource>(left, right, comparer);\n}\n","import { IterableX } from './iterablex';\nimport { identity } from '../internal/identity';\nimport { returnIterator } from '../internal/returniterator';\n\nexport class ZipIterable<TSource, TResult> extends IterableX<TResult> {\n  private _sources: Iterable<TSource>[];\n  private _fn: (values: any[]) => TResult;\n\n  constructor(sources: Iterable<TSource>[], fn: (values: any[]) => TResult) {\n    super();\n    this._sources = sources;\n    this._fn = fn;\n  }\n  *[Symbol.iterator](): IterableIterator<TResult> {\n    const fn = this._fn;\n    const sourcesLength = this._sources.length;\n    const its = this._sources.map(x => x[Symbol.iterator]());\n    while (sourcesLength > 0) {\n      const values = new Array(sourcesLength);\n      for (let index = -1; ++index < sourcesLength; ) {\n        const result = its[index].next();\n        if (result.done) {\n          its.forEach(returnIterator);\n          return undefined;\n        }\n        values[index] = result.value;\n      }\n      yield fn(values);\n    }\n  }\n}\n\nexport function zip<T, T2>(source: Iterable<T>, source2: Iterable<T2>): IterableX<[T, T2]>;\nexport function zip<T, T2, T3>(\n  source: Iterable<T>,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>\n): IterableX<[T, T2, T3]>;\nexport function zip<T, T2, T3, T4>(\n  source: Iterable<T>,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>\n): IterableX<[T, T2, T3, T4]>;\nexport function zip<T, T2, T3, T4, T5>(\n  source: Iterable<T>,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>,\n  source5: Iterable<T5>\n): IterableX<[T, T2, T3, T4, T5]>;\nexport function zip<T, T2, T3, T4, T5, T6>(\n  source: Iterable<T>,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>,\n  source5: Iterable<T5>,\n  source6: Iterable<T6>\n): IterableX<[T, T2, T3, T4, T5, T6]>;\n\nexport function zip<T, R>(project: (values: [T]) => R, source: Iterable<T>): IterableX<R>;\nexport function zip<T, T2, R>(\n  project: (values: [T, T2]) => R,\n  source: Iterable<T>,\n  source2: Iterable<T2>\n): IterableX<R>;\nexport function zip<T, T2, T3, R>(\n  project: (values: [T, T2, T3]) => R,\n  source: Iterable<T>,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>\n): IterableX<R>;\nexport function zip<T, T2, T3, T4, R>(\n  project: (values: [T, T2, T3, T4]) => R,\n  source: Iterable<T>,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>\n): IterableX<R>;\nexport function zip<T, T2, T3, T4, T5, R>(\n  project: (values: [T, T2, T3, T4, T5]) => R,\n  source: Iterable<T>,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>,\n  source5: Iterable<T5>\n): IterableX<R>;\nexport function zip<T, T2, T3, T4, T5, T6, R>(\n  project: (values: [T, T2, T3, T4, T5, T6]) => R,\n  source: Iterable<T>,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>,\n  source5: Iterable<T5>,\n  source6: Iterable<T6>\n): IterableX<R>;\n\nexport function zip<T>(...sources: Iterable<T>[]): IterableX<T[]>;\nexport function zip<T, R>(project: (values: T[]) => R, ...sources: Iterable<T>[]): IterableX<R>;\n/* tslint:enable:max-line-length */\nexport function zip<T, R>(...sources: any[]): IterableX<R> {\n  let fn = (sources.shift() || identity) as (values: any[]) => R;\n  if (fn && typeof fn !== 'function') {\n    sources.unshift(fn);\n    fn = identity;\n  }\n  return new ZipIterable<T, R>(sources as Iterable<T>[], fn);\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { BufferIterable } from '../buffer';\n\nexport function buffer<TSource>(\n  count: number,\n  skip?: number\n): OperatorFunction<TSource, TSource[]> {\n  if (skip == null) {\n    skip = count;\n  }\n  return function bufferOperatorFunction(source: Iterable<TSource>): IterableX<TSource[]> {\n    return new BufferIterable(source, count, skip!);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { CatchIterable } from '../catch';\n\nexport function _catch<T>(...args: Iterable<T>[]): MonoTypeOperatorFunction<T> {\n  return function catchOperatorFunction(source: Iterable<T>): IterableX<T> {\n    return new CatchIterable<T>([source, ...args]);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { CatchWithIterable } from '../catchwith';\n\nexport function catchWith<TSource>(\n  handler: (error: any) => Iterable<TSource>\n): MonoTypeOperatorFunction<TSource> {\n  return function catchWithOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new CatchWithIterable<TSource>(source, handler);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { ConcatIterable } from '../concat';\n\n/* tslint:disable:max-line-length */\nexport function concat<T, T2>(v2: Iterable<T2>): MonoTypeOperatorFunction<T | T2>;\nexport function concat<T, T2, T3>(\n  v2: Iterable<T2>,\n  v3: Iterable<T3>\n): MonoTypeOperatorFunction<T | T2 | T3>;\nexport function concat<T, T2, T3, T4>(\n  v2: Iterable<T2>,\n  v3: Iterable<T3>,\n  v4: Iterable<T4>\n): MonoTypeOperatorFunction<T | T2 | T3 | T4>;\nexport function concat<T, T2, T3, T4, T5>(\n  v2: Iterable<T2>,\n  v3: Iterable<T3>,\n  v4: Iterable<T4>,\n  v5: Iterable<T5>\n): MonoTypeOperatorFunction<T | T2 | T3 | T4 | T5>;\nexport function concat<T, T2, T3, T4, T5, T6>(\n  v2: Iterable<T2>,\n  v3: Iterable<T3>,\n  v4: Iterable<T4>,\n  v5: Iterable<T5>,\n  v6: Iterable<T6>\n): MonoTypeOperatorFunction<T | T2 | T3 | T4 | T5 | T6>;\n/* tslint:enable:max-line-length */\n\nexport function concat<T>(...args: Iterable<T>[]): MonoTypeOperatorFunction<T> {\n  return function concatOperatorFunction(source: Iterable<T>): IterableX<T> {\n    return new ConcatIterable<T>([source, ...args]);\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { ConcatIterable } from '../concat';\n\nexport function concatAll<T>(): OperatorFunction<Iterable<T>, T> {\n  return function concatAllOperatorFunction(source: Iterable<Iterable<T>>): IterableX<T> {\n    return new ConcatIterable<T>(source);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { DefaultIfEmptyIterable } from '../defaultifempty';\n\nexport function defaultIfEmpty<T>(defaultValue: T): MonoTypeOperatorFunction<T> {\n  return function defaultIfEmptyOperatorFunction(source: Iterable<T>): IterableX<T> {\n    return new DefaultIfEmptyIterable<T>(source, defaultValue);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { DistinctIterable } from '../distinct';\nimport { identity } from '../../internal/identity';\nimport { comparer as defaultComparer } from '../../internal/comparer';\n\nexport function distinct<TSource, TKey>(\n  keySelector: (value: TSource) => TKey = identity,\n  comparer: (x: TKey, y: TKey) => boolean = defaultComparer\n): MonoTypeOperatorFunction<TSource> {\n  return function distinctOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new DistinctIterable<TSource, TKey>(source, keySelector, comparer);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { DistinctUntilChangedIterable } from '../distinctuntilchanged';\nimport { identity } from '../../internal/identity';\nimport { comparer as defaultComparer } from '../../internal/comparer';\n\nexport function distinctUntilChanged<TSource, TKey>(\n  keySelector: (value: TSource) => TKey = identity,\n  comparer: (first: TKey, second: TKey) => boolean = defaultComparer\n): MonoTypeOperatorFunction<TSource> {\n  return function distinctUntilChangedOperatorFunction(\n    source: Iterable<TSource>\n  ): IterableX<TSource> {\n    return new DistinctUntilChangedIterable<TSource, TKey>(source, keySelector, comparer);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { concatStatic } from '../concat';\nimport { _while } from '../while';\n\nexport function doWhile<TSource>(condition: () => boolean): MonoTypeOperatorFunction<TSource> {\n  return function doWhileOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return concatStatic(source, _while(condition, source));\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { EndWithIterable } from '../endwith';\n\nexport function endWith<TSource>(...args: TSource[]): MonoTypeOperatorFunction<TSource> {\n  return function endsWithOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new EndWithIterable<TSource>(source, args);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { ExceptIterable } from '../except';\nimport { comparer as defaultComparer } from '../../internal/comparer';\n\nexport function except<TSource>(\n  second: Iterable<TSource>,\n  comparer: (x: TSource, y: TSource) => boolean = defaultComparer\n): MonoTypeOperatorFunction<TSource> {\n  return function exceptOperatorFunction(first: Iterable<TSource>): IterableX<TSource> {\n    return new ExceptIterable<TSource>(first, second, comparer);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { ExpandIterable } from '../expand';\n\nexport function expand<TSource>(\n  selector: (value: TSource) => Iterable<TSource>\n): MonoTypeOperatorFunction<TSource> {\n  return function expandOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new ExpandIterable<TSource>(source, selector);\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { FilterIterable } from '../filter';\nimport { bindCallback } from '../../internal/bindcallback';\n\nexport function filter<T, S extends T>(\n  predicate: (value: T, index: number) => value is S,\n  thisArg?: any\n): OperatorFunction<T, S>;\nexport function filter<T>(\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): OperatorFunction<T, T>;\nexport function filter<TSource>(\n  predicate: (value: TSource, index: number) => boolean,\n  thisArg?: any\n): OperatorFunction<TSource, TSource> {\n  return function filterOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new FilterIterable<TSource>(source, bindCallback(predicate, thisArg, 2));\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { FinallyIterable } from '../finally';\n\nexport function _finally<TSource>(action: () => void): MonoTypeOperatorFunction<TSource> {\n  return function finallyOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new FinallyIterable<TSource>(source, action);\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { FlatMapIterable } from '../flatmap';\nimport { bindCallback } from '../../internal/bindcallback';\n\nexport function flatMap<TSource, TResult>(\n  selector: (value: TSource) => Iterable<TResult>,\n  thisArg?: any\n): OperatorFunction<TSource, TResult> {\n  return function flatMapOperatorFunction(source: Iterable<TSource>): IterableX<TResult> {\n    return new FlatMapIterable<TSource, TResult>(source, bindCallback(selector, thisArg, 1));\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { FlattenIterable } from '../flatten';\n\nexport function flatten<T>(depth: number = Infinity): MonoTypeOperatorFunction<T> {\n  return function flattenOperatorFunction(source: Iterable<T>): IterableX<T> {\n    return new FlattenIterable<T>(source, depth);\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { GroupByIterable, GroupedIterable, groupByResultIdentity } from '../groupby';\nimport { identity } from '../../internal/identity';\n\nexport function groupBy<TSource, TKey>(\n  keySelector: (value: TSource) => TKey\n): OperatorFunction<TSource, GroupedIterable<TKey, TSource>>;\nexport function groupBy<TSource, TKey, TValue>(\n  keySelector: (value: TSource) => TKey,\n  elementSelector?: (value: TSource) => TValue\n): OperatorFunction<TSource, GroupedIterable<TKey, TValue>>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  keySelector: (value: TSource) => TKey,\n  elementSelector?: (value: TSource) => TValue,\n  resultSelector?: (key: TKey, values: Iterable<TValue>) => TResult\n): OperatorFunction<TSource, TResult>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  keySelector: (value: TSource) => TKey,\n  elementSelector: (value: TSource) => TValue = identity,\n  resultSelector: (key: TKey, values: Iterable<TValue>) => TResult = groupByResultIdentity\n): OperatorFunction<TSource, TResult> {\n  return function groupByOperatorFunction(source: Iterable<TSource>): IterableX<TResult> {\n    return new GroupByIterable<TSource, TKey, TValue, TResult>(\n      source,\n      keySelector,\n      elementSelector,\n      resultSelector\n    );\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { GroupJoinIterable } from '../groupjoin';\n\nexport function groupJoin<TOuter, TInner, TKey, TResult>(\n  inner: Iterable<TInner>,\n  outerSelector: (value: TOuter) => TKey,\n  innerSelector: (value: TInner) => TKey,\n  resultSelector: (outer: TOuter, inner: Iterable<TInner>) => TResult\n): OperatorFunction<TOuter, TResult> {\n  return function groupJoinOperatorFunction(outer: Iterable<TOuter>): IterableX<TResult> {\n    return new GroupJoinIterable<TOuter, TInner, TKey, TResult>(\n      outer,\n      inner,\n      outerSelector,\n      innerSelector,\n      resultSelector\n    );\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { IgnoreElementsIterable } from '../ignoreelements';\n\nexport function ignoreElements<TSource>(): MonoTypeOperatorFunction<TSource> {\n  return function ignoreElementsOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new IgnoreElementsIterable<TSource>(source);\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { JoinIterable } from '../innerjoin';\n\nexport function innerJoin<TOuter, TInner, TKey, TResult>(\n  inner: Iterable<TInner>,\n  outerSelector: (value: TOuter) => TKey,\n  innerSelector: (value: TInner) => TKey,\n  resultSelector: (outer: TOuter, inner: TInner) => TResult\n): OperatorFunction<TOuter, TResult> {\n  return function innerJoinOperatorFunction(outer: Iterable<TOuter>): IterableX<TResult> {\n    return new JoinIterable<TOuter, TInner, TKey, TResult>(\n      outer,\n      inner,\n      outerSelector,\n      innerSelector,\n      resultSelector\n    );\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { IntersectIterable } from '../intersect';\nimport { comparer as defaultComparer } from '../../internal/comparer';\n\nexport function intersect<TSource>(\n  second: Iterable<TSource>,\n  comparer: (x: TSource, y: TSource) => boolean = defaultComparer\n): MonoTypeOperatorFunction<TSource> {\n  return function intersectOperatorFunction(first: Iterable<TSource>): IterableX<TSource> {\n    return new IntersectIterable<TSource>(first, second, comparer);\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { MapIterable } from '../map';\nimport { bindCallback } from '../../internal/bindcallback';\n\nexport function map<TSource, TResult>(\n  selector: (value: TSource, index: number) => TResult,\n  thisArg?: any\n): OperatorFunction<TSource, TResult> {\n  return function mapOperatorFunction(source: Iterable<TSource>): IterableX<TResult> {\n    return new MapIterable<TSource, TResult>(source, bindCallback(selector, thisArg, 2));\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { extremaBy, defaultCompare } from '../_extremaby';\n\nexport function maxBy<TSource, TKey>(\n  keySelector: (x: TSource) => TKey,\n  comparer: (x: TKey, y: TKey) => number = defaultCompare\n): MonoTypeOperatorFunction<TSource> {\n  return function maxByOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return extremaBy(source, keySelector, comparer);\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { memoize as memoizeStatic } from '../memoize';\n\nexport function memoize<TSource>(readerCount?: number): OperatorFunction<TSource, TSource>;\nexport function memoize<TSource, TResult>(\n  readerCount?: number,\n  selector?: (value: Iterable<TSource>) => Iterable<TResult>\n): OperatorFunction<TSource, TResult>;\nexport function memoize<TSource, TResult = TSource>(\n  readerCount: number = -1,\n  selector?: (value: Iterable<TSource>) => Iterable<TResult>\n): OperatorFunction<TSource, TSource | TResult> {\n  return function memoizeOperatorFunction(source: Iterable<TSource>): IterableX<TSource | TResult> {\n    return memoizeStatic(source, readerCount, selector);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { extremaBy, defaultCompare } from '../_extremaby';\n\nexport function minBy<TSource, TKey>(\n  keySelector: (x: TSource) => TKey,\n  comparer: (x: TKey, y: TKey) => number = defaultCompare\n): MonoTypeOperatorFunction<TSource> {\n  return function minByOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return extremaBy(source, keySelector, (key, minValue) => -comparer(key, minValue));\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { OnErrorResumeNextIterable } from '../onerrorresumenext';\n\nexport function onErrorResumeNext<T>(...args: Iterable<T>[]): MonoTypeOperatorFunction<T> {\n  return function onErrorResumeNextOperatorFunction(source: Iterable<T>): IterableX<T> {\n    return new OnErrorResumeNextIterable<T>([source, ...args]);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { OrderedIterableX, OrderedIterableBaseX } from '../orderby';\nimport { sorter as defaultSorter } from '../../internal/sorter';\n\nexport function orderBy<TKey, TSource>(\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): MonoTypeOperatorFunction<TSource> {\n  return function orderByOperatorFunction(source: Iterable<TSource>) {\n    return new OrderedIterableX<TKey, TSource>(source, keySelector, comparer, false);\n  };\n}\n\nexport function orderByDescending<TKey, TSource>(\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): MonoTypeOperatorFunction<TSource> {\n  return function orderByDescendingOperatorFunction(source: Iterable<TSource>) {\n    return new OrderedIterableX<TKey, TSource>(source, keySelector, comparer, true);\n  };\n}\n\nexport function thenBy<TKey, TSource>(\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): MonoTypeOperatorFunction<TSource> {\n  return function thenByOperatorFunction(source: Iterable<TSource>) {\n    const orderSource = <OrderedIterableBaseX<TSource>>source;\n    return new OrderedIterableX<TKey, TSource>(\n      orderSource._source,\n      keySelector,\n      comparer,\n      false,\n      orderSource\n    );\n  };\n}\n\nexport function thenByDescending<TKey, TSource>(\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): MonoTypeOperatorFunction<TSource> {\n  return function thenByDescendingOperatorFunction(source: Iterable<TSource>) {\n    const orderSource = <OrderedIterableBaseX<TSource>>source;\n    return new OrderedIterableX<TKey, TSource>(\n      orderSource._source,\n      keySelector,\n      comparer,\n      true,\n      orderSource\n    );\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { PairwiseIterable } from '../pairwise';\n\nexport function pairwise<TSource>(): OperatorFunction<TSource, TSource[]> {\n  return function pairwiseOperatorFunction(source: Iterable<TSource>): IterableX<TSource[]> {\n    return new PairwiseIterable<TSource>(source);\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { pluck as pluckStatic } from '../pluck';\n\nexport function pluck<TSource, TResult>(...args: string[]): OperatorFunction<TSource, TResult> {\n  return function pluckOperatorFunction(source: Iterable<TSource>): IterableX<TResult> {\n    return pluckStatic(source, ...args);\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { publish as publishStatic } from '../publish';\n\nexport function publish<TSource>(): OperatorFunction<TSource, TSource>;\nexport function publish<TSource, TResult>(\n  selector?: (value: Iterable<TSource>) => Iterable<TResult>\n): OperatorFunction<TSource, TResult>;\nexport function publish<TSource, TResult>(\n  selector?: (value: Iterable<TSource>) => Iterable<TResult>\n): OperatorFunction<TSource, TSource | TResult> {\n  return function publishOperatorFunction(source: Iterable<TSource>): IterableX<TSource | TResult> {\n    return publishStatic(source, selector);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { RepeatIterable } from '../repeat';\n\nexport function repeat<TSource>(count: number = -1): MonoTypeOperatorFunction<TSource> {\n  return function repeatOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new RepeatIterable<TSource>(source, count);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { retry as retryStatic } from '../retry';\n\nexport function retry<TSource>(count: number = -1): MonoTypeOperatorFunction<TSource> {\n  return function retryOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return retryStatic<TSource>(source, count);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { ReverseIterable } from '../reverse';\n\nexport function reverse<TSource>(): MonoTypeOperatorFunction<TSource> {\n  return function reverseOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new ReverseIterable<TSource>(source);\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { ScanIterable } from '../scan';\n\nexport function scan<T, R = T>(\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: never[]\n): OperatorFunction<T, R>;\nexport function scan<T, R = T>(\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: R\n): OperatorFunction<T, R>;\nexport function scan<T, R = T>(\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  ...seed: R[]\n): OperatorFunction<T, R> {\n  return function scanOperatorFunction(source: Iterable<T>): IterableX<R> {\n    return new ScanIterable(source, accumulator, seed);\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { ScanRightIterable } from '../scanright';\n\nexport function scanRight<T, R = T>(\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: never[]\n): OperatorFunction<T, R>;\nexport function scanRight<T, R = T>(\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: R\n): OperatorFunction<T, R>;\nexport function scanRight<T, R = T>(\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  ...seed: R[]\n): OperatorFunction<T, R> {\n  return function scanRightOperatorFunction(source: Iterable<T>): IterableX<R> {\n    return new ScanRightIterable(source, accumulator, seed);\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { share as shareStatic } from '../share';\n\nexport function share<TSource>(): OperatorFunction<TSource, TSource>;\nexport function share<TSource, TResult>(\n  selector?: (value: Iterable<TSource>) => Iterable<TResult>\n): OperatorFunction<TSource, TResult>;\nexport function share<TSource, TResult = TSource>(\n  selector?: (value: Iterable<TSource>) => Iterable<TResult>\n): OperatorFunction<TSource, TSource | TResult> {\n  return function shareOperatorFunction(source: Iterable<TSource>): IterableX<TSource | TResult> {\n    return shareStatic<TSource, TResult>(source, selector);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { SkipIterable } from '../skip';\n\nexport function skip<TSource>(count: number): MonoTypeOperatorFunction<TSource> {\n  return function skipOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new SkipIterable<TSource>(source, count);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { SkipLastIterable } from '../skiplast';\n\nexport function skipLast<TSource>(count: number): MonoTypeOperatorFunction<TSource> {\n  return function skipLastOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new SkipLastIterable<TSource>(source, count);\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { SkipWhileIterable } from '../skipwhile';\n\nexport function skipWhile<T, S extends T>(\n  predicate: (value: T, index: number) => value is S\n): OperatorFunction<T, S>;\nexport function skipWhile<T>(\n  predicate: (value: T, index: number) => boolean\n): OperatorFunction<T, T>;\nexport function skipWhile<T>(\n  predicate: (value: T, index: number) => boolean\n): OperatorFunction<T, T> {\n  return function skipWhileOperatorFunction(source: Iterable<T>): IterableX<T> {\n    return new SkipWhileIterable<T>(source, predicate);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { SliceIterable } from '../slice';\n\nexport function slice<TSource>(\n  begin: number,\n  end: number = Infinity\n): MonoTypeOperatorFunction<TSource> {\n  return function sliceOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new SliceIterable<TSource>(source, begin, end);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { StartWithIterable } from '../startwith';\n\nexport function startWith<TSource>(...args: TSource[]): MonoTypeOperatorFunction<TSource> {\n  return function startWithOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new StartWithIterable<TSource>(source, args);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { TakeIterable } from '../take';\n\nexport function take<TSource>(count: number): MonoTypeOperatorFunction<TSource> {\n  return function takeOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new TakeIterable<TSource>(source, count);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { TakeLastIterable } from '../takelast';\n\nexport function takeLast<TSource>(count: number): MonoTypeOperatorFunction<TSource> {\n  return function takeLastOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new TakeLastIterable<TSource>(source, count);\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { TakeWhileIterable } from '../takewhile';\n\nexport function takeWhile<T, S extends T>(\n  predicate: (value: T, index: number) => value is S\n): OperatorFunction<T, S>;\nexport function takeWhile<T>(\n  predicate: (value: T, index: number) => boolean\n): OperatorFunction<T, T>;\nexport function takeWhile<T>(\n  predicate: (value: T, index: number) => boolean\n): OperatorFunction<T, T> {\n  return function takeWhileOperatorFunction(source: Iterable<T>): IterableX<T> {\n    return new TakeWhileIterable<T>(source, predicate);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { TapIterable } from '../tap';\nimport { PartialObserver } from '../../observer';\n\nexport function tap<TSource>(\n  observer: PartialObserver<TSource>\n): MonoTypeOperatorFunction<TSource> {\n  return function tapOperatorFunction(source: Iterable<TSource>): IterableX<TSource> {\n    return new TapIterable<TSource>(source, observer);\n  };\n}\n","import { toDOMStream as toDOMStreamOperator } from '../../iterable/todomstream';\nimport {\n  ReadableBYOBStreamOptions,\n  ReadableByteStreamOptions\n} from '../../asynciterable/todomstream';\n\nimport { UnaryFunction } from '../../interfaces';\n\nexport function toDOMStream<T>(\n  strategy?: QueuingStrategy<T>\n): UnaryFunction<Iterable<T>, ReadableStream<T>>;\nexport function toDOMStream<T>(\n  options: ReadableBYOBStreamOptions<Uint8Array>\n): UnaryFunction<Iterable<T>, ReadableStream<Uint8Array>>;\nexport function toDOMStream<T>(\n  options: ReadableByteStreamOptions<Uint8Array>\n): UnaryFunction<Iterable<T>, ReadableStream<Uint8Array>>;\nexport function toDOMStream(\n  options?: QueuingStrategy<any> | ReadableBYOBStreamOptions | ReadableByteStreamOptions\n) {\n  return function toDOMStreamOperatorFunction(source: Iterable<any>) {\n    if (!options || !('type' in options) || options['type'] !== 'bytes') {\n      return toDOMStreamOperator(source, options as QueuingStrategy<any> | undefined);\n    }\n    return toDOMStreamOperator(source, options as\n      | ReadableBYOBStreamOptions\n      | ReadableByteStreamOptions);\n  };\n}\n","import { MonoTypeOperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { UnionIterable } from '../union';\nimport { comparer as defaultComparer } from '../../internal/comparer';\n\nexport function union<TSource>(\n  right: Iterable<TSource>,\n  comparer: (x: TSource, y: TSource) => boolean = defaultComparer\n): MonoTypeOperatorFunction<TSource> {\n  return function unionOperatorFunction(left: Iterable<TSource>): IterableX<TSource> {\n    return new UnionIterable<TSource>(left, right, comparer);\n  };\n}\n","import { OperatorFunction } from '../../interfaces';\nimport { IterableX } from '../../iterable/iterablex';\nimport { ZipIterable } from '../zip';\nimport { identity } from '../../internal/identity';\n\nexport function zip<T, T2>(\n  source: Iterable<T>,\n  source2: Iterable<T2>\n): OperatorFunction<T, [T, T2]>;\nexport function zip<T, T2, T3>(\n  source2: Iterable<T2>,\n  source3: Iterable<T3>\n): OperatorFunction<T, [T, T2, T3]>;\nexport function zip<T, T2, T3, T4>(\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>\n): OperatorFunction<T, [T, T2, T3, T4]>;\nexport function zip<T, T2, T3, T4, T5>(\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>,\n  source5: Iterable<T5>\n): OperatorFunction<T, [T, T2, T3, T4, T5]>;\nexport function zip<T, T2, T3, T4, T5, T6>(\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>,\n  source5: Iterable<T5>,\n  source6: Iterable<T6>\n): OperatorFunction<T, [T, T2, T3, T4, T5, T6]>;\n\nexport function zip<T, T2, R>(\n  project: (values: [T, T2]) => R,\n  source2: Iterable<T2>\n): OperatorFunction<T, R>;\nexport function zip<T, T2, T3, R>(\n  project: (values: [T, T2, T3]) => R,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>\n): OperatorFunction<T, R>;\nexport function zip<T, T2, T3, T4, R>(\n  project: (values: [T, T2, T3, T4]) => R,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>\n): OperatorFunction<T, R>;\nexport function zip<T, T2, T3, T4, T5, R>(\n  project: (values: [T, T2, T3, T4, T5]) => R,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>,\n  source5: Iterable<T5>\n): OperatorFunction<T, R>;\nexport function zip<T, T2, T3, T4, T5, T6, R>(\n  project: (values: [T, T2, T3, T4, T5, T6]) => R,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>,\n  source5: Iterable<T5>,\n  source6: Iterable<T6>\n): OperatorFunction<T, R>;\n\nexport function zip<T>(...sources: Iterable<T>[]): OperatorFunction<T, T[]>;\nexport function zip<T, R>(\n  project: (values: T[]) => R,\n  ...sources: Iterable<T>[]\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\nexport function zip<T, R>(...sources: any[]): OperatorFunction<T, R> {\n  return function zipOperatorFunction(source: Iterable<T>): IterableX<R> {\n    let fn = (sources.shift() || identity) as (values: any[]) => R;\n    if (fn && typeof fn !== 'function') {\n      sources.unshift(fn);\n      fn = identity;\n    }\n    return new ZipIterable<T, R>([source, ...sources] as Iterable<T>[], fn);\n  };\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { AsyncSink } from '../asyncsink';\nimport { memoize } from './memoize';\n\nexport function asyncify<TSource>(func: Function): (...args: any[]) => AsyncIterableX<TSource> {\n  return function(...args: any[]) {\n    const sink = new AsyncSink<TSource>();\n\n    const handler = function(...innerArgs: any[]) {\n      sink.write(innerArgs.length === 1 ? innerArgs[0] : innerArgs);\n      sink.end();\n    };\n\n    try {\n      func(...args.concat(handler));\n    } catch (e) {\n      sink.error(e);\n      sink.end();\n    }\n\n    return memoize(\n      (async function*() {\n        for (let next; !(next = await sink.next()).done; ) {\n          yield next.value;\n        }\n      })()\n    );\n  };\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { AsyncSink } from '../asyncsink';\nimport { memoize } from './memoize';\n\nexport function asyncifyErrback<TSource>(\n  func: Function\n): (...args: any[]) => AsyncIterableX<TSource> {\n  return function(...args: any[]) {\n    const sink = new AsyncSink<TSource>();\n\n    const handler = function(err: any, ...innerArgs: any[]) {\n      if (err) {\n        sink.error(err);\n        sink.end();\n      } else {\n        sink.write(innerArgs.length === 1 ? innerArgs[0] : innerArgs);\n        sink.end();\n      }\n    };\n\n    try {\n      func(...args.concat(handler));\n    } catch (e) {\n      sink.error(e);\n      sink.end();\n    }\n\n    return memoize(\n      (async function*() {\n        for (let next; !(next = await sink.next()).done; ) {\n          yield next.value;\n        }\n      })()\n    );\n  };\n}\n","import { identityAsync } from '../internal/identity';\n\nexport async function average(\n  source: Iterable<number | PromiseLike<number>> | AsyncIterable<number>,\n  selector?: (x: number) => number | Promise<number>\n): Promise<number>;\nexport async function average<TSource>(\n  source: Iterable<TSource | PromiseLike<TSource>> | AsyncIterable<TSource>,\n  selector?: (x: TSource) => number | Promise<number>\n): Promise<number>;\nexport async function average(\n  source: Iterable<number | PromiseLike<number>> | AsyncIterable<any>,\n  selector: (x: any) => number | Promise<number> = identityAsync\n): Promise<number> {\n  let sum = 0;\n  let count = 0;\n  for await (let item of source) {\n    sum += await selector(item);\n    count++;\n  }\n\n  if (count === 0) {\n    throw new Error('Empty collection');\n  }\n\n  return sum / count;\n}\n","import { AsyncIterableX } from './asynciterablex';\n\ninterface AsyncResolver<T> {\n  resolve: (value?: T | PromiseLike<T> | undefined) => void;\n  reject: (reason?: any) => void;\n}\n\ninterface WaitingState<T> {\n  type: 'waiting';\n  resolver: AsyncResolver<IteratorResult<T[]>>;\n}\ninterface BatchingState<T> {\n  type: 'batching';\n  values: T[];\n}\n\ntype State<T> = WaitingState<T> | BatchingState<T>;\n\nfunction assertNever(value: never): never {\n  throw new Error(`Unhandled discriminated union member ${value}`);\n}\n\nclass BatchAsyncIterable<TSource> extends AsyncIterableX<TSource[]> {\n  private _source: AsyncIterable<TSource>;\n\n  constructor(source: AsyncIterable<TSource>) {\n    super();\n    this._source = source;\n  }\n\n  [Symbol.asyncIterator]() {\n    const it = this._source[Symbol.asyncIterator]();\n\n    let state: State<TSource> = { type: 'batching', values: [] };\n    let ended: null | Promise<IteratorResult<TSource[]>> = null;\n\n    function consumeNext() {\n      it.next().then(\n        res => {\n          if (res.done) {\n            ended = Promise.resolve({ done: true } as IteratorResult<TSource[]>);\n\n            if (state.type === 'waiting') {\n              state.resolver.resolve(ended);\n            }\n          } else {\n            if (state.type === 'waiting') {\n              const { resolve } = state.resolver;\n              state = { type: 'batching', values: [] };\n              resolve({ done: res.done, value: [res.value] });\n            } else if (state.type === 'batching') {\n              state.values.push(res.value);\n            } else {\n              assertNever(state);\n            }\n\n            consumeNext();\n          }\n        },\n        err => {\n          ended = Promise.reject(err);\n\n          if (state.type === 'waiting') {\n            const { reject } = state.resolver;\n            reject(err);\n          }\n        }\n      );\n    }\n\n    consumeNext();\n\n    return {\n      next() {\n        if (state.type === 'batching' && state.values.length > 0) {\n          const { values } = state;\n          state.values = [];\n          return Promise.resolve({ done: false, value: values });\n        }\n\n        if (ended) {\n          return ended;\n        }\n\n        if (state.type === 'waiting') {\n          throw new Error('Previous `next()` is still in progress');\n        }\n\n        return new Promise<IteratorResult<TSource[]>>((resolve, reject) => {\n          state = {\n            type: 'waiting',\n            resolver: { resolve, reject }\n          };\n        });\n      },\n\n      return(value: any) {\n        return it.return\n          ? it.return(value).then(() => ({ done: true } as IteratorResult<TSource[]>))\n          : Promise.resolve({ done: true } as IteratorResult<TSource[]>);\n      }\n    };\n  }\n}\n\n/**\n * Returns an async iterable sequence of batches that are collected from the source sequence between\n * subsequent `next()` calls.\n */\nexport function batch<TSource>(source: AsyncIterable<TSource>): AsyncIterableX<TSource[]> {\n  return new BatchAsyncIterable(source);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class BufferAsyncIterable<TSource> extends AsyncIterableX<TSource[]> {\n  private _source: AsyncIterable<TSource>;\n  private _count: number;\n  private _skip: number;\n\n  constructor(source: AsyncIterable<TSource>, count: number, skip: number) {\n    super();\n    this._source = source;\n    this._count = count;\n    this._skip = skip;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let buffers: TSource[][] = [],\n      i = 0;\n    for await (let item of this._source) {\n      if (i % this._skip === 0) {\n        buffers.push([]);\n      }\n\n      for (let buffer of buffers) {\n        buffer.push(item);\n      }\n\n      if (buffers.length > 0 && buffers[0].length === this._count) {\n        yield buffers.shift()!;\n      }\n\n      i++;\n    }\n\n    while (buffers.length > 0) {\n      yield buffers.shift()!;\n    }\n  }\n}\n\nexport function buffer<TSource>(\n  source: AsyncIterable<TSource>,\n  count: number,\n  skip?: number\n): AsyncIterableX<TSource[]> {\n  if (skip == null) {\n    skip = count;\n  }\n  return new BufferAsyncIterable<TSource>(source, count, skip);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nclass DeferAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _fn: () => AsyncIterable<TSource> | Promise<AsyncIterable<TSource>>;\n\n  constructor(fn: () => AsyncIterable<TSource> | Promise<AsyncIterable<TSource>>) {\n    super();\n    this._fn = fn;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let items = await this._fn();\n    for await (let item of items) {\n      yield item;\n    }\n  }\n}\n\nexport function defer<TSource>(\n  factory: () => AsyncIterable<TSource> | Promise<AsyncIterable<TSource>>\n): AsyncIterableX<TSource> {\n  return new DeferAsyncIterable<TSource>(factory);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nclass EmptyAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  async *[Symbol.asyncIterator](): AsyncIterator<TSource> {\n    // tslint:disable-next-line:no-empty\n  }\n}\n\nexport function empty<TSource>(): AsyncIterableX<TSource> {\n  return new EmptyAsyncIterable<TSource>();\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { defer } from './defer';\nimport { empty } from './empty';\n\nexport function _case<TSource, TResult>(\n  selector: () => TSource | Promise<TSource>,\n  sources: Map<TSource, AsyncIterable<TResult>>,\n  defaultSource: AsyncIterable<TResult> = empty<TResult>()\n): AsyncIterableX<TResult> {\n  return defer<TResult>(async () => {\n    const key = await selector();\n    return sources.has(key) ? sources.get(key)! : defaultSource;\n  });\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { returnAsyncIterator } from '../internal/returniterator';\n\nexport class CatchAllAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: Iterable<AsyncIterable<TSource>>;\n\n  constructor(source: Iterable<AsyncIterable<TSource>>) {\n    super();\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let error = null,\n      hasError = false;\n\n    for (let source of this._source) {\n      const it = source[Symbol.asyncIterator]();\n\n      error = null;\n      hasError = false;\n\n      while (1) {\n        let c = <TSource>{};\n\n        try {\n          const { done, value } = await it.next();\n          if (done) {\n            await returnAsyncIterator(it);\n            break;\n          }\n          c = value;\n        } catch (e) {\n          error = e;\n          hasError = true;\n          await returnAsyncIterator(it);\n          break;\n        }\n\n        yield c;\n      }\n\n      if (!hasError) {\n        break;\n      }\n    }\n\n    if (hasError) {\n      throw error;\n    }\n  }\n}\n\nexport function _catchAll<TSource>(\n  source: Iterable<AsyncIterable<TSource>>\n): AsyncIterableX<TSource> {\n  return new CatchAllAsyncIterable<TSource>(source);\n}\n\nexport function _catch<T>(\n  source: AsyncIterable<T>,\n  ...args: AsyncIterable<T>[]\n): AsyncIterableX<T> {\n  return _catchAll<T>([source, ...args]);\n}\n\nexport function _catchStatic<T>(...source: AsyncIterable<T>[]): AsyncIterableX<T> {\n  return _catchAll(source);\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { returnAsyncIterator } from '../internal/returniterator';\n\nexport class CatchWithAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _handler: (error: any) => AsyncIterable<TSource> | Promise<AsyncIterable<TSource>>;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    handler: (error: any) => AsyncIterable<TSource> | Promise<AsyncIterable<TSource>>\n  ) {\n    super();\n    this._source = source;\n    this._handler = handler;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let err: AsyncIterable<TSource> | undefined,\n      hasError = false,\n      it = this._source[Symbol.asyncIterator]();\n    while (1) {\n      let c = <IteratorResult<TSource>>{};\n\n      try {\n        c = await it.next();\n        if (c.done) {\n          await returnAsyncIterator(it);\n          break;\n        }\n      } catch (e) {\n        err = await this._handler(e);\n        hasError = true;\n        await returnAsyncIterator(it);\n        break;\n      }\n\n      yield c.value;\n    }\n\n    if (hasError) {\n      for await (let item of err!) {\n        yield item;\n      }\n    }\n  }\n}\n\nexport function catchWith<TSource>(\n  source: AsyncIterable<TSource>,\n  handler: (error: any) => AsyncIterable<TSource> | Promise<AsyncIterable<TSource>>\n): AsyncIterableX<TSource> {\n  return new CatchWithAsyncIterable<TSource>(source, handler);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nclass ChainAsyncIterable<TResult> extends AsyncIterableX<TResult> {\n  private _result: AsyncIterable<TResult>;\n\n  constructor(result: AsyncIterable<TResult>) {\n    super();\n    this._result = result;\n  }\n\n  [Symbol.asyncIterator]() {\n    return this._result[Symbol.asyncIterator]();\n  }\n}\n\n/**\n * Returns an async iterable sequence that is the result of invoking the selector on the source sequence,\n * without sharing subscriptions.  This operator allows for a fluent style of writing queries that use\n * the same sequence multiple times.\n * @param {AsyncIterable<TSource>} source Source sequence that will be shared in the selector function.\n * @param {function(source: AsyncIterable<TSource>): AsyncIterable<TResult>} selector Selector function which can use\n * the source sequence as many times as needed, without sharing subscriptions to the source sequence.\n * @returns An async iterable sequence that contains the elements of a sequence produced by multicasting the source\n * sequence within a selector function.\n */\nexport function chain<TSource, TResult>(\n  source: AsyncIterable<TSource>,\n  selector: (source: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): AsyncIterableX<TResult> {\n  return new ChainAsyncIterable<TResult>(selector(source));\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { identity, identityAsync } from '../internal/identity';\n\n// tslint:disable-next-line:no-empty\nconst NEVER_PROMISE = new Promise(() => {});\n\ntype MergeResult<T> = { value: T; index: number };\n\nfunction wrapPromiseWithIndex<T>(promise: Promise<T>, index: number) {\n  return promise.then(value => ({ value, index })) as Promise<MergeResult<T>>;\n}\n\nexport class CombineLatestAsyncIterable<TSource, TResult> extends AsyncIterableX<TResult> {\n  private _sources: AsyncIterable<TSource>[];\n  private _fn: (values: any[]) => TResult | Promise<TResult>;\n\n  constructor(\n    sources: AsyncIterable<TSource>[],\n    fn: (values: any[]) => TResult | Promise<TResult>\n  ) {\n    super();\n    this._sources = sources;\n    this._fn = fn;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    const fn = this._fn;\n    const length = this._sources.length;\n    const iterators = new Array<AsyncIterator<TSource>>(length);\n    const nexts = new Array<Promise<MergeResult<IteratorResult<TSource>>>>(length);\n    let hasValueAll = false;\n    const values = new Array<TSource>(length);\n    const hasValues = new Array<boolean>(length);\n    let active = length;\n\n    hasValues.fill(false);\n\n    for (let i = 0; i < length; i++) {\n      const iterator = this._sources[i][Symbol.asyncIterator]();\n      iterators[i] = iterator;\n      nexts[i] = wrapPromiseWithIndex(iterator.next(), i);\n    }\n\n    while (active > 0) {\n      const next = Promise.race(nexts);\n      const { value: next$, index } = await next;\n      if (next$.done) {\n        nexts[index] = <Promise<MergeResult<IteratorResult<TSource>>>>NEVER_PROMISE;\n        active--;\n      } else {\n        values[index] = next$.value;\n        hasValues[index] = true;\n\n        const iterator$ = iterators[index];\n        nexts[index] = wrapPromiseWithIndex(iterator$.next(), index);\n\n        if (hasValueAll || (hasValueAll = hasValues.every(identity))) {\n          yield await fn(values);\n        }\n      }\n    }\n  }\n}\n\nexport function combineLatest<T, T2>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>\n): AsyncIterableX<[T, T2]>;\nexport function combineLatest<T, T2, T3>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): AsyncIterableX<[T, T2, T3]>;\nexport function combineLatest<T, T2, T3, T4>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): AsyncIterableX<[T, T2, T3, T4]>;\nexport function combineLatest<T, T2, T3, T4, T5>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): AsyncIterableX<[T, T2, T3, T4, T5]>;\nexport function combineLatest<T, T2, T3, T4, T5, T6>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): AsyncIterableX<[T, T2, T3, T4, T5, T6]>;\n\nexport function combineLatest<T, R>(\n  project: (values: [T]) => R | Promise<R>,\n  source: AsyncIterable<T>\n): AsyncIterableX<R>;\nexport function combineLatest<T, T2, R>(\n  project: (values: [T, T2]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>\n): AsyncIterableX<R>;\nexport function combineLatest<T, T2, T3, R>(\n  project: (values: [T, T2, T3]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): AsyncIterableX<R>;\nexport function combineLatest<T, T2, T3, T4, R>(\n  project: (values: [T, T2, T3, T4]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): AsyncIterableX<R>;\nexport function combineLatest<T, T2, T3, T4, T5, R>(\n  project: (values: [T, T2, T3, T4, T5]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): AsyncIterableX<R>;\nexport function combineLatest<T, T2, T3, T4, T5, T6, R>(\n  project: (values: [T, T2, T3, T4, T5, T6]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): AsyncIterableX<R>;\n\nexport function combineLatest<T>(...sources: AsyncIterable<T>[]): AsyncIterableX<T[]>;\nexport function combineLatest<T, R>(\n  project: (values: T[]) => R | Promise<R>,\n  ...sources: AsyncIterable<T>[]\n): AsyncIterableX<R>;\n/* tslint:enable:max-line-length */\nexport function combineLatest<T, R>(...sources: any[]): AsyncIterableX<R> {\n  let fn = (sources.shift() || identityAsync) as (values: any[]) => R | Promise<R>;\n  if (fn && typeof fn !== 'function') {\n    sources.unshift(fn);\n    fn = identityAsync;\n  }\n  return new CombineLatestAsyncIterable<T, R>(sources as AsyncIterable<T>[], fn);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class ConcatAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: Iterable<AsyncIterable<TSource>>;\n\n  constructor(source: Iterable<AsyncIterable<TSource>>) {\n    super();\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for (let outer of this._source) {\n      for await (let item of outer) {\n        yield item;\n      }\n    }\n  }\n}\n\nexport function _concatAll<TSource>(\n  source: Iterable<AsyncIterable<TSource>>\n): AsyncIterableX<TSource> {\n  return new ConcatAsyncIterable<TSource>(source);\n}\n\n/* tslint:disable:max-line-length */\nexport function concat<T>(source: AsyncIterable<T>): AsyncIterableX<T>;\nexport function concat<T, T2>(\n  source: AsyncIterable<T>,\n  v2: AsyncIterable<T2>\n): AsyncIterableX<T | T2>;\nexport function concat<T, T2, T3>(\n  source: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>\n): AsyncIterableX<T | T2 | T3>;\nexport function concat<T, T2, T3, T4>(\n  source: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>\n): AsyncIterableX<T | T2 | T3 | T4>;\nexport function concat<T, T2, T3, T4, T5>(\n  source: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>\n): AsyncIterable<T | T2 | T3 | T4 | T5>;\nexport function concat<T, T2, T3, T4, T5, T6>(\n  source: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>,\n  v6: AsyncIterable<T6>\n): AsyncIterable<T | T2 | T3 | T4 | T5 | T6>;\nexport function concat<T>(source: AsyncIterable<T>, ...args: AsyncIterable<T>[]): AsyncIterableX<T>;\n/* tslint:enable:max-line-length */\n\nexport function concat<T>(\n  source: AsyncIterable<T>,\n  ...args: AsyncIterable<T>[]\n): AsyncIterableX<T> {\n  return new ConcatAsyncIterable<T>([source, ...args]);\n}\n\n/* tslint:disable:max-line-length */\nexport function concatStatic<T>(v1: AsyncIterable<T>): AsyncIterableX<T>;\nexport function concatStatic<T, T2>(\n  v1: AsyncIterable<T>,\n  v2: AsyncIterable<T2>\n): AsyncIterableX<T | T2>;\nexport function concatStatic<T, T2, T3>(\n  v1: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>\n): AsyncIterableX<T | T2 | T3>;\nexport function concatStatic<T, T2, T3, T4>(\n  v1: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>\n): AsyncIterableX<T | T2 | T3 | T4>;\nexport function concatStatic<T, T2, T3, T4, T5>(\n  v1: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>\n): AsyncIterable<T | T2 | T3 | T4 | T5>;\nexport function concatStatic<T, T2, T3, T4, T5, T6>(\n  v1: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>,\n  v6: AsyncIterable<T6>\n): AsyncIterable<T | T2 | T3 | T4 | T5 | T6>;\n/* tslint:enable:max-line-length */\n\nexport function concatStatic<T>(...args: AsyncIterable<T>[]): AsyncIterableX<T> {\n  return new ConcatAsyncIterable<T>(args);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class ConcatAllAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<AsyncIterable<TSource>>;\n\n  constructor(source: AsyncIterable<AsyncIterable<TSource>>) {\n    super();\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (let outer of this._source) {\n      for await (let item of outer) {\n        yield item;\n      }\n    }\n  }\n}\n\nexport function concatAll<TSource>(\n  source: AsyncIterable<AsyncIterable<TSource>>\n): AsyncIterableX<TSource> {\n  return new ConcatAllAsyncIterable<TSource>(source);\n}\n","export async function count<T>(\n  source: AsyncIterable<T>,\n  fn: (value: T) => boolean | Promise<boolean> = async () => true\n): Promise<number> {\n  let i = 0;\n\n  for await (let item of source) {\n    if (await fn(item)) {\n      i++;\n    }\n  }\n\n  return i;\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nasync function forEach<T>(\n  source: AsyncIterable<T>,\n  fn: (item: T) => void | Promise<void>\n): Promise<void> {\n  for await (const item of source) {\n    await fn(item);\n  }\n}\n\nexport class DebounceAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _time: number;\n\n  constructor(source: AsyncIterable<TSource>, time: number) {\n    super();\n    this._source = source;\n    this._time = time;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let noValue: boolean;\n    let lastItem: TSource | undefined;\n    let deferred: Promise<TSource>;\n    let resolver: (value?: TSource | PromiseLike<TSource> | undefined) => void;\n    let done: boolean = false;\n    let hasError: boolean = false;\n    let error: any;\n\n    const reset = (hasNoValue: boolean) => {\n      noValue = hasNoValue;\n      lastItem = undefined;\n      deferred = new Promise<TSource>(r => (resolver = r));\n    };\n\n    const run = () => {\n      if (lastItem === undefined) {\n        noValue = true;\n        return;\n      }\n\n      const item = lastItem;\n      const res = resolver;\n      reset(false);\n      setTimeout(run, this._time);\n      res(item);\n    };\n\n    reset(true);\n    forEach(this._source, item => {\n      lastItem = item;\n      if (noValue) {\n        run();\n      }\n    })\n      .then(() => (done = true))\n      .catch(err => {\n        hasError = true;\n        error = err;\n      });\n\n    while (1) {\n      if (done) {\n        break;\n      }\n      if (hasError) {\n        throw error;\n      }\n      yield await deferred!;\n    }\n  }\n}\n\nexport function debounce<TSource>(\n  source: AsyncIterable<TSource>,\n  time: number\n): AsyncIterableX<TSource> {\n  return new DebounceAsyncIterable<TSource>(source, time);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class DefaultIfEmptyAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _defaultValue: TSource;\n\n  constructor(source: AsyncIterable<TSource>, defaultValue: TSource) {\n    super();\n    this._source = source;\n    this._defaultValue = defaultValue;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let state = 1;\n    for await (let item of this._source) {\n      state = 2;\n      yield item;\n    }\n    if (state === 1) {\n      yield this._defaultValue;\n    }\n  }\n}\n\nexport function defaultIfEmpty<T>(source: AsyncIterable<T>, defaultValue: T): AsyncIterableX<T> {\n  return new DefaultIfEmptyAsyncIterable<T>(source, defaultValue);\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { identityAsync } from '../internal/identity';\nimport { arrayIndexOfAsync } from '../internal/arrayindexof';\nimport { comparerAsync } from '../internal/comparer';\n\nexport class DistinctAsyncIterable<TSource, TKey> extends AsyncIterableX<TSource> {\n  private _source: Iterable<TSource | PromiseLike<TSource>> | AsyncIterable<TSource>;\n  private _keySelector: (value: TSource) => TKey | Promise<TKey>;\n  private _comparer: (x: TKey, y: TKey) => boolean | Promise<boolean>;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    keySelector: (value: TSource) => TKey | Promise<TKey>,\n    comparer: (x: TKey, y: TKey) => boolean | Promise<boolean>\n  ) {\n    super();\n    this._source = source;\n    this._keySelector = keySelector;\n    this._comparer = comparer;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let set = [] as TKey[];\n\n    for await (let item of <AsyncIterable<TSource>>this._source) {\n      let key = await this._keySelector(item);\n      if ((await arrayIndexOfAsync(set, key, this._comparer)) === -1) {\n        set.push(key);\n        yield item;\n      }\n    }\n  }\n}\n\nexport function distinct<TSource, TKey>(\n  source: AsyncIterable<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey> = identityAsync,\n  comparer: (x: TKey, y: TKey) => boolean | Promise<boolean> = comparerAsync\n): AsyncIterableX<TSource> {\n  return new DistinctAsyncIterable<TSource, TKey>(source, keySelector, comparer);\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { identityAsync } from '../internal/identity';\nimport { comparerAsync } from '../internal/comparer';\n\nexport class DistinctUntilChangedAsyncIterable<TSource, TKey> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _keySelector: (value: TSource) => TKey | Promise<TKey>;\n  private _comparer: (x: TKey, y: TKey) => boolean | Promise<boolean>;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    keySelector: (value: TSource) => TKey | Promise<TKey>,\n    comparer: (first: TKey, second: TKey) => boolean | Promise<boolean>\n  ) {\n    super();\n    this._source = source;\n    this._keySelector = keySelector;\n    this._comparer = comparer;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let currentKey: TKey | undefined,\n      hasCurrentKey = false;\n    for await (let item of this._source) {\n      let key = await this._keySelector(item);\n      let comparerEquals = false;\n      if (hasCurrentKey) {\n        comparerEquals = await this._comparer(currentKey!, key);\n      }\n      if (!hasCurrentKey || !comparerEquals) {\n        hasCurrentKey = true;\n        currentKey = key;\n        yield item;\n      }\n    }\n  }\n}\n\nexport function distinctUntilChanged<TSource, TKey>(\n  source: AsyncIterable<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey> = identityAsync,\n  comparer: (first: TKey, second: TKey) => boolean | Promise<boolean> = comparerAsync\n): AsyncIterableX<TSource> {\n  return new DistinctUntilChangedAsyncIterable<TSource, TKey>(source, keySelector, comparer);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nclass WhileAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _condition: () => boolean | Promise<boolean>;\n  private _source: AsyncIterable<TSource>;\n\n  constructor(condition: () => boolean | Promise<boolean>, source: AsyncIterable<TSource>) {\n    super();\n    this._condition = condition;\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    while (await this._condition()) {\n      for await (let item of this._source) {\n        yield item;\n      }\n    }\n  }\n}\n\nexport function _while<TSource>(\n  condition: () => boolean | Promise<boolean>,\n  source: AsyncIterable<TSource>\n): AsyncIterableX<TSource> {\n  return new WhileAsyncIterable<TSource>(condition, source);\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { concatStatic } from './concat';\nimport { _while } from './while';\n\nexport function doWhile<TSource>(\n  source: AsyncIterable<TSource>,\n  condition: () => boolean | Promise<boolean>\n): AsyncIterableX<TSource> {\n  return concatStatic(source, _while(condition, source));\n}\n","export async function elementAt<T>(\n  source: AsyncIterable<T>,\n  index: number\n): Promise<T | undefined> {\n  for await (let item of source) {\n    if (index === 0) {\n      return item;\n    }\n    index--;\n  }\n  return undefined;\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class EndWithAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _args: TSource[];\n\n  constructor(source: AsyncIterable<TSource>, args: TSource[]) {\n    super();\n    this._source = source;\n    this._args = args;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (let item of this._source) {\n      yield item;\n    }\n    for (let x of this._args) {\n      yield x;\n    }\n  }\n}\n\nexport function endWith<TSource>(\n  source: AsyncIterable<TSource>,\n  ...args: TSource[]\n): AsyncIterableX<TSource> {\n  return new EndWithAsyncIterable<TSource>(source, args);\n}\n","export async function every<T, S extends T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => value is S\n): Promise<boolean>;\nexport async function every<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<boolean>;\nexport async function every<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<boolean> {\n  let i = 0;\n  for await (let item of source) {\n    if (!await predicate(item, i++)) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { arrayIndexOfAsync } from '../internal/arrayindexof';\nimport { comparerAsync } from '../internal/comparer';\n\nexport class ExceptAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _first: AsyncIterable<TSource>;\n  private _second: AsyncIterable<TSource>;\n  private _comparer: (x: TSource, y: TSource) => boolean | Promise<boolean>;\n\n  constructor(\n    first: AsyncIterable<TSource>,\n    second: AsyncIterable<TSource>,\n    comparer: (x: TSource, y: TSource) => boolean | Promise<boolean>\n  ) {\n    super();\n    this._first = first;\n    this._second = second;\n    this._comparer = comparer;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let map = [] as TSource[];\n    for await (let secondItem of this._second) {\n      map.push(secondItem);\n    }\n\n    for await (let firstItem of this._first) {\n      if ((await arrayIndexOfAsync(map, firstItem, this._comparer)) === -1) {\n        map.push(firstItem);\n        yield firstItem;\n      }\n    }\n  }\n}\n\nexport function except<TSource>(\n  first: AsyncIterable<TSource>,\n  second: AsyncIterable<TSource>,\n  comparer: (x: TSource, y: TSource) => boolean | Promise<boolean> = comparerAsync\n): AsyncIterableX<TSource> {\n  return new ExceptAsyncIterable<TSource>(first, second, comparer);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class ExpandAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _selector: (value: TSource) => AsyncIterable<TSource> | Promise<AsyncIterable<TSource>>;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    selector: (value: TSource) => AsyncIterable<TSource> | Promise<AsyncIterable<TSource>>\n  ) {\n    super();\n    this._source = source;\n    this._selector = selector;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let q = [this._source];\n    while (q.length > 0) {\n      let src = q.shift();\n      for await (let item of src!) {\n        let items = await this._selector(item);\n        q.push(items);\n        yield item;\n      }\n    }\n  }\n}\n\nexport function expand<TSource>(\n  source: AsyncIterable<TSource>,\n  selector: (value: TSource) => AsyncIterable<TSource> | Promise<AsyncIterable<TSource>>\n): AsyncIterableX<TSource> {\n  return new ExpandAsyncIterable<TSource>(source, selector);\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { bindCallback } from '../internal/bindcallback';\n\nexport class FilterAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: Iterable<TSource | PromiseLike<TSource>> | AsyncIterable<TSource>;\n  private _predicate: (value: TSource, index: number) => boolean | Promise<boolean>;\n\n  constructor(\n    source: Iterable<TSource | PromiseLike<TSource>> | AsyncIterable<TSource>,\n    predicate: (value: TSource, index: number) => boolean | Promise<boolean>\n  ) {\n    super();\n    this._source = source;\n    this._predicate = predicate;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let i = 0;\n    for await (let item of <AsyncIterable<TSource>>this._source) {\n      if (await this._predicate(item, i++)) {\n        yield item;\n      }\n    }\n  }\n}\n\nexport function filter<T, S extends T>(\n  source: Iterable<T | PromiseLike<T>> | AsyncIterable<T>,\n  predicate: (value: T, index: number) => value is S,\n  thisArg?: any\n): AsyncIterableX<S>;\nexport function filter<T>(\n  source: Iterable<T | PromiseLike<T>> | AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): AsyncIterableX<T>;\nexport function filter<TSource>(\n  source: Iterable<TSource | PromiseLike<TSource>> | AsyncIterable<TSource>,\n  predicate: (value: TSource, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): AsyncIterableX<TSource> {\n  return new FilterAsyncIterable<TSource>(source, bindCallback(predicate, thisArg, 2));\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class FinallyAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _action: () => any | Promise<any>;\n\n  constructor(source: AsyncIterable<TSource>, action: () => void | Promise<void>) {\n    super();\n    this._source = source;\n    this._action = action;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    try {\n      for await (let item of this._source) {\n        yield item;\n      }\n    } finally {\n      await this._action();\n    }\n  }\n}\n\nexport function _finally<TSource>(\n  source: AsyncIterable<TSource>,\n  action: () => any | Promise<any>\n): AsyncIterableX<TSource> {\n  return new FinallyAsyncIterable<TSource>(source, action);\n}\n","import { bindCallback } from '../internal/bindcallback';\n\nexport async function find<T, S extends T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => value is S,\n  thisArg?: any\n): Promise<S | undefined>;\nexport async function find<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): Promise<T | undefined>;\nexport async function find<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): Promise<T | undefined> {\n  const fn = bindCallback(predicate, thisArg, 2);\n  let i = 0;\n\n  for await (let item of source) {\n    if (await fn(item, i++)) {\n      return item;\n    }\n  }\n  return undefined;\n}\n","import { bindCallback } from '../internal/bindcallback';\n\nexport async function findIndex<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): Promise<number> {\n  const fn = bindCallback(predicate, thisArg, 2);\n  let i = 0;\n\n  for await (let item of source) {\n    if (await fn(item, i++)) {\n      return i;\n    }\n  }\n  return -1;\n}\n","export async function first<T, S extends T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => value is S\n): Promise<S | undefined>;\nexport async function first<T>(\n  source: AsyncIterable<T>,\n  predicate?: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<T | undefined>;\nexport async function first<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean> = async () => true\n): Promise<T | undefined> {\n  let i = 0;\n  for await (let item of source) {\n    if (await predicate(item, i++)) {\n      return item;\n    }\n  }\n\n  return undefined;\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { bindCallback } from '../internal/bindcallback';\n\nexport class FlatMapAsyncIterable<TSource, TResult> extends AsyncIterableX<TResult> {\n  private _source: AsyncIterable<TSource>;\n  private _selector: (value: TSource) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    selector: (value: TSource) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>\n  ) {\n    super();\n    this._source = source;\n    this._selector = selector;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (let outer of this._source) {\n      const inners = await this._selector(outer);\n      for await (let inner of inners) {\n        yield inner;\n      }\n    }\n  }\n}\n\nexport function flatMap<TSource, TResult>(\n  source: AsyncIterable<TSource>,\n  selector: (value: TSource) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>,\n  thisArg?: any\n): AsyncIterableX<TResult> {\n  return new FlatMapAsyncIterable<TSource, TResult>(source, bindCallback(selector, thisArg, 1));\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { isAsyncIterable } from '../internal/isiterable';\n\nexport class FlattenAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _depth: number;\n\n  constructor(source: AsyncIterable<TSource>, depth: number) {\n    super();\n    this._source = source;\n    this._depth = depth;\n  }\n\n  private async *_flatten(source: AsyncIterable<TSource>, depth: number): AsyncIterable<TSource> {\n    if (depth === 0) {\n      for await (let item of source) {\n        yield item;\n      }\n      return undefined;\n    }\n    for await (let item of source) {\n      if (isAsyncIterable(item)) {\n        for await (let innerItem of this._flatten(item, depth - 1)) {\n          yield innerItem;\n        }\n      } else {\n        yield item;\n      }\n    }\n  }\n\n  [Symbol.asyncIterator]() {\n    return this._flatten(this._source, this._depth)[Symbol.asyncIterator]();\n  }\n}\n\nexport function flatten<T>(source: AsyncIterable<T>, depth: number = Infinity): AsyncIterableX<T> {\n  return new FlattenAsyncIterable<T>(source, depth);\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { bindCallback } from '../internal/bindcallback';\n\nexport class MapAsyncIterable<TSource, TResult> extends AsyncIterableX<TResult> {\n  private _source: AsyncIterable<TSource>;\n  private _selector: (value: TSource, index: number) => Promise<TResult> | TResult;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    selector: (value: TSource, index: number) => Promise<TResult> | TResult\n  ) {\n    super();\n    this._source = source;\n    this._selector = selector;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let i = 0;\n    for await (let item of <AsyncIterable<TSource>>this._source) {\n      let result = await this._selector(item, i++);\n      yield result;\n    }\n  }\n}\n\nexport function map<TSource, TResult>(\n  source: AsyncIterable<TSource>,\n  selector: (value: TSource, index: number) => Promise<TResult> | TResult,\n  thisArg?: any\n): AsyncIterableX<TResult> {\n  return new MapAsyncIterable<TSource, TResult>(source, bindCallback(selector, thisArg, 2));\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { concatAll } from './concatall';\nimport { map } from './map';\n\nexport function _for<TSource, TResult>(\n  source: AsyncIterable<TSource>,\n  fn: (value: TSource) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>\n): AsyncIterableX<TResult> {\n  return concatAll(map(source, fn));\n}\n","import { identity, identityAsync } from '../internal/identity';\n\n// tslint:disable-next-line:no-empty\nconst NEVER_PROMISE = new Promise(() => {});\n\ntype MergeResult<T> = { value: T; index: number };\n\nfunction wrapPromiseWithIndex<T>(promise: Promise<T>, index: number) {\n  return promise.then(value => ({ value, index })) as Promise<MergeResult<T>>;\n}\n\nexport function forkJoin<T, T2>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>\n): Promise<[T, T2] | undefined>;\nexport function forkJoin<T, T2, T3>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): Promise<[T, T2, T3] | undefined>;\nexport function forkJoin<T, T2, T3, T4>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): Promise<[T, T2, T3, T4] | undefined>;\nexport function forkJoin<T, T2, T3, T4, T5>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): Promise<[T, T2, T3, T4, T5] | undefined>;\nexport function forkJoin<T, T2, T3, T4, T5, T6>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): Promise<[T, T2, T3, T4, T5, T6] | undefined>;\n\nexport function forkJoin<T, R>(\n  project: (values: [T]) => R | Promise<R>,\n  source: AsyncIterable<T>\n): Promise<R | undefined>;\nexport function forkJoin<T, T2, R>(\n  project: (values: [T, T2]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>\n): Promise<R | undefined>;\nexport function forkJoin<T, T2, T3, R>(\n  project: (values: [T, T2, T3]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): Promise<R | undefined>;\nexport function forkJoin<T, T2, T3, T4, R>(\n  project: (values: [T, T2, T3, T4]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): Promise<R | undefined>;\nexport function forkJoin<T, T2, T3, T4, T5, R>(\n  project: (values: [T, T2, T3, T4, T5]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): Promise<R | undefined>;\nexport function forkJoin<T, T2, T3, T4, T5, T6, R>(\n  project: (values: [T, T2, T3, T4, T5, T6]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): Promise<R | undefined>;\n\nexport function forkJoin<T>(...sources: AsyncIterable<T>[]): Promise<T[] | undefined>;\nexport function forkJoin<T, R>(\n  project: (values: T[]) => R | Promise<R>,\n  ...sources: AsyncIterable<T>[]\n): Promise<R | undefined>;\n\nexport async function forkJoin<T, R>(...sources: any[]): Promise<R | undefined> {\n  let fn = (sources.shift() || identityAsync) as (values: any[]) => R | Promise<R>;\n  if (fn && typeof fn !== 'function') {\n    sources.unshift(fn);\n    fn = identityAsync;\n  }\n\n  const length = sources.length;\n  const iterators = new Array<AsyncIterator<T>>(length);\n  const nexts = new Array<Promise<MergeResult<IteratorResult<T>>>>(length);\n\n  let active = length;\n  const values = new Array<T>(length);\n  const hasValues = new Array<boolean>(length);\n  hasValues.fill(false);\n\n  for (let i = 0; i < length; i++) {\n    const iterator = sources[i][Symbol.asyncIterator]();\n    iterators[i] = iterator;\n    nexts[i] = wrapPromiseWithIndex(iterator.next(), i);\n  }\n\n  while (active > 0) {\n    const next = Promise.race(nexts);\n    const { value: next$, index } = await next;\n    if (next$.done) {\n      nexts[index] = <Promise<MergeResult<IteratorResult<T>>>>NEVER_PROMISE;\n      active--;\n    } else {\n      const iterator$ = iterators[index];\n      nexts[index] = wrapPromiseWithIndex(iterator$.next(), index);\n      hasValues[index] = true;\n      values[index] = next$.value;\n    }\n  }\n\n  if (hasValues.length > 0 && hasValues.every(identity)) {\n    return await fn(values);\n  }\n\n  return undefined;\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { AsyncSink } from '../asyncsink';\nimport { memoize } from './memoize';\n\nexport function fromEventPattern<TSource>(\n  addHandler: (handler: (...args: any[]) => void) => void,\n  removeHandler: (handler: (...args: any[]) => void) => void\n): AsyncIterableX<TSource> {\n  const sink = new AsyncSink<TSource>();\n  const handler = (e: TSource) => sink.write(e);\n\n  addHandler(handler);\n\n  return memoize(\n    (async function*() {\n      for (let next; !(next = await sink.next()).done; ) {\n        yield next.value;\n      }\n      removeHandler(handler);\n      sink.end();\n    })()\n  );\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { fromEventPattern } from './fromeventpattern';\n\nexport interface NodeEventEmitter {\n  addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n  removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n}\n\nexport type EventListenerOptions =\n  | {\n      capture?: boolean;\n      passive?: boolean;\n      once?: boolean;\n    }\n  | boolean;\n\nexport type EventedTarget = EventTarget | NodeEventEmitter;\n\nfunction isNodeEventEmitter(obj: any): obj is NodeEventEmitter {\n  return !!obj && typeof obj.addListener === 'function' && typeof obj.removeListener === 'function';\n}\n\nfunction isEventTarget(obj: any): obj is EventTarget {\n  return (\n    !!obj &&\n    typeof obj.addEventListener === 'function' &&\n    typeof obj.removeEventListener === 'function'\n  );\n}\n\nexport function fromEvent<TSource>(\n  obj: EventedTarget,\n  type: string,\n  options?: EventListenerOptions\n): AsyncIterableX<TSource> {\n  if (isEventTarget(obj)) {\n    const target = <EventTarget>obj;\n    return fromEventPattern<TSource>(\n      h => target.addEventListener(type, <EventListener>h, options),\n      h => target.removeEventListener(type, <EventListener>h, options)\n    );\n  } else if (isNodeEventEmitter(obj)) {\n    const target = <NodeEventEmitter>obj;\n    return fromEventPattern<TSource>(\n      h => target.addListener(type, h),\n      h => target.removeListener(type, h)\n    );\n  } else {\n    throw new TypeError('Unsupported event target');\n  }\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nclass GenerateAsyncIterable<TState, TResult> extends AsyncIterableX<TResult> {\n  private _initialState: TState;\n  private _condition: (value: TState) => boolean | Promise<boolean>;\n  private _iterate: (value: TState) => TState | Promise<TState>;\n  private _resultSelector: (value: TState) => TResult | Promise<TResult>;\n\n  constructor(\n    initialState: TState,\n    condition: (value: TState) => boolean | Promise<boolean>,\n    iterate: (value: TState) => TState | Promise<TState>,\n    resultSelector: (value: TState) => TResult | Promise<TResult>\n  ) {\n    super();\n    this._initialState = initialState;\n    this._condition = condition;\n    this._iterate = iterate;\n    this._resultSelector = resultSelector;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for (let i = this._initialState; await this._condition(i); i = await this._iterate(i)) {\n      yield await this._resultSelector(i);\n    }\n  }\n}\n\nexport function generate<TState, TResult>(\n  initialState: TState,\n  condition: (value: TState) => boolean | Promise<boolean>,\n  iterate: (value: TState) => TState | Promise<TState>,\n  resultSelector: (value: TState) => TResult | Promise<TResult>\n): AsyncIterableX<TResult> {\n  return new GenerateAsyncIterable<TState, TResult>(\n    initialState,\n    condition,\n    iterate,\n    resultSelector\n  );\n}\n","export function sleep(dueTime: number) {\n  return new Promise<void>(res => setTimeout(res, dueTime));\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { sleep } from './_sleep';\n\nclass GenerateTimeAsyncIterable<TState, TResult> extends AsyncIterableX<TResult> {\n  private _initialState: TState;\n  private _condition: (value: TState) => boolean | Promise<boolean>;\n  private _iterate: (value: TState) => TState | Promise<TState>;\n  private _resultSelector: (value: TState) => TResult | Promise<TResult>;\n  private _timeSelector: (value: TState) => number | Promise<number>;\n\n  constructor(\n    initialState: TState,\n    condition: (value: TState) => boolean | Promise<boolean>,\n    iterate: (value: TState) => TState | Promise<TState>,\n    resultSelector: (value: TState) => TResult | Promise<TResult>,\n    timeSelector: (value: TState) => number | Promise<number>\n  ) {\n    super();\n    this._initialState = initialState;\n    this._condition = condition;\n    this._iterate = iterate;\n    this._resultSelector = resultSelector;\n    this._timeSelector = timeSelector;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for (let i = this._initialState; await this._condition(i); i = await this._iterate(i)) {\n      const time = await this._timeSelector(i);\n      await sleep(time);\n      yield await this._resultSelector(i);\n    }\n  }\n}\n\nexport function generateTime<TState, TResult>(\n  initialState: TState,\n  condition: (value: TState) => boolean | Promise<boolean>,\n  iterate: (value: TState) => TState | Promise<TState>,\n  resultSelector: (value: TState) => TResult | Promise<TResult>,\n  timeSelector: (value: TState) => number | Promise<number>\n): AsyncIterableX<TResult> {\n  return new GenerateTimeAsyncIterable<TState, TResult>(\n    initialState,\n    condition,\n    iterate,\n    resultSelector,\n    timeSelector\n  );\n}\n","/**\n * @ignore\n */\nexport async function createGrouping<TSource, TKey, TValue>(\n  source: AsyncIterable<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector: (value: TSource) => TValue | Promise<TValue>\n): Promise<Map<TKey, TValue[]>> {\n  let map = new Map<TKey, TValue[]>();\n  for await (let item of source) {\n    let key = await keySelector(item);\n    let grouping = map.get(key);\n    if (!map.has(key)) {\n      grouping = [];\n      map.set(key, grouping);\n    }\n    let element = await elementSelector(item);\n    grouping!.push(element);\n  }\n\n  return map;\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { identityAsync } from '../internal/identity';\nimport { createGrouping } from './_grouping';\n\nexport class GroupedAsyncIterable<TKey, TValue> extends AsyncIterableX<TValue> {\n  public readonly key: TKey;\n  private _source: Iterable<TValue>;\n\n  constructor(key: TKey, source: Iterable<TValue>) {\n    super();\n    this.key = key;\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for (let item of this._source) {\n      yield item;\n    }\n  }\n}\n\nexport class GroupByAsyncIterable<TSource, TKey, TValue, TResult> extends AsyncIterableX<TResult> {\n  private _source: AsyncIterable<TSource>;\n  private _keySelector: (value: TSource) => TKey | Promise<TKey>;\n  private _elementSelector: (value: TSource) => TValue | Promise<TValue>;\n  private _resultSelector: (key: TKey, values: Iterable<TValue>) => TResult | Promise<TResult>;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    keySelector: (value: TSource) => TKey | Promise<TKey>,\n    elementSelector: (value: TSource) => TValue | Promise<TValue>,\n    resultSelector: (key: TKey, values: Iterable<TValue>) => TResult | Promise<TResult>\n  ) {\n    super();\n    this._source = source;\n    this._keySelector = keySelector;\n    this._elementSelector = elementSelector;\n    this._resultSelector = resultSelector;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    const map = await createGrouping(this._source, this._keySelector, this._elementSelector);\n    for (let [key, values] of map) {\n      yield await this._resultSelector(key, values);\n    }\n  }\n}\n\nexport function groupByResultIdentityAsync<TKey, TValue>(key: TKey, values: Iterable<TValue>): any {\n  return new GroupedAsyncIterable(key, values);\n}\n\nexport function groupBy<TSource, TKey>(\n  source: AsyncIterable<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>\n): AsyncIterableX<GroupedAsyncIterable<TKey, TSource>>;\nexport function groupBy<TSource, TKey, TValue>(\n  source: AsyncIterable<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (value: TSource) => TValue | Promise<TValue>\n): AsyncIterableX<GroupedAsyncIterable<TKey, TValue>>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  source: AsyncIterable<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (value: TSource) => TValue | Promise<TValue>,\n  resultSelector?: (key: TKey, values: Iterable<TValue>) => TResult | Promise<TResult>\n): AsyncIterableX<TResult>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  source: AsyncIterable<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector: (value: TSource) => TValue | Promise<TValue> = identityAsync,\n  resultSelector: (\n    key: TKey,\n    values: Iterable<TValue>\n  ) => TResult | Promise<TResult> = groupByResultIdentityAsync\n): AsyncIterableX<TResult> {\n  return new GroupByAsyncIterable<TSource, TKey, TValue, TResult>(\n    source,\n    keySelector,\n    elementSelector,\n    resultSelector\n  );\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { createGrouping } from './_grouping';\nimport { empty } from './empty';\nimport { identity } from '../internal/identity';\n\nexport class GroupJoinAsyncIterable<TOuter, TInner, TKey, TResult> extends AsyncIterableX<TResult> {\n  private _outer: AsyncIterable<TOuter>;\n  private _inner: AsyncIterable<TInner>;\n  private _outerSelector: (value: TOuter) => TKey | Promise<TKey>;\n  private _innerSelector: (value: TInner) => TKey | Promise<TKey>;\n  private _resultSelector: (\n    outer: TOuter,\n    inner: AsyncIterable<TInner>\n  ) => TResult | Promise<TResult>;\n\n  constructor(\n    outer: AsyncIterable<TOuter>,\n    inner: AsyncIterable<TInner>,\n    outerSelector: (value: TOuter) => TKey | Promise<TKey>,\n    innerSelector: (value: TInner) => TKey | Promise<TKey>,\n    resultSelector: (outer: TOuter, inner: AsyncIterable<TInner>) => TResult | Promise<TResult>\n  ) {\n    super();\n    this._outer = outer;\n    this._inner = inner;\n    this._outerSelector = outerSelector;\n    this._innerSelector = innerSelector;\n    this._resultSelector = resultSelector;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    const map = await createGrouping(this._inner, this._innerSelector, identity);\n    for await (let outerElement of this._outer) {\n      const outerKey = await this._outerSelector(outerElement);\n      const innerElements = map.has(outerKey)\n        ? <Iterable<TInner>>map.get(outerKey)\n        : empty<TInner>();\n      yield await this._resultSelector(outerElement, AsyncIterableX.from(innerElements));\n    }\n  }\n}\n\nexport function groupJoin<TOuter, TInner, TKey, TResult>(\n  outer: AsyncIterable<TOuter>,\n  inner: AsyncIterable<TInner>,\n  outerSelector: (value: TOuter) => TKey | Promise<TKey>,\n  innerSelector: (value: TInner) => TKey | Promise<TKey>,\n  resultSelector: (outer: TOuter, inner: AsyncIterable<TInner>) => TResult | Promise<TResult>\n): AsyncIterableX<TResult> {\n  return new GroupJoinAsyncIterable<TOuter, TInner, TKey, TResult>(\n    outer,\n    inner,\n    outerSelector,\n    innerSelector,\n    resultSelector\n  );\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { defer } from './defer';\nimport { empty } from './empty';\n\nexport function _if<TSource>(\n  fn: () => boolean | Promise<boolean>,\n  thenSource: AsyncIterable<TSource>,\n  elseSource: AsyncIterable<TSource> = empty<TSource>()\n): AsyncIterableX<TSource> {\n  return defer<TSource>(async () => ((await fn()) ? thenSource : elseSource));\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class IgnoreElementsAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n\n  constructor(source: AsyncIterable<TSource>) {\n    super();\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<TSource> {\n    // tslint:disable-next-line:no-empty\n    for await (let _ of this._source) {\n    }\n  }\n}\n\nexport function ignoreElements<TSource>(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n  return new IgnoreElementsAsyncIterable<TSource>(source);\n}\n","import { comparer } from '../internal/comparer';\n\nexport async function includes<T>(\n  source: AsyncIterable<T>,\n  searchElement: T,\n  fromIndex: number = 0\n): Promise<boolean> {\n  let i = 0;\n  if (Math.abs(fromIndex)) {\n    fromIndex = 0;\n  }\n  for await (let item of source) {\n    if (i++ > fromIndex && comparer(item, searchElement)) {\n      return true;\n    }\n  }\n  return false;\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { createGrouping } from './_grouping';\nimport { identity } from '../internal/identity';\n\nexport class JoinAsyncIterable<TOuter, TInner, TKey, TResult> extends AsyncIterableX<TResult> {\n  private _outer: AsyncIterable<TOuter>;\n  private _inner: AsyncIterable<TInner>;\n  private _outerSelector: (value: TOuter) => TKey | Promise<TKey>;\n  private _innerSelector: (value: TInner) => TKey | Promise<TKey>;\n  private _resultSelector: (outer: TOuter, inner: TInner) => TResult | Promise<TResult>;\n\n  constructor(\n    outer: AsyncIterable<TOuter>,\n    inner: AsyncIterable<TInner>,\n    outerSelector: (value: TOuter) => TKey | Promise<TKey>,\n    innerSelector: (value: TInner) => TKey | Promise<TKey>,\n    resultSelector: (outer: TOuter, inner: TInner) => TResult | Promise<TResult>\n  ) {\n    super();\n    this._outer = outer;\n    this._inner = inner;\n    this._outerSelector = outerSelector;\n    this._innerSelector = innerSelector;\n    this._resultSelector = resultSelector;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    const map = await createGrouping(this._inner, this._innerSelector, identity);\n    for await (let outerElement of this._outer) {\n      const outerKey = await this._outerSelector(outerElement);\n      if (map.has(outerKey)) {\n        for (let innerElement of map.get(outerKey)!) {\n          yield await this._resultSelector(outerElement, innerElement);\n        }\n      }\n    }\n  }\n}\n\nexport function innerJoin<TOuter, TInner, TKey, TResult>(\n  outer: AsyncIterable<TOuter>,\n  inner: AsyncIterable<TInner>,\n  outerSelector: (value: TOuter) => TKey | Promise<TKey>,\n  innerSelector: (value: TInner) => TKey | Promise<TKey>,\n  resultSelector: (outer: TOuter, inner: TInner) => TResult | Promise<TResult>\n): AsyncIterableX<TResult> {\n  return new JoinAsyncIterable<TOuter, TInner, TKey, TResult>(\n    outer,\n    inner,\n    outerSelector,\n    innerSelector,\n    resultSelector\n  );\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { arrayIndexOfAsync } from '../internal/arrayindexof';\nimport { comparerAsync } from '../internal/comparer';\n\nasync function arrayRemove<T>(\n  array: T[],\n  item: T,\n  comparer: (x: T, y: T) => boolean | Promise<boolean>\n): Promise<boolean> {\n  let idx = await arrayIndexOfAsync(array, item, comparer);\n  if (idx === -1) {\n    return false;\n  }\n  array.splice(idx, 1);\n  return true;\n}\n\nexport class IntersectAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _first: AsyncIterable<TSource>;\n  private _second: AsyncIterable<TSource>;\n  private _comparer: (x: TSource, y: TSource) => boolean | Promise<boolean>;\n\n  constructor(\n    first: AsyncIterable<TSource>,\n    second: AsyncIterable<TSource>,\n    comparer: (x: TSource, y: TSource) => boolean | Promise<boolean>\n  ) {\n    super();\n    this._first = first;\n    this._second = second;\n    this._comparer = comparer;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let map = [] as TSource[];\n    for await (let secondItem of this._second) {\n      map.push(secondItem);\n    }\n\n    for await (let firstItem of this._first) {\n      if (await arrayRemove(map, firstItem, this._comparer)) {\n        yield firstItem;\n      }\n    }\n  }\n}\n\nexport function intersect<TSource>(\n  first: AsyncIterable<TSource>,\n  second: AsyncIterable<TSource>,\n  comparer: (x: TSource, y: TSource) => boolean | Promise<boolean> = comparerAsync\n): AsyncIterableX<TSource> {\n  return new IntersectAsyncIterable<TSource>(first, second, comparer);\n}\n","export async function isEmpty<T>(source: AsyncIterable<T>): Promise<boolean> {\n  for await (let _ of source) {\n    return false;\n  }\n  return true;\n}\n","export async function last<T, S extends T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => value is S\n): Promise<S | undefined>;\nexport async function last<T>(\n  source: AsyncIterable<T>,\n  predicate?: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<T | undefined>;\nexport async function last<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean> = async () => true\n): Promise<T | undefined> {\n  let i = 0,\n    result: T | undefined;\n  for await (let item of source) {\n    if (await predicate(item, i++)) {\n      result = item;\n    }\n  }\n\n  return result;\n}\n","import { identityAsync } from '../internal/identity';\n\nexport async function max(\n  source: AsyncIterable<number>,\n  selector?: (x: number) => number | Promise<number>\n): Promise<number>;\nexport async function max<T>(\n  source: AsyncIterable<T>,\n  selector: (x: T) => number | Promise<number>\n): Promise<number>;\nexport async function max(\n  source: AsyncIterable<any>,\n  selector: (x: any) => number | Promise<number> = identityAsync\n): Promise<number> {\n  let atleastOnce = false;\n  let value = -Infinity;\n  for await (let item of source) {\n    if (!atleastOnce) {\n      atleastOnce = true;\n    }\n    let x = await selector(item);\n    if (x > value) {\n      value = x;\n    }\n  }\n  if (!atleastOnce) {\n    throw new Error('Sequence contains no elements');\n  }\n\n  return value;\n}\n","import { AsyncIterableX } from './asynciterablex';\n\n/**\n * @ignore\n */\nexport async function defaultCompareAsync<T>(key: T, minValue: T): Promise<number> {\n  return key > minValue ? 1 : key < minValue ? -1 : 0;\n}\n\n/**\n * @ignore\n */\nclass ExtremaByAsyncIterator<TSource, TKey> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _keyFn: (x: TSource) => TKey | Promise<TKey>;\n  private _cmp: (x: TKey, y: TKey) => number | Promise<number>;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    keyFn: (x: TSource) => TKey | Promise<TKey>,\n    cmp: (x: TKey, y: TKey) => number | Promise<number>\n  ) {\n    super();\n    this._source = source;\n    this._keyFn = keyFn;\n    this._cmp = cmp;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let result: TSource[] = [],\n      done,\n      next;\n    const it = this._source[Symbol.asyncIterator]();\n    done = (next = await it.next()).done;\n    if (done) {\n      throw new Error('Sequence contains no elements');\n    }\n\n    let current = next.value;\n    let resKey = await this._keyFn(current);\n    done = (next = await it.next()).done;\n    while (!done) {\n      let curr = next.value;\n      let key = await this._keyFn(curr);\n      const c = await this._cmp(key, resKey);\n      if (c === 0) {\n        result.push(curr);\n      } else if (c > 0) {\n        result = [curr];\n        resKey = key;\n      }\n      done = (next = await it.next()).done;\n    }\n\n    yield* result;\n  }\n}\n\n/**\n * @ignore\n */\nexport function extremaBy<TSource, TKey>(\n  source: AsyncIterable<TSource>,\n  keyFn: (x: TSource) => TKey | Promise<TKey>,\n  cmp: (x: TKey, y: TKey) => number | Promise<number>\n): AsyncIterableX<TSource> {\n  return new ExtremaByAsyncIterator<TSource, TKey>(source, keyFn, cmp);\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { extremaBy, defaultCompareAsync } from './_extremaby';\n\nexport function maxBy<TSource, TKey>(\n  source: AsyncIterable<TSource>,\n  keySelector: (x: TSource) => TKey | Promise<TKey>,\n  comparer: (x: TKey, y: TKey) => number | Promise<number> = defaultCompareAsync\n): AsyncIterableX<TSource> {\n  return extremaBy(source, keySelector, comparer);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\n// tslint:disable-next-line:no-empty\nconst NEVER_PROMISE = new Promise(() => {});\n\ntype MergeResult<T> = { value: T; index: number };\n\nfunction wrapPromiseWithIndex<T>(promise: Promise<T>, index: number) {\n  return promise.then(value => ({ value, index })) as Promise<MergeResult<T>>;\n}\n\nexport class MergeAsyncIterable<T> extends AsyncIterableX<T> {\n  private _source: AsyncIterable<T>[];\n\n  constructor(source: AsyncIterable<T>[]) {\n    super();\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<T> {\n    const length = this._source.length;\n    const iterators = new Array<AsyncIterator<T>>(length);\n    const nexts = new Array<Promise<MergeResult<IteratorResult<T>>>>(length);\n    let active = length;\n    for (let i = 0; i < length; i++) {\n      const iterator = this._source[i][Symbol.asyncIterator]();\n      iterators[i] = iterator;\n      nexts[i] = wrapPromiseWithIndex(iterator.next(), i);\n    }\n\n    while (active > 0) {\n      const next = Promise.race(nexts);\n      const { value: next$, index } = await next;\n      if (next$.done) {\n        nexts[index] = <Promise<MergeResult<IteratorResult<T>>>>NEVER_PROMISE;\n        active--;\n      } else {\n        const iterator$ = iterators[index];\n        nexts[index] = wrapPromiseWithIndex(iterator$.next(), index);\n        yield next$.value;\n      }\n    }\n  }\n}\n\n/* tslint:disable:max-line-length */\nexport function merge<T>(source: AsyncIterable<T>): AsyncIterableX<T>;\nexport function merge<T, T2>(\n  source: AsyncIterable<T>,\n  v2: AsyncIterable<T2>\n): AsyncIterableX<T | T2>;\nexport function merge<T, T2, T3>(\n  source: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>\n): AsyncIterableX<T | T2 | T3>;\nexport function merge<T, T2, T3, T4>(\n  source: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>\n): AsyncIterableX<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4, T5>(\n  source: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>\n): AsyncIterable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5, T6>(\n  source: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>,\n  v6: AsyncIterable<T6>\n): AsyncIterable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T>(source: AsyncIterable<T>, ...args: AsyncIterable<T>[]): AsyncIterableX<T>;\n/* tslint:enable:max-line-length */\n\nexport function merge<T>(source: AsyncIterable<T>, ...args: AsyncIterable<T>[]): AsyncIterableX<T> {\n  return new MergeAsyncIterable<T>([source, ...args]);\n}\n\n/* tslint:disable:max-line-length */\nexport function mergeStatic<T>(v1: AsyncIterable<T>): AsyncIterableX<T>;\nexport function mergeStatic<T, T2>(\n  v1: AsyncIterable<T>,\n  v2: AsyncIterable<T2>\n): AsyncIterableX<T | T2>;\nexport function mergeStatic<T, T2, T3>(\n  v1: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>\n): AsyncIterableX<T | T2 | T3>;\nexport function mergeStatic<T, T2, T3, T4>(\n  v1: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>\n): AsyncIterableX<T | T2 | T3 | T4>;\nexport function mergeStatic<T, T2, T3, T4, T5>(\n  v1: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>\n): AsyncIterable<T | T2 | T3 | T4 | T5>;\nexport function mergeStatic<T, T2, T3, T4, T5, T6>(\n  v1: AsyncIterable<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>,\n  v6: AsyncIterable<T6>\n): AsyncIterable<T | T2 | T3 | T4 | T5 | T6>;\n/* tslint:enable:max-line-length */\n\nexport function mergeStatic<T>(...args: AsyncIterable<T>[]): AsyncIterableX<T> {\n  return new MergeAsyncIterable<T>(args);\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { flatMap } from './flatmap';\n\nexport function mergeAll<TSource>(\n  source: AsyncIterable<AsyncIterable<TSource>>\n): AsyncIterableX<TSource> {\n  return flatMap(source, source => source);\n}\n","'use strict';\nimport { identityAsync } from '../internal/identity';\n\nexport async function min(\n  source: AsyncIterable<number>,\n  selector?: (x: number) => number | Promise<number>\n): Promise<number>;\nexport async function min<T>(\n  source: AsyncIterable<T>,\n  selector: (x: T) => number | Promise<number>\n): Promise<number>;\nexport async function min(\n  source: AsyncIterable<any>,\n  selector: (x: any) => number | Promise<number> = identityAsync\n): Promise<number> {\n  let atleastOnce = false;\n  let value = Infinity;\n  for await (let item of source) {\n    if (!atleastOnce) {\n      atleastOnce = true;\n    }\n    let x = await selector(item);\n    if (x < value) {\n      value = x;\n    }\n  }\n  if (!atleastOnce) {\n    throw new Error('Sequence contains no elements');\n  }\n\n  return value;\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { extremaBy, defaultCompareAsync } from './_extremaby';\n\nexport function minBy<TSource, TKey>(\n  source: AsyncIterable<TSource>,\n  keySelector: (x: TSource) => TKey | Promise<TKey>,\n  comparer: (x: TKey, y: TKey) => number | Promise<number> = defaultCompareAsync\n): AsyncIterableX<TSource> {\n  return extremaBy(source, keySelector, async (key, minValue) => -await comparer(key, minValue));\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nfunction makeTuple<TFirst, TSecond>(x: TFirst, y: TSecond): [TFirst, TSecond] {\n  return [x, y];\n}\n\nclass OfEntriesAsyncIterable<TSource> extends AsyncIterableX<[string, TSource]> {\n  private _source: { [key: string]: TSource };\n\n  constructor(source: { [key: string]: TSource }) {\n    super();\n    this._source = source;\n  }\n\n  [Symbol.asyncIterator]() {\n    return AsyncIterableX.from(Object.keys(this._source), key => makeTuple(key, this._source[key]))[\n      Symbol.asyncIterator\n    ]();\n  }\n}\n\nexport function ofEntries<TSource>(source: {\n  [key: string]: TSource;\n}): AsyncIterableX<[string, TSource]> {\n  return new OfEntriesAsyncIterable<TSource>(source);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nclass OfKeysAsyncIterable<TSource> extends AsyncIterableX<string> {\n  private _source: { [key: string]: TSource };\n\n  constructor(source: { [key: string]: TSource }) {\n    super();\n    this._source = source;\n  }\n\n  [Symbol.asyncIterator]() {\n    return AsyncIterableX.from<string, string>(Object.keys(this._source))[Symbol.asyncIterator]();\n  }\n}\n\nexport function ofKeys<TSource>(source: { [key: string]: TSource }): AsyncIterableX<string> {\n  return new OfKeysAsyncIterable<TSource>(source);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nclass OfValuesAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: { [key: string]: TSource };\n\n  constructor(source: { [key: string]: TSource }) {\n    super();\n    this._source = source;\n  }\n\n  [Symbol.asyncIterator]() {\n    return AsyncIterableX.from(Object.keys(this._source), key => this._source[key])[\n      Symbol.asyncIterator\n    ]();\n  }\n}\n\nexport function ofValues<TSource>(source: { [key: string]: TSource }): AsyncIterableX<TSource> {\n  return new OfValuesAsyncIterable<TSource>(source);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class OnErrorResumeNextAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: Iterable<AsyncIterable<TSource>>;\n\n  constructor(source: Iterable<AsyncIterable<TSource>>) {\n    super();\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for (let item of this._source) {\n      let it = item[Symbol.asyncIterator]();\n      while (1) {\n        let next;\n        try {\n          next = await it.next();\n        } catch (e) {\n          break;\n        }\n\n        if (next.done) {\n          break;\n        }\n        yield next.value;\n      }\n    }\n  }\n}\n\nexport function onErrorResumeNext<T>(\n  source: AsyncIterable<T>,\n  ...args: AsyncIterable<T>[]\n): AsyncIterableX<T> {\n  return new OnErrorResumeNextAsyncIterable<T>([source, ...args]);\n}\n\nexport function onErrorResumeNextStatic<T>(...source: AsyncIterable<T>[]): AsyncIterableX<T> {\n  return new OnErrorResumeNextAsyncIterable<T>(source);\n}\n","export async function toArray<TSource>(source: AsyncIterable<TSource>): Promise<TSource[]> {\n  let results = [] as TSource[];\n  for await (let item of source) {\n    results.push(item);\n  }\n  return results;\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { toArray } from './toarray';\nimport { sorter as defaultSorter } from '../internal/sorter';\n\nexport abstract class OrderedAsyncIterableBaseX<TSource> extends AsyncIterableX<TSource> {\n  _source: AsyncIterable<TSource>;\n\n  constructor(source: AsyncIterable<TSource>) {\n    super();\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    const array = await toArray(this._source);\n    const len = array.length;\n    const indices = new Array<number>(len);\n    for (let i = 0, len = array.length; i < len; i++) {\n      indices[i] = i;\n    }\n\n    indices.sort(this._getSorter(array));\n    for (const index of indices) {\n      yield array[index];\n    }\n  }\n\n  thenBy<TKey>(\n    keySelector: (item: TSource) => TKey,\n    comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n  ): OrderedAsyncIterableBaseX<TSource> {\n    /* tslint:disable-next-line: no-use-before-declare */\n    return new OrderedAsyncIterableX<TKey, TSource>(\n      this._source,\n      keySelector,\n      comparer,\n      false,\n      this\n    );\n  }\n\n  thenByDescending<TKey>(\n    keySelector: (item: TSource) => TKey,\n    comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n  ): OrderedAsyncIterableBaseX<TSource> {\n    /* tslint:disable-next-line: no-use-before-declare */\n    return new OrderedAsyncIterableX<TKey, TSource>(\n      this._source,\n      keySelector,\n      comparer,\n      true,\n      this\n    );\n  }\n\n  abstract _getSorter(\n    elements: TSource[],\n    next?: (x: number, y: number) => number\n  ): (x: number, y: number) => number;\n}\n\nexport class OrderedAsyncIterableX<TKey, TSource> extends OrderedAsyncIterableBaseX<TSource> {\n  private _keySelector: (item: TSource) => TKey;\n  private _comparer: (fst: TKey, snd: TKey) => number;\n  private _descending: boolean;\n  private _parent?: OrderedAsyncIterableBaseX<TSource>;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    keySelector: (item: TSource) => TKey,\n    comparer: (fst: TKey, snd: TKey) => number,\n    descending: boolean,\n    parent?: OrderedAsyncIterableBaseX<TSource>\n  ) {\n    super(source);\n    this._keySelector = keySelector;\n    this._comparer = comparer;\n    this._descending = descending;\n    this._parent = parent;\n  }\n\n  _getSorter(\n    elements: TSource[],\n    next?: (x: number, y: number) => number\n  ): (x: number, y: number) => number {\n    const keys = elements.map(this._keySelector);\n    const comparer = this._comparer;\n    const parent = this._parent;\n    const descending = this._descending;\n    const sorter = (x: number, y: number): number => {\n      const result = comparer(keys[x], keys[y]);\n      if (result === 0) {\n        return next ? next(x, y) : x - y;\n      }\n\n      return descending ? -result : result;\n    };\n\n    return parent ? parent._getSorter(elements, sorter) : sorter;\n  }\n}\n\nexport function orderBy<TKey, TSource>(\n  source: AsyncIterable<TSource>,\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): OrderedAsyncIterableX<TKey, TSource> {\n  return new OrderedAsyncIterableX<TKey, TSource>(source, keySelector, comparer, false);\n}\n\nexport function orderByDescending<TKey, TSource>(\n  source: AsyncIterable<TSource>,\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): OrderedAsyncIterableX<TKey, TSource> {\n  return new OrderedAsyncIterableX<TKey, TSource>(source, keySelector, comparer, true);\n}\n\nexport function thenBy<TKey, TSource>(\n  source: OrderedAsyncIterableBaseX<TSource>,\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): OrderedAsyncIterableX<TKey, TSource> {\n  return new OrderedAsyncIterableX<TKey, TSource>(\n    source._source,\n    keySelector,\n    comparer,\n    false,\n    source\n  );\n}\n\nexport function thenByDescending<TKey, TSource>(\n  source: OrderedAsyncIterableBaseX<TSource>,\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): OrderedAsyncIterableX<TKey, TSource> {\n  return new OrderedAsyncIterableX<TKey, TSource>(\n    source._source,\n    keySelector,\n    comparer,\n    true,\n    source\n  );\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class PairwiseAsyncIterable<TSource> extends AsyncIterableX<TSource[]> {\n  private _source: AsyncIterable<TSource>;\n\n  constructor(source: AsyncIterable<TSource>) {\n    super();\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let value: TSource | undefined,\n      hasValue = false;\n    for await (const item of this._source) {\n      if (!hasValue) {\n        hasValue = true;\n      } else {\n        yield [value!, item];\n      }\n      value = item;\n    }\n  }\n}\n\n/**\n * Returns a new sequence that triggers on the second and subsequent triggerings of the input sequence.\n * @param {AsyncIterable<T>} source Source sequence.\n * @return {AsyncIterable<T[]>} A sequence that triggers on successive pairs of iterations from the input sequence.\n */\nexport function pairwise<TSource>(source: AsyncIterable<TSource>): AsyncIterableX<TSource[]> {\n  return new PairwiseAsyncIterable<TSource>(source);\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { filter } from './filter';\n\nexport function partition<T, S extends T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => value is S,\n  thisArg?: any\n): AsyncIterableX<S>[];\nexport function partition<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): AsyncIterableX<T>[];\nexport function partition<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): AsyncIterableX<T>[] {\n  return [filter(source, predicate, thisArg), filter(source, (x, i) => !predicate(x, i), thisArg)];\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { map } from './map';\n\nfunction plucker(props: string[], length: number): (x: any) => any {\n  const mapper = (x: any) => {\n    let currentProp = x;\n    for (let i = 0; i < length; i++) {\n      const p = currentProp[props[i]];\n      if (typeof p !== 'undefined') {\n        currentProp = p;\n      } else {\n        return undefined;\n      }\n    }\n    return currentProp;\n  };\n\n  return mapper;\n}\n\nexport function pluck<TSource, TResult>(\n  source: AsyncIterable<TSource>,\n  ...args: string[]\n): AsyncIterableX<TResult> {\n  return map<TSource, TResult>(source, (plucker(args, args.length) as any) as (\n    value: TSource\n  ) => TResult);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nclass RaceAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _left: AsyncIterable<TSource>;\n  private _right: AsyncIterable<TSource>;\n\n  constructor(left: AsyncIterable<TSource>, right: AsyncIterable<TSource>) {\n    super();\n    this._left = left;\n    this._right = right;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    const leftIt = this._left[Symbol.asyncIterator](),\n      rightIt = this._right[Symbol.asyncIterator]();\n    let otherIterator: AsyncIterator<TSource>;\n    let resultIterator: AsyncIterator<TSource>;\n    const { value, done } = await Promise.race([\n      leftIt.next().then(x => {\n        if (!resultIterator) {\n          resultIterator = leftIt;\n          otherIterator = rightIt;\n        }\n        return x;\n      }),\n      rightIt.next().then(x => {\n        if (!resultIterator) {\n          resultIterator = rightIt;\n          otherIterator = leftIt;\n        }\n        return x;\n      })\n    ]);\n\n    if (!done) {\n      yield value;\n    }\n\n    otherIterator = otherIterator!;\n    resultIterator = resultIterator!;\n\n    // Cancel/finish other iterator\n    if (otherIterator.return) {\n      await otherIterator.return!();\n    }\n\n    let next;\n    while (!(next = await resultIterator.next()).done) {\n      yield next.value;\n    }\n  }\n}\n\n/**\n * Propagates the async sequence that reacts first.\n * @param {AsyncIterable<T>} left First async sequence.\n * @param {AsyncIterable<T>} right Second async sequence.\n * @return {AsyncIterable<T>} An async sequence that surfaces either of the given sequences, whichever reacted first.\n */\nexport function race<TSource>(\n  left: AsyncIterable<TSource>,\n  right: AsyncIterable<TSource>\n): AsyncIterableX<TSource> {\n  return new RaceAsyncIterable<TSource>(left, right);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nclass RangeAsyncIterable extends AsyncIterableX<number> {\n  private _start: number;\n  private _count: number;\n\n  constructor(start: number, count: number) {\n    super();\n    this._start = start;\n    this._count = count;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for (let current = this._start, end = this._start + this._count; current < end; current++) {\n      yield current;\n    }\n  }\n}\n\nexport function range(start: number, count: number): AsyncIterableX<number> {\n  return new RangeAsyncIterable(start, count);\n}\n","export async function reduce<T, R = T>(\n  source: AsyncIterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: never[]\n): Promise<R>;\nexport async function reduce<T, R = T>(\n  source: AsyncIterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: R\n): Promise<R>;\nexport async function reduce<T, R = T>(\n  source: AsyncIterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  ...seed: R[]\n): Promise<R> {\n  const hasSeed = seed.length === 1;\n  let i = 0,\n    hasValue = false,\n    acc = seed[0] as T | R;\n  for await (let item of source) {\n    if (hasValue || (hasValue = hasSeed)) {\n      acc = await accumulator(<R>acc, item, i++);\n    } else {\n      acc = item;\n      hasValue = true;\n      i++;\n    }\n  }\n\n  if (!(hasSeed || hasValue)) {\n    throw new Error('Sequence contains no elements');\n  }\n\n  return acc as R;\n}\n","import { toArray } from './toarray';\nexport async function reduceRight<T, R = T>(\n  source: AsyncIterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: never[]\n): Promise<R>;\nexport async function reduceRight<T, R = T>(\n  source: AsyncIterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: R\n): Promise<R>;\nexport async function reduceRight<T, R = T>(\n  source: AsyncIterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  ...seed: R[]\n): Promise<R> {\n  const array = await toArray(source);\n  const hasSeed = seed.length === 1;\n  let hasValue = false,\n    acc = seed[0] as T | R;\n  for (let offset = array.length - 1; offset >= 0; offset--) {\n    const item = array[offset];\n    if (hasValue || (hasValue = hasSeed)) {\n      acc = await accumulator(<R>acc, item, offset);\n    } else {\n      acc = item;\n      hasValue = true;\n    }\n  }\n\n  if (!(hasSeed || hasValue)) {\n    throw new Error('Sequence contains no elements');\n  }\n\n  return acc as R;\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class RepeatAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _count: number;\n\n  constructor(source: AsyncIterable<TSource>, count: number) {\n    super();\n    this._source = source;\n    this._count = count;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    if (this._count === -1) {\n      while (1) {\n        for await (let item of this._source) {\n          yield item;\n        }\n      }\n    } else {\n      for (let i = 0; i < this._count; i++) {\n        for await (let item of this._source) {\n          yield item;\n        }\n      }\n    }\n  }\n}\n\nexport function repeat<TSource>(\n  source: AsyncIterable<TSource>,\n  count: number = -1\n): AsyncIterableX<TSource> {\n  return new RepeatAsyncIterable<TSource>(source, count);\n}\n\nexport function repeatStatic<TSource>(value: TSource, count: number = -1): AsyncIterableX<TSource> {\n  return new RepeatAsyncIterable<TSource>(AsyncIterableX.of(value), count);\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { repeatStatic } from '../iterable/repeat';\nimport { _catchAll } from './catch';\n\nexport function retry<TSource>(\n  source: AsyncIterable<TSource>,\n  count: number = -1\n): AsyncIterableX<TSource> {\n  return _catchAll<TSource>(repeatStatic<AsyncIterable<TSource>>(source, count));\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class ReverseAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n\n  constructor(source: AsyncIterable<TSource>) {\n    super();\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let results = [] as TSource[];\n    for await (let item of this._source) {\n      results.unshift(item);\n    }\n    yield* results;\n  }\n}\n\nexport function reverse<TSource>(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n  return new ReverseAsyncIterable<TSource>(source);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class ScanAsyncIterable<T, R> extends AsyncIterableX<R> {\n  private _source: AsyncIterable<T>;\n  private _fn: (acc: R, x: T, index: number) => R | Promise<R>;\n  private _seed?: T | R;\n  private _hasSeed: boolean;\n\n  constructor(\n    source: AsyncIterable<T>,\n    fn: (acc: R, x: T, index: number) => R | Promise<R>,\n    seed: R[]\n  ) {\n    super();\n    this._source = source;\n    this._fn = fn;\n    this._hasSeed = seed.length === 1;\n    this._seed = seed[0];\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let i = 0,\n      hasValue = false,\n      acc = this._seed;\n    for await (let item of this._source) {\n      if (hasValue || (hasValue = this._hasSeed)) {\n        acc = await this._fn(<R>acc, item, i++);\n        yield acc;\n      } else {\n        acc = item;\n        hasValue = true;\n        i++;\n      }\n    }\n    if (i === 1 && !this._hasSeed) {\n      yield acc as R;\n    }\n  }\n}\n\nexport function scan<T, R = T>(\n  source: AsyncIterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: never[]\n): AsyncIterableX<R>;\nexport function scan<T, R = T>(\n  source: AsyncIterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: R\n): AsyncIterableX<R>;\nexport function scan<T, R = T>(\n  source: AsyncIterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  ...seed: R[]\n): AsyncIterableX<R> {\n  return new ScanAsyncIterable(source, accumulator, seed);\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { toArray } from './toarray';\n\nexport class ScanRightAsyncIterable<T, R> extends AsyncIterableX<R> {\n  private _source: AsyncIterable<T>;\n  private _fn: (acc: R, x: T, index: number) => R | Promise<R>;\n  private _seed?: T | R;\n  private _hasSeed: boolean;\n\n  constructor(\n    source: AsyncIterable<T>,\n    fn: (acc: R, x: T, index: number) => R | Promise<R>,\n    seed: R[]\n  ) {\n    super();\n    this._source = source;\n    this._fn = fn;\n    this._hasSeed = seed.length === 1;\n    this._seed = seed[0];\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let hasValue = false,\n      acc = this._seed;\n    const source = await toArray(this._source);\n    for (let offset = source.length - 1; offset >= 0; offset--) {\n      const item = source[offset];\n      if (hasValue || (hasValue = this._hasSeed)) {\n        acc = await this._fn(<R>acc, item, offset);\n        yield acc;\n      } else {\n        acc = item;\n        hasValue = true;\n      }\n    }\n  }\n}\n\nexport function scanRight<T, R = T>(\n  source: AsyncIterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: never[]\n): AsyncIterableX<R>;\nexport function scanRight<T, R = T>(\n  source: AsyncIterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: R\n): AsyncIterableX<R>;\nexport function scanRight<T, R = T>(\n  source: AsyncIterable<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  ...seed: R[]\n): AsyncIterableX<R> {\n  return new ScanRightAsyncIterable(source, accumulator, seed);\n}\n","import { comparerAsync } from '../internal/comparer';\n\nexport async function sequenceEqual<T>(\n  source: AsyncIterable<T>,\n  other: AsyncIterable<T>,\n  comparer: (first: T, second: T) => boolean | Promise<boolean> = comparerAsync\n): Promise<boolean> {\n  const it1 = source[Symbol.asyncIterator](),\n    it2 = other[Symbol.asyncIterator]();\n  let next1: IteratorResult<T>, next2: IteratorResult<T>;\n  while (!(next1 = await it1.next()).done) {\n    if (!(!(next2 = await it2.next()).done && (await comparer(next1.value, next2.value)))) {\n      return false;\n    }\n  }\n\n  return (await it2.next()).done;\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { create } from './create';\n\nclass SharedAsyncIterable<T> extends AsyncIterableX<T> {\n  private _it: AsyncIterator<T>;\n\n  constructor(it: AsyncIterator<T>) {\n    super();\n    this._it = it;\n  }\n\n  [Symbol.asyncIterator]() {\n    return this._it;\n  }\n}\n\nexport function share<TSource>(source: AsyncIterable<TSource>): AsyncIterableX<TSource>;\nexport function share<TSource, TResult>(\n  source: AsyncIterable<TSource>,\n  selector?: (\n    value: AsyncIterable<TSource>\n  ) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>\n): AsyncIterableX<TResult>;\nexport function share<TSource, TResult = TSource>(\n  source: AsyncIterable<TSource>,\n  selector?: (\n    value: AsyncIterable<TSource>\n  ) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>\n): AsyncIterableX<TSource | TResult> {\n  return selector\n    ? create<TResult>(async () => {\n        const it = await selector(new SharedAsyncIterable(source[Symbol.asyncIterator]()));\n        return it[Symbol.asyncIterator]();\n      })\n    : new SharedAsyncIterable<TSource>(source[Symbol.asyncIterator]());\n}\n","export async function single<T, S extends T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => value is S\n): Promise<S | undefined>;\nexport async function single<T>(\n  source: AsyncIterable<T>,\n  predicate?: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<T | undefined>;\nexport async function single<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean> = () => true\n): Promise<T | undefined> {\n  let result: T | undefined;\n  let hasResult = false;\n  let i = 0;\n  for await (let item of source) {\n    if (hasResult && (await predicate(item, i++))) {\n      throw new Error('More than one element was found');\n    }\n    if (await predicate(item, i++)) {\n      result = item;\n      hasResult = true;\n    }\n  }\n\n  return result;\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class SkipAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _count: number;\n\n  constructor(source: AsyncIterable<TSource>, count: number) {\n    super();\n    this._source = source;\n    this._count = count;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let it = this._source[Symbol.asyncIterator](),\n      count = this._count,\n      next;\n    while (count > 0 && !(next = await it.next()).done) {\n      count--;\n    }\n    if (count <= 0) {\n      while (!(next = await it.next()).done) {\n        yield next.value;\n      }\n    }\n  }\n}\n\nexport function skip<TSource>(\n  source: AsyncIterable<TSource>,\n  count: number\n): AsyncIterableX<TSource> {\n  return new SkipAsyncIterable<TSource>(source, count);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class SkipLastAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _count: number;\n\n  constructor(source: AsyncIterable<TSource>, count: number) {\n    super();\n    this._source = source;\n    this._count = count;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let q = [] as TSource[];\n    for await (let item of this._source) {\n      q.push(item);\n      if (q.length > this._count) {\n        yield q.shift()!;\n      }\n    }\n  }\n}\n\nexport function skipLast<TSource>(\n  source: AsyncIterable<TSource>,\n  count: number\n): AsyncIterableX<TSource> {\n  return new SkipLastAsyncIterable<TSource>(source, count);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class SkipUntilAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _other: () => Promise<any>;\n\n  constructor(source: AsyncIterable<TSource>, other: () => Promise<any>) {\n    super();\n    this._source = source;\n    this._other = other;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let otherDone = false;\n    this._other().then(() => (otherDone = true));\n    for await (let item of this._source) {\n      if (otherDone) {\n        yield item;\n      }\n    }\n  }\n}\n\nexport function skipUntil<TSource>(\n  source: AsyncIterable<TSource>,\n  other: () => Promise<any>\n): AsyncIterableX<TSource> {\n  return new SkipUntilAsyncIterable<TSource>(source, other);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class SkipWhileAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _predicate: (value: TSource, index: number) => boolean | Promise<boolean>;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    predicate: (value: TSource, index: number) => boolean | Promise<boolean>\n  ) {\n    super();\n    this._source = source;\n    this._predicate = predicate;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let yielding = false,\n      i = 0;\n    for await (let element of this._source) {\n      if (!yielding && !await this._predicate(element, i++)) {\n        yielding = true;\n      }\n      if (yielding) {\n        yield element;\n      }\n    }\n  }\n}\n\nexport function skipWhile<T, S extends T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => value is S\n): AsyncIterableX<S>;\nexport function skipWhile<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): AsyncIterableX<T>;\nexport function skipWhile<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): AsyncIterableX<T> {\n  return new SkipWhileAsyncIterable<T>(source, predicate);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class SliceAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _begin: number;\n  private _end: number;\n\n  constructor(source: AsyncIterable<TSource>, begin: number, end: number) {\n    super();\n    this._source = source;\n    this._begin = begin;\n    this._end = end;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let it = this._source[Symbol.asyncIterator](),\n      begin = this._begin,\n      next;\n    while (begin > 0 && !(next = await it.next()).done) {\n      begin--;\n    }\n\n    let end = this._end;\n    if (end > 0) {\n      while (!(next = await it.next()).done) {\n        yield next.value;\n        if (--end === 0) {\n          break;\n        }\n      }\n    }\n  }\n}\n\nexport function slice<TSource>(\n  source: AsyncIterable<TSource>,\n  begin: number,\n  end: number = Infinity\n): AsyncIterableX<TSource> {\n  return new SliceAsyncIterable<TSource>(source, begin, end);\n}\n","export async function some<T, S extends T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => value is S\n): Promise<boolean>;\nexport async function some<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<boolean>;\nexport async function some<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<boolean> {\n  let i = 0;\n  for await (let item of source) {\n    if (await predicate(item, i++)) {\n      return true;\n    }\n  }\n  return false;\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class StartWithAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _args: TSource[];\n\n  constructor(source: AsyncIterable<TSource>, args: TSource[]) {\n    super();\n    this._source = source;\n    this._args = args;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for (let x of this._args) {\n      yield x;\n    }\n    for await (let item of this._source) {\n      yield item;\n    }\n  }\n}\n\nexport function startWith<TSource>(\n  source: AsyncIterable<TSource>,\n  ...args: TSource[]\n): AsyncIterableX<TSource> {\n  return new StartWithAsyncIterable<TSource>(source, args);\n}\n","import { identityAsync } from '../internal/identity';\n\nexport async function sum(\n  source: AsyncIterable<number>,\n  selector?: (x: number) => number | Promise<number>\n): Promise<number>;\nexport async function sum<T>(\n  source: AsyncIterable<T>,\n  selector: (x: T) => number | Promise<number>\n): Promise<number>;\nexport async function sum(\n  source: AsyncIterable<any>,\n  selector: (x: any) => number | Promise<number> = identityAsync\n): Promise<number> {\n  let sum = 0;\n  for await (let item of source) {\n    sum += await selector(item);\n  }\n\n  return sum;\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class TakeAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _count: number;\n\n  constructor(source: AsyncIterable<TSource>, count: number) {\n    super();\n    this._source = source;\n    this._count = count;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let i = this._count;\n    if (i > 0) {\n      for await (let item of this._source) {\n        yield item;\n        if (--i === 0) {\n          break;\n        }\n      }\n    }\n  }\n}\n\nexport function take<TSource>(\n  source: AsyncIterable<TSource>,\n  count: number\n): AsyncIterableX<TSource> {\n  return new TakeAsyncIterable<TSource>(source, count);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class TakeLastAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _count: number;\n\n  constructor(source: AsyncIterable<TSource>, count: number) {\n    super();\n    this._source = source;\n    this._count = count;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    if (this._count > 0) {\n      let q = [] as TSource[];\n      for await (let item of this._source) {\n        if (q.length >= this._count) {\n          q.shift();\n        }\n        q.push(item);\n      }\n\n      while (q.length > 0) {\n        yield q.shift()!;\n      }\n    }\n  }\n}\n\nexport function takeLast<TSource>(\n  source: AsyncIterable<TSource>,\n  count: number\n): AsyncIterableX<TSource> {\n  return new TakeLastAsyncIterable<TSource>(source, count);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class TakeUntilAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _other: () => Promise<any>;\n\n  constructor(source: AsyncIterable<TSource>, other: () => Promise<any>) {\n    super();\n    this._source = source;\n    this._other = other;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let otherDone = false;\n    this._other().then(() => (otherDone = true));\n    for await (let item of this._source) {\n      if (otherDone) {\n        break;\n      }\n      yield item;\n    }\n  }\n}\n\nexport function takeUntil<TSource>(\n  source: AsyncIterable<TSource>,\n  other: () => Promise<any>\n): AsyncIterableX<TSource> {\n  return new TakeUntilAsyncIterable<TSource>(source, other);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class TakeWhileAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _predicate: (value: TSource, index: number) => boolean | Promise<boolean>;\n\n  constructor(\n    source: AsyncIterable<TSource>,\n    predicate: (value: TSource, index: number) => boolean | Promise<boolean>\n  ) {\n    super();\n    this._source = source;\n    this._predicate = predicate;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let i = 0;\n    for await (let item of this._source) {\n      if (!await this._predicate(item, i++)) {\n        break;\n      }\n      yield item;\n    }\n  }\n}\n\nexport function takeWhile<T, S extends T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => value is S\n): AsyncIterableX<S>;\nexport function takeWhile<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): AsyncIterableX<T>;\nexport function takeWhile<T>(\n  source: AsyncIterable<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): AsyncIterableX<T> {\n  return new TakeWhileAsyncIterable<T>(source, predicate);\n}\n","import { isFunction } from './isiterable';\nimport { Observer, PartialObserver } from '../observer';\n\nconst noop = (_?: any) => {\n  /**/\n};\n\nexport function toObserver<T>(\n  next?: PartialObserver<T> | ((value: T) => void) | null,\n  error?: ((err: any) => void) | null,\n  complete?: (() => void) | null\n): Observer<T> {\n  const observer = next as PartialObserver<T>;\n\n  if (observer && typeof observer === 'object') {\n    return {\n      next: isFunction(observer.next) ? x => observer.next!(x) : noop,\n      error: isFunction(observer.error) ? e => observer.error!(e) : noop,\n      complete: isFunction(observer.complete) ? () => observer.complete!() : noop\n    };\n  }\n\n  return {\n    next: isFunction(next) ? next : noop,\n    error: isFunction(error) ? error : noop,\n    complete: isFunction(complete) ? complete : noop\n  };\n}\n","import { toObserver } from '../internal/toobserver';\nimport { AsyncIterableX } from './asynciterablex';\nimport { PartialAsyncObserver } from '../observer';\n\nexport class TapAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _observer: PartialAsyncObserver<TSource>;\n\n  constructor(source: AsyncIterable<TSource>, observer: PartialAsyncObserver<TSource>) {\n    super();\n    this._source = source;\n    this._observer = observer;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    const it = this._source[Symbol.asyncIterator]();\n    while (1) {\n      let next;\n      try {\n        next = await it.next();\n      } catch (e) {\n        if (this._observer.error) {\n          await this._observer.error(e);\n        }\n        throw e;\n      }\n\n      if (next.done) {\n        if (this._observer.complete) {\n          await this._observer.complete();\n        }\n        break;\n      }\n\n      if (this._observer.next) {\n        await this._observer.next(next.value);\n      }\n      yield next.value;\n    }\n  }\n}\n\nexport function tap<TSource>(\n  source: AsyncIterable<TSource>,\n  observer: PartialAsyncObserver<TSource>\n): AsyncIterableX<TSource>;\n\nexport function tap<TSource>(\n  source: AsyncIterable<TSource>,\n  next?: ((value: TSource) => any) | null,\n  error?: ((err: any) => any) | null,\n  complete?: (() => any) | null\n): AsyncIterableX<TSource>;\n\nexport function tap<TSource>(\n  source: AsyncIterable<TSource>,\n  observerOrNext?: PartialAsyncObserver<TSource> | ((value: TSource) => any) | null,\n  error?: ((err: any) => any) | null,\n  complete?: (() => any) | null\n): AsyncIterableX<TSource> {\n  return new TapAsyncIterable<TSource>(source, toObserver(observerOrNext, error, complete));\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport class ThrottleAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _time: number;\n\n  constructor(source: AsyncIterable<TSource>, time: number) {\n    super();\n    this._source = source;\n    this._time = time;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let currentTime, previousTime;\n    for await (const item of this._source) {\n      currentTime = Date.now();\n      if (!previousTime || currentTime - previousTime > this._time) {\n        previousTime = currentTime;\n        yield item;\n      }\n    }\n  }\n}\n\nexport function throttle<TSource>(\n  source: AsyncIterable<TSource>,\n  time: number\n): AsyncIterableX<TSource> {\n  return new ThrottleAsyncIterable<TSource>(source, time);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport interface TimeInterval<T> {\n  value: T;\n  elapsed: number;\n}\n\nexport class TimeIntervalAsyncIterable<TSource> extends AsyncIterableX<TimeInterval<TSource>> {\n  private _source: AsyncIterable<TSource>;\n\n  constructor(source: AsyncIterable<TSource>) {\n    super();\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let last = Date.now();\n    for await (let item of this._source) {\n      const now = Date.now();\n      const span = now - last;\n      last = now;\n      yield { value: item, elapsed: span };\n    }\n  }\n}\n\nexport function timeInterval<TSource>(\n  source: AsyncIterable<TSource>\n): AsyncIterableX<TimeInterval<TSource>> {\n  return new TimeIntervalAsyncIterable<TSource>(source);\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { sleep } from './_sleep';\n\nexport class TimeoutError extends Error {\n  constructor() {\n    super();\n    Object.setPrototypeOf(this, TimeoutError.prototype);\n    this.message = 'Timeout has occurred';\n  }\n}\n\nconst VALUE_TYPE = 'value';\nconst ERROR_TYPE = 'error';\n\ninterface TimeoutOperation<T> {\n  type: string;\n  value?: IteratorResult<T>;\n}\n\nexport class TimeoutAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _dueTime: number;\n\n  constructor(source: AsyncIterable<TSource>, dueTime: number) {\n    super();\n    this._source = source;\n    this._dueTime = dueTime;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    const it = this._source[Symbol.asyncIterator]();\n    while (1) {\n      const { type, value } = await Promise.race<TimeoutOperation<TSource>>([\n        it.next().then(value => {\n          return { type: VALUE_TYPE, value };\n        }),\n        sleep(this._dueTime).then(() => {\n          return { type: ERROR_TYPE };\n        })\n      ]);\n\n      if (type === ERROR_TYPE) {\n        throw new TimeoutError();\n      }\n\n      if (!value || value.done) {\n        break;\n      }\n      yield value.value;\n    }\n  }\n}\n\nexport function timeout<TSource>(\n  source: AsyncIterable<TSource>,\n  dueTime: number\n): AsyncIterableX<TSource> {\n  return new TimeoutAsyncIterable<TSource>(source, dueTime);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nexport interface Timestamp<TSource> {\n  time: number;\n  value: TSource;\n}\n\nexport class TimestampAsyncIterable<TSource> extends AsyncIterableX<Timestamp<TSource>> {\n  private _source: AsyncIterable<TSource>;\n\n  constructor(source: AsyncIterable<TSource>) {\n    super();\n    this._source = source;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const item of this._source) {\n      yield { time: Date.now(), value: item };\n    }\n  }\n}\n\nexport function timestamp<TSource>(\n  source: AsyncIterable<TSource>\n): AsyncIterableX<Timestamp<TSource>> {\n  return new TimestampAsyncIterable<TSource>(source);\n}\n","import { AsyncIterableX } from './asynciterablex';\n\nclass ThrowAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _error: any;\n\n  constructor(error: any) {\n    super();\n    this._error = error;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<TSource> {\n    throw this._error;\n  }\n}\n\nexport function _throw<TSource>(error: any): AsyncIterableX<TSource> {\n  return new ThrowAsyncIterable<TSource>(error);\n}\n","import { identityAsync } from '../internal/identity';\n\nexport async function toMap<TSource, TKey>(\n  source: AsyncIterable<TSource>,\n  keySelector: (item: TSource) => TKey | Promise<TKey>\n): Promise<Map<TKey, TSource>>;\nexport async function toMap<TSource, TKey, TElement = TSource>(\n  source: AsyncIterable<TSource>,\n  keySelector: (item: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (item: TSource) => TElement | Promise<TElement>\n): Promise<Map<TKey, TElement>>;\nexport async function toMap<TSource, TKey, TElement = TSource>(\n  source: AsyncIterable<TSource>,\n  keySelector: (item: TSource) => TKey | Promise<TKey>,\n  elementSelector: (item: TSource) => TElement | Promise<TElement> = identityAsync\n): Promise<Map<TKey, TElement | TSource>> {\n  let map = new Map<TKey, TElement | TSource>();\n  for await (let item of source) {\n    let value = await elementSelector(item);\n    let key = await keySelector(item);\n    map.set(key, value);\n  }\n  return map;\n}\n","import { Subscription } from './subscription';\n\n// Older versions of Rx will polyfill Symbol.observable, which gets\n// compiled into our UMD bundle. At runtime, our UMD bundle defines its\n// version of Symbol.observable, and since it's not getting it from Rx via\n// `require()` anymore, Rx defines and looks for a different Symbol.observable,\n// instance, leading to mismatches.\n// Assigning the global Symbol.observable to the one we bundle in here means\n// that Rx's polyfill will pick it up. Alternatively if there's already a global\n// Symbol.observable (like if Rx was required first), we should use that one inside Ix.\n\n// Symbol.observable addition\n// Note: This will add Symbol.observable globally for all TypeScript users\ndeclare global {\n  interface SymbolConstructor {\n    readonly observable: symbol;\n  }\n}\n\n// Symbol.observable or a string \"@@observable\". Used for interop.\n// Referenced via string indexer so closure-compiler doesn't mangle.\nexport const observable = (typeof Symbol === 'function' && Symbol.observable) || '@@observable';\n\nexport interface NextObserver<T> {\n  next: (value: T) => any;\n  error?: (err: any) => any;\n  complete?: () => any;\n}\n\nexport interface ErrorObserver<T> {\n  next?: (value: T) => any;\n  error: (err: any) => any;\n  complete?: () => any;\n}\n\nexport interface CompletionObserver<T> {\n  next?: (value: T) => any;\n  error?: (err: any) => any;\n  complete: () => any;\n}\n\nexport type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;\n\nexport interface NextAsyncObserver<T> {\n  next: (value: T) => any | Promise<any>;\n  error?: (err: any) => any | Promise<any>;\n  complete?: () => any | Promise<any>;\n}\n\nexport interface ErrorAsyncObserver<T> {\n  next?: (value: T) => any | Promise<any>;\n  error: (err: any) => any | Promise<any>;\n  complete?: () => any | Promise<any>;\n}\n\nexport interface CompletionAsyncObserver<T> {\n  next?: (value: T) => any | Promise<any>;\n  error?: (err: any) => any | Promise<any>;\n  complete: () => any | Promise<any>;\n}\n\nexport type PartialAsyncObserver<T> =\n  | NextAsyncObserver<T>\n  | ErrorAsyncObserver<T>\n  | CompletionAsyncObserver<T>;\n\nexport interface Observer<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport interface Observable<T> {\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(\n    next?: (value: T) => void,\n    error?: (error: any) => void,\n    complete?: () => void\n  ): Subscription;\n}\n","import { toObserver } from '../internal/toobserver';\nimport { observable as symbolObservable } from '../observer';\nimport { Observable, PartialObserver } from '../observer';\nimport { Subscription } from '../subscription';\n\nclass BooleanSubscription implements Subscription {\n  public isUnsubscribed: boolean = false;\n\n  unsubscribe() {\n    this.isUnsubscribed = true;\n  }\n}\n\nclass AsyncIterableObservable<TSource> implements Observable<TSource> {\n  private _source: AsyncIterable<TSource>;\n\n  constructor(source: AsyncIterable<TSource>) {\n    this._source = source;\n  }\n\n  [symbolObservable](): Observable<TSource> {\n    return this;\n  }\n  subscribe(\n    next?: PartialObserver<TSource> | ((value: TSource) => any) | null,\n    error?: ((err: any) => any) | null,\n    complete?: (() => any) | null\n  ) {\n    const observer = toObserver(next, error, complete);\n    const subscription = new BooleanSubscription();\n\n    const it = this._source[Symbol.asyncIterator]();\n    const f = () => {\n      it.next()\n        .then(({ value, done }) => {\n          if (!subscription.isUnsubscribed) {\n            if (done) {\n              observer.complete();\n            } else {\n              observer.next(value);\n              f();\n            }\n          }\n        })\n        .catch(err => {\n          if (!subscription.isUnsubscribed) {\n            observer.error(err);\n          }\n        });\n    };\n    f();\n\n    return subscription;\n  }\n}\n\nexport function toObservable<TSource>(source: AsyncIterable<TSource>): Observable<TSource> {\n  return new AsyncIterableObservable<TSource>(source);\n}\n","export async function toSet<TSource>(source: AsyncIterable<TSource>): Promise<Set<TSource>> {\n  let set = new Set<TSource>();\n  for await (let item of source) {\n    set.add(item);\n  }\n  return set;\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { arrayIndexOfAsync } from '../internal/arrayindexof';\nimport { comparerAsync } from '../internal/comparer';\n\nexport class UnionAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _left: AsyncIterable<TSource>;\n  private _right: AsyncIterable<TSource>;\n  private _comparer: (x: TSource, y: TSource) => boolean | Promise<boolean>;\n\n  constructor(\n    left: AsyncIterable<TSource>,\n    right: AsyncIterable<TSource>,\n    comparer: (x: TSource, y: TSource) => boolean | Promise<boolean>\n  ) {\n    super();\n    this._left = left;\n    this._right = right;\n    this._comparer = comparer;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let map = [] as TSource[];\n    for await (let lItem of this._left) {\n      if ((await arrayIndexOfAsync(map, lItem, this._comparer)) === -1) {\n        map.push(lItem);\n        yield lItem;\n      }\n    }\n\n    for await (let rItem of this._right) {\n      if ((await arrayIndexOfAsync(map, rItem, this._comparer)) === -1) {\n        map.push(rItem);\n        yield rItem;\n      }\n    }\n  }\n}\n\nexport function union<TSource>(\n  left: AsyncIterable<TSource>,\n  right: AsyncIterable<TSource>,\n  comparer: (x: TSource, y: TSource) => boolean | Promise<boolean> = comparerAsync\n): AsyncIterableX<TSource> {\n  return new UnionAsyncIterable<TSource>(left, right, comparer);\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { identityAsync } from '../internal/identity';\nimport { returnAsyncIterator } from '../internal/returniterator';\n\nexport class ZipAsyncIterable<TSource, TResult> extends AsyncIterableX<TResult> {\n  private _sources: AsyncIterable<TSource>[];\n  private _fn: (values: any[]) => TResult | Promise<TResult>;\n\n  constructor(\n    sources: AsyncIterable<TSource>[],\n    fn: (values: any[]) => TResult | Promise<TResult>\n  ) {\n    super();\n    this._sources = sources;\n    this._fn = fn;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterableIterator<TResult> {\n    const fn = this._fn;\n    const sourcesLength = this._sources.length;\n    const its = this._sources.map(x => x[Symbol.asyncIterator]());\n    while (sourcesLength > 0) {\n      const values = new Array(sourcesLength);\n      for (let i = -1; ++i < sourcesLength; ) {\n        const result = await its[i].next();\n        if (result.done) {\n          await Promise.all(its.map(returnAsyncIterator));\n          return undefined;\n        }\n        values[i] = result.value;\n      }\n      yield await fn(values);\n    }\n  }\n}\n\nexport function zip<T, T2>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>\n): AsyncIterableX<[T, T2]>;\nexport function zip<T, T2, T3>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): AsyncIterableX<[T, T2, T3]>;\nexport function zip<T, T2, T3, T4>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): AsyncIterableX<[T, T2, T3, T4]>;\nexport function zip<T, T2, T3, T4, T5>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): AsyncIterableX<[T, T2, T3, T4, T5]>;\nexport function zip<T, T2, T3, T4, T5, T6>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): AsyncIterableX<[T, T2, T3, T4, T5, T6]>;\n\nexport function zip<T, R>(\n  project: (values: [T]) => R | Promise<R>,\n  source: AsyncIterable<T>\n): AsyncIterableX<R>;\nexport function zip<T, T2, R>(\n  project: (values: [T, T2]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>\n): AsyncIterableX<R>;\nexport function zip<T, T2, T3, R>(\n  project: (values: [T, T2, T3]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): AsyncIterableX<R>;\nexport function zip<T, T2, T3, T4, R>(\n  project: (values: [T, T2, T3, T4]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): AsyncIterableX<R>;\nexport function zip<T, T2, T3, T4, T5, R>(\n  project: (values: [T, T2, T3, T4, T5]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): AsyncIterableX<R>;\nexport function zip<T, T2, T3, T4, T5, T6, R>(\n  project: (values: [T, T2, T3, T4, T5, T6]) => R | Promise<R>,\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): AsyncIterableX<R>;\n\nexport function zip<T>(...sources: AsyncIterable<T>[]): AsyncIterableX<T[]>;\nexport function zip<T, R>(\n  project: (values: T[]) => R | Promise<R>,\n  ...sources: AsyncIterable<T>[]\n): AsyncIterableX<R>;\n/* tslint:enable:max-line-length */\nexport function zip<T, R>(...sources: any[]): AsyncIterableX<R> {\n  let fn = (sources.shift() || identityAsync) as (values: any[]) => R | Promise<R>;\n  if (fn && typeof fn !== 'function') {\n    sources.unshift(fn);\n    fn = identityAsync;\n  }\n  return new ZipAsyncIterable<T, R>(sources as AsyncIterable<T>[], fn);\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { BufferAsyncIterable } from '../buffer';\n\nexport function buffer<TSource>(\n  count: number,\n  skip?: number\n): OperatorAsyncFunction<TSource, TSource[]> {\n  if (skip == null) {\n    skip = count;\n  }\n  return function bufferOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource[]> {\n    return new BufferAsyncIterable<TSource>(source, count, skip!);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { CatchAllAsyncIterable } from '../catch';\n\nexport function _catch<T>(...args: AsyncIterable<T>[]): MonoTypeOperatorAsyncFunction<T> {\n  return function catchOperatorFunction(source: AsyncIterable<T>): AsyncIterableX<T> {\n    return new CatchAllAsyncIterable<T>([source, ...args]);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { CatchWithAsyncIterable } from '../catchwith';\n\nexport function catchWith<TSource>(\n  handler: (error: any) => AsyncIterable<TSource> | Promise<AsyncIterable<TSource>>\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function catchWithOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new CatchWithAsyncIterable<TSource>(source, handler);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { ConcatAsyncIterable } from '../concat';\n\n/* tslint:disable:max-line-length */\nexport function concat<T, T2>(v2: AsyncIterable<T2>): MonoTypeOperatorAsyncFunction<T | T2>;\nexport function concat<T, T2, T3>(\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>\n): MonoTypeOperatorAsyncFunction<T | T2 | T3>;\nexport function concat<T, T2, T3, T4>(\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>\n): MonoTypeOperatorAsyncFunction<T | T2 | T3 | T4>;\nexport function concat<T, T2, T3, T4, T5>(\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>\n): MonoTypeOperatorAsyncFunction<T | T2 | T3 | T4 | T5>;\nexport function concat<T, T2, T3, T4, T5, T6>(\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>,\n  v6: AsyncIterable<T6>\n): MonoTypeOperatorAsyncFunction<T | T2 | T3 | T4 | T5 | T6>;\n/* tslint:enable:max-line-length */\n\nexport function concat<T>(...args: AsyncIterable<T>[]): MonoTypeOperatorAsyncFunction<T> {\n  return function concatOperatorFunction(source: AsyncIterable<T>): AsyncIterableX<T> {\n    return new ConcatAsyncIterable<T>([source, ...args]);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { ConcatAllAsyncIterable } from '../concatall';\n\nexport function concatAll<T>(): OperatorAsyncFunction<AsyncIterable<T>, T> {\n  return function concatAllOperatorFunction(\n    source: AsyncIterable<AsyncIterable<T>>\n  ): AsyncIterableX<T> {\n    return new ConcatAllAsyncIterable<T>(source);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { DebounceAsyncIterable } from '../debounce';\n\nexport function debounce<TSource>(time: number): MonoTypeOperatorAsyncFunction<TSource> {\n  return function debounceOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new DebounceAsyncIterable<TSource>(source, time);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { DefaultIfEmptyAsyncIterable } from '../defaultifempty';\n\nexport function defaultIfEmpty<T>(defaultValue: T): MonoTypeOperatorAsyncFunction<T> {\n  return function defaultIfEmptyOperatorFunction(source: AsyncIterable<T>): AsyncIterableX<T> {\n    return new DefaultIfEmptyAsyncIterable<T>(source, defaultValue);\n  };\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { sleep } from './_sleep';\n\nexport class DelayAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _dueTime: number;\n\n  constructor(source: AsyncIterable<TSource>, dueTime: number) {\n    super();\n    this._source = source;\n    this._dueTime = dueTime;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    await sleep(this._dueTime);\n    for await (const item of this._source) {\n      yield item;\n    }\n  }\n}\n\nexport function delay<TSource>(\n  source: AsyncIterable<TSource>,\n  dueTime: number\n): AsyncIterableX<TSource> {\n  return new DelayAsyncIterable<TSource>(source, dueTime);\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { DelayAsyncIterable } from '../delay';\n\nexport function delay<TSource>(dueTime: number): MonoTypeOperatorAsyncFunction<TSource> {\n  return function delayOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new DelayAsyncIterable<TSource>(source, dueTime);\n  };\n}\n","import { AsyncIterableX } from './asynciterablex';\nimport { sleep } from './_sleep';\n\nexport class DelayEachAsyncIterable<TSource> extends AsyncIterableX<TSource> {\n  private _source: AsyncIterable<TSource>;\n  private _dueTime: number;\n\n  constructor(source: AsyncIterable<TSource>, dueTime: number) {\n    super();\n    this._source = source;\n    this._dueTime = dueTime;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const item of this._source) {\n      await sleep(this._dueTime);\n      yield item;\n    }\n  }\n}\n\nexport function delayEach<TSource>(\n  source: AsyncIterable<TSource>,\n  dueTime: number\n): AsyncIterableX<TSource> {\n  return new DelayEachAsyncIterable<TSource>(source, dueTime);\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { DelayEachAsyncIterable } from '../delayeach';\n\nexport function delayEach<TSource>(dueTime: number): MonoTypeOperatorAsyncFunction<TSource> {\n  return function delayEachOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new DelayEachAsyncIterable<TSource>(source, dueTime);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { DistinctAsyncIterable } from '../distinct';\nimport { identityAsync } from '../../internal/identity';\nimport { comparerAsync } from '../../internal/comparer';\n\nexport function distinct<TSource, TKey>(\n  keySelector: (value: TSource) => TKey | Promise<TKey> = identityAsync,\n  comparer: (x: TKey, y: TKey) => boolean | Promise<boolean> = comparerAsync\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function distinctOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new DistinctAsyncIterable<TSource, TKey>(source, keySelector, comparer);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { DistinctUntilChangedAsyncIterable } from '../distinctuntilchanged';\nimport { identityAsync } from '../../internal/identity';\nimport { comparerAsync } from '../../internal/comparer';\n\nexport function distinctUntilChanged<TSource, TKey>(\n  keySelector: (value: TSource) => TKey | Promise<TKey> = identityAsync,\n  comparer: (first: TKey, second: TKey) => boolean | Promise<boolean> = comparerAsync\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function distinctUntilChangedOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new DistinctUntilChangedAsyncIterable<TSource, TKey>(source, keySelector, comparer);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { concatStatic } from '../concat';\nimport { _while } from '../while';\n\nexport function doWhile<TSource>(\n  condition: () => boolean | Promise<boolean>\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function doWhileOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return concatStatic(source, _while(condition, source));\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { EndWithAsyncIterable } from '../endwith';\n\nexport function endWith<TSource>(...args: TSource[]): MonoTypeOperatorAsyncFunction<TSource> {\n  return function endsWithOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new EndWithAsyncIterable<TSource>(source, args);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { ExceptAsyncIterable } from '../except';\nimport { comparerAsync } from '../../internal/comparer';\n\nexport function except<TSource>(\n  second: AsyncIterable<TSource>,\n  comparer: (x: TSource, y: TSource) => boolean | Promise<boolean> = comparerAsync\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function exceptOperatorFunction(first: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new ExceptAsyncIterable<TSource>(first, second, comparer);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { ExpandAsyncIterable } from '../expand';\n\nexport function expand<TSource>(\n  selector: (value: TSource) => AsyncIterable<TSource> | Promise<AsyncIterable<TSource>>\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function expandOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new ExpandAsyncIterable<TSource>(source, selector);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { FilterAsyncIterable } from '../filter';\nimport { bindCallback } from '../../internal/bindcallback';\n\nexport function filter<T, S extends T>(\n  predicate: (value: T, index: number) => value is S,\n  thisArg?: any\n): OperatorAsyncFunction<T, S>;\nexport function filter<T>(\n  predicate: (value: T, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): OperatorAsyncFunction<T, T>;\nexport function filter<TSource>(\n  predicate: (value: TSource, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): OperatorAsyncFunction<TSource, TSource> {\n  return function filterOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new FilterAsyncIterable<TSource>(source, bindCallback(predicate, thisArg, 2));\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { FinallyAsyncIterable } from '../finally';\n\nexport function _finally<TSource>(\n  action: () => any | Promise<any>\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function finallyOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new FinallyAsyncIterable<TSource>(source, action);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { FlatMapAsyncIterable } from '../flatmap';\nimport { bindCallback } from '../../internal/bindcallback';\n\nexport function flatMap<TSource, TResult>(\n  selector: (value: TSource) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>,\n  thisArg?: any\n): OperatorAsyncFunction<TSource, TResult> {\n  return function flatMapOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TResult> {\n    return new FlatMapAsyncIterable<TSource, TResult>(source, bindCallback(selector, thisArg, 1));\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { FlattenAsyncIterable } from '../flatten';\n\nexport function flatten<T>(depth: number = Infinity): MonoTypeOperatorAsyncFunction<T> {\n  return function flattenOperatorFunction(source: AsyncIterable<T>): AsyncIterableX<T> {\n    return new FlattenAsyncIterable<T>(source, depth);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { GroupByAsyncIterable, GroupedAsyncIterable, groupByResultIdentityAsync } from '../groupby';\nimport { identityAsync } from '../../internal/identity';\n\nexport function groupBy<TSource, TKey>(\n  keySelector: (value: TSource) => TKey | Promise<TKey>\n): OperatorAsyncFunction<TSource, GroupedAsyncIterable<TKey, TSource>>;\nexport function groupBy<TSource, TKey, TValue>(\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (value: TSource) => TValue | Promise<TValue>\n): OperatorAsyncFunction<TSource, GroupedAsyncIterable<TKey, TValue>>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (value: TSource) => TValue | Promise<TValue>,\n  resultSelector?: (key: TKey, values: Iterable<TValue>) => TResult | Promise<TResult>\n): OperatorAsyncFunction<TSource, TResult>;\nexport function groupBy<TSource, TKey, TValue, TResult>(\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector: (value: TSource) => TValue | Promise<TValue> = identityAsync,\n  resultSelector: (\n    key: TKey,\n    values: Iterable<TValue>\n  ) => TResult | Promise<TResult> = groupByResultIdentityAsync\n): OperatorAsyncFunction<TSource, TResult> {\n  return function groupByOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TResult> {\n    return new GroupByAsyncIterable<TSource, TKey, TValue, TResult>(\n      source,\n      keySelector,\n      elementSelector,\n      resultSelector\n    );\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { GroupJoinAsyncIterable } from '../groupjoin';\n\nexport function groupJoin<TOuter, TInner, TKey, TResult>(\n  inner: AsyncIterable<TInner>,\n  outerSelector: (value: TOuter) => TKey | Promise<TKey>,\n  innerSelector: (value: TInner) => TKey | Promise<TKey>,\n  resultSelector: (outer: TOuter, inner: AsyncIterable<TInner>) => TResult | Promise<TResult>\n): OperatorAsyncFunction<TOuter, TResult> {\n  return function groupJoinOperatorFunction(outer: AsyncIterable<TOuter>): AsyncIterableX<TResult> {\n    return new GroupJoinAsyncIterable<TOuter, TInner, TKey, TResult>(\n      outer,\n      inner,\n      outerSelector,\n      innerSelector,\n      resultSelector\n    );\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { IgnoreElementsAsyncIterable } from '../ignoreelements';\n\nexport function ignoreElements<TSource>(): MonoTypeOperatorAsyncFunction<TSource> {\n  return function ignoreElementsOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new IgnoreElementsAsyncIterable<TSource>(source);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { JoinAsyncIterable } from '../innerjoin';\n\nexport function innerJoin<TOuter, TInner, TKey, TResult>(\n  inner: AsyncIterable<TInner>,\n  outerSelector: (value: TOuter) => TKey | Promise<TKey>,\n  innerSelector: (value: TInner) => TKey | Promise<TKey>,\n  resultSelector: (outer: TOuter, inner: TInner) => TResult | Promise<TResult>\n): OperatorAsyncFunction<TOuter, TResult> {\n  return function innerJoinOperatorFunction(outer: AsyncIterable<TOuter>): AsyncIterableX<TResult> {\n    return new JoinAsyncIterable<TOuter, TInner, TKey, TResult>(\n      outer,\n      inner,\n      outerSelector,\n      innerSelector,\n      resultSelector\n    );\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { IntersectAsyncIterable } from '../intersect';\nimport { comparerAsync } from '../../internal/comparer';\n\nexport function intersect<TSource>(\n  second: AsyncIterable<TSource>,\n  comparer: (x: TSource, y: TSource) => boolean | Promise<boolean> = comparerAsync\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function intersectOperatorFunction(\n    first: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new IntersectAsyncIterable<TSource>(first, second, comparer);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { MapAsyncIterable } from '../map';\nimport { bindCallback } from '../../internal/bindcallback';\n\nexport function map<TSource, TResult>(\n  selector: (value: TSource, index: number) => Promise<TResult> | TResult,\n  thisArg?: any\n): OperatorAsyncFunction<TSource, TResult> {\n  return function mapOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TResult> {\n    return new MapAsyncIterable<TSource, TResult>(source, bindCallback(selector, thisArg, 2));\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { extremaBy, defaultCompareAsync } from '../_extremaby';\n\nexport function maxBy<TSource, TKey>(\n  keySelector: (x: TSource) => TKey | Promise<TKey>,\n  comparer: (x: TKey, y: TKey) => number | Promise<number> = defaultCompareAsync\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function maxByOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return extremaBy(source, keySelector, comparer);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { memoize as memoizeStatic } from '../memoize';\n\nexport function memoize<TSource>(readerCount?: number): OperatorAsyncFunction<TSource, TSource>;\nexport function memoize<TSource, TResult>(\n  readerCount?: number,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): OperatorAsyncFunction<TSource, TResult>;\nexport function memoize<TSource, TResult = TSource>(\n  readerCount: number = -1,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): OperatorAsyncFunction<TSource, TSource | TResult> {\n  return function memoizeOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource | TResult> {\n    return memoizeStatic(source, readerCount, selector);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { MergeAsyncIterable } from '../merge';\n\n/* tslint:disable:max-line-length */\nexport function merge<T, T2>(v2: AsyncIterable<T2>): MonoTypeOperatorAsyncFunction<T | T2>;\nexport function merge<T, T2, T3>(\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>\n): MonoTypeOperatorAsyncFunction<T | T2 | T3>;\nexport function merge<T, T2, T3, T4>(\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>\n): MonoTypeOperatorAsyncFunction<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4, T5>(\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>\n): MonoTypeOperatorAsyncFunction<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5, T6>(\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>,\n  v6: AsyncIterable<T6>\n): MonoTypeOperatorAsyncFunction<T | T2 | T3 | T4 | T5 | T6>;\n/* tslint:enable:max-line-length */\n\nexport function merge<T>(...args: AsyncIterable<T>[]): MonoTypeOperatorAsyncFunction<T> {\n  return function mergeOperatorFunction(source: AsyncIterable<T>): AsyncIterableX<T> {\n    return new MergeAsyncIterable<T>([source, ...args]);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { flatMap } from '../flatmap';\n\nexport function mergeAll<TSource>(): OperatorAsyncFunction<AsyncIterable<TSource>, TSource> {\n  return function mergeAllOperatorFunction(\n    source: AsyncIterable<AsyncIterable<TSource>>\n  ): AsyncIterableX<TSource> {\n    return flatMap(source, source => source);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { extremaBy, defaultCompareAsync } from '../_extremaby';\n\nexport function minBy<TSource, TKey>(\n  keySelector: (x: TSource) => TKey | Promise<TKey>,\n  comparer: (x: TKey, y: TKey) => number | Promise<number> = defaultCompareAsync\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function minByOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return extremaBy(source, keySelector, async (key, minValue) => -await comparer(key, minValue));\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { OnErrorResumeNextAsyncIterable } from '../onerrorresumenext';\n\nexport function onErrorResumeNext<T>(\n  ...args: AsyncIterable<T>[]\n): MonoTypeOperatorAsyncFunction<T> {\n  return function onErrorResumeNextOperatorFunction(source: AsyncIterable<T>): AsyncIterableX<T> {\n    return new OnErrorResumeNextAsyncIterable<T>([source, ...args]);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { OrderedAsyncIterableX, OrderedAsyncIterableBaseX } from '../orderby';\nimport { sorter as defaultSorter } from '../../internal/sorter';\n\nexport function orderBy<TKey, TSource>(\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function orderByOperatorFunction(source: AsyncIterable<TSource>) {\n    return new OrderedAsyncIterableX<TKey, TSource>(source, keySelector, comparer, false);\n  };\n}\n\nexport function orderByDescending<TKey, TSource>(\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function orderByDescendingOperatorFunction(source: AsyncIterable<TSource>) {\n    return new OrderedAsyncIterableX<TKey, TSource>(source, keySelector, comparer, true);\n  };\n}\n\nexport function thenBy<TKey, TSource>(\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function thenByOperatorFunction(source: AsyncIterable<TSource>) {\n    const orderSource = <OrderedAsyncIterableBaseX<TSource>>source;\n    return new OrderedAsyncIterableX<TKey, TSource>(\n      orderSource._source,\n      keySelector,\n      comparer,\n      false,\n      orderSource\n    );\n  };\n}\n\nexport function thenByDescending<TKey, TSource>(\n  keySelector: (item: TSource) => TKey,\n  comparer: (fst: TKey, snd: TKey) => number = defaultSorter\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function thenByDescendingOperatorFunction(source: AsyncIterable<TSource>) {\n    const orderSource = <OrderedAsyncIterableBaseX<TSource>>source;\n    return new OrderedAsyncIterableX<TKey, TSource>(\n      orderSource._source,\n      keySelector,\n      comparer,\n      true,\n      orderSource\n    );\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { PairwiseAsyncIterable } from '../pairwise';\n\nexport function pairwise<TSource>(): OperatorAsyncFunction<TSource, TSource[]> {\n  return function pairwiseOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource[]> {\n    return new PairwiseAsyncIterable<TSource>(source);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { pluck as pluckStatic } from '../pluck';\n\nexport function pluck<TSource, TResult>(\n  ...args: string[]\n): OperatorAsyncFunction<TSource, TResult> {\n  return function pluckOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TResult> {\n    return pluckStatic(source, ...args);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { publish as publishStatic } from '../publish';\n\nexport function publish<TSource>(): OperatorAsyncFunction<TSource, TSource>;\nexport function publish<TSource, TResult>(\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): OperatorAsyncFunction<TSource, TResult>;\nexport function publish<TSource, TResult>(\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): OperatorAsyncFunction<TSource, TSource | TResult> {\n  return function publishOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource | TResult> {\n    return publishStatic(source, selector);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { RepeatAsyncIterable } from '../repeat';\n\nexport function repeat<TSource>(count: number = -1): MonoTypeOperatorAsyncFunction<TSource> {\n  return function repeatOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new RepeatAsyncIterable<TSource>(source, count);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { retry as retryStatic } from '../retry';\n\nexport function retry<TSource>(count: number = -1): MonoTypeOperatorAsyncFunction<TSource> {\n  return function retryOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return retryStatic<TSource>(source, count);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { ReverseAsyncIterable } from '../reverse';\n\nexport function reverse<TSource>(): MonoTypeOperatorAsyncFunction<TSource> {\n  return function reverseOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new ReverseAsyncIterable<TSource>(source);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { ScanAsyncIterable } from '../scan';\n\nexport function scan<T, R = T>(\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: never[]\n): OperatorAsyncFunction<T, R>;\nexport function scan<T, R = T>(\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: R\n): OperatorAsyncFunction<T, R>;\nexport function scan<T, R = T>(\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  ...seed: R[]\n): OperatorAsyncFunction<T, R> {\n  return function scanOperatorFunction(source: AsyncIterable<T>): AsyncIterableX<R> {\n    return new ScanAsyncIterable(source, accumulator, seed);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { ScanRightAsyncIterable } from '../scanright';\n\nexport function scanRight<T, R = T>(\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: never[]\n): OperatorAsyncFunction<T, R>;\nexport function scanRight<T, R = T>(\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: R\n): OperatorAsyncFunction<T, R>;\nexport function scanRight<T, R = T>(\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  ...seed: R[]\n): OperatorAsyncFunction<T, R> {\n  return function scanRightOperatorFunction(source: AsyncIterable<T>): AsyncIterableX<R> {\n    return new ScanRightAsyncIterable(source, accumulator, seed);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { share as shareStatic } from '../share';\n\nexport function share<TSource>(): OperatorAsyncFunction<TSource, TSource>;\nexport function share<TSource, TResult>(\n  selector?: (\n    value: AsyncIterable<TSource>\n  ) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>\n): OperatorAsyncFunction<TSource, TResult>;\nexport function share<TSource, TResult = TSource>(\n  selector?: (\n    value: AsyncIterable<TSource>\n  ) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>\n): OperatorAsyncFunction<TSource, TSource | TResult> {\n  return function shareOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource | TResult> {\n    return shareStatic<TSource, TResult>(source, selector);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { SkipAsyncIterable } from '../skip';\n\nexport function skip<TSource>(count: number): MonoTypeOperatorAsyncFunction<TSource> {\n  return function skipOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new SkipAsyncIterable<TSource>(source, count);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { SkipLastAsyncIterable } from '../skiplast';\n\nexport function skipLast<TSource>(count: number): MonoTypeOperatorAsyncFunction<TSource> {\n  return function skipLastOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new SkipLastAsyncIterable<TSource>(source, count);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { SkipUntilAsyncIterable } from '../skipuntil';\n\nexport function skipUntil<TSource>(\n  other: () => Promise<any>\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function skipUntilOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new SkipUntilAsyncIterable<TSource>(source, other);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { SkipWhileAsyncIterable } from '../skipwhile';\n\nexport function skipWhile<T, S extends T>(\n  predicate: (value: T, index: number) => value is S\n): OperatorAsyncFunction<T, S>;\nexport function skipWhile<T>(\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): OperatorAsyncFunction<T, T>;\nexport function skipWhile<T>(\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): OperatorAsyncFunction<T, T> {\n  return function skipWhileOperatorFunction(source: AsyncIterable<T>): AsyncIterableX<T> {\n    return new SkipWhileAsyncIterable<T>(source, predicate);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { SliceAsyncIterable } from '../slice';\n\nexport function slice<TSource>(\n  begin: number,\n  end: number = Infinity\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function sliceOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new SliceAsyncIterable<TSource>(source, begin, end);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { StartWithAsyncIterable } from '../startwith';\n\nexport function startWith<TSource>(...args: TSource[]): MonoTypeOperatorAsyncFunction<TSource> {\n  return function startWithOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new StartWithAsyncIterable<TSource>(source, args);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { TakeAsyncIterable } from '../take';\n\nexport function take<TSource>(count: number): MonoTypeOperatorAsyncFunction<TSource> {\n  return function takeOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new TakeAsyncIterable<TSource>(source, count);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { TakeLastAsyncIterable } from '../takelast';\n\nexport function takeLast<TSource>(count: number): MonoTypeOperatorAsyncFunction<TSource> {\n  return function takeLastOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new TakeLastAsyncIterable<TSource>(source, count);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { TakeUntilAsyncIterable } from '../takeuntil';\n\nexport function takeUntil<TSource>(\n  other: () => Promise<any>\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function takeUntilOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new TakeUntilAsyncIterable<TSource>(source, other);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { TakeWhileAsyncIterable } from '../takewhile';\n\nexport function takeWhile<T, S extends T>(\n  predicate: (value: T, index: number) => value is S\n): OperatorAsyncFunction<T, S>;\nexport function takeWhile<T>(\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): OperatorAsyncFunction<T, T>;\nexport function takeWhile<T>(\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): OperatorAsyncFunction<T, T> {\n  return function takeWhileOperatorFunction(source: AsyncIterable<T>): AsyncIterableX<T> {\n    return new TakeWhileAsyncIterable<T>(source, predicate);\n  };\n}\n","import { toObserver } from '../../internal/toobserver';\nimport { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { TapAsyncIterable } from '../tap';\nimport { PartialAsyncObserver } from '../../observer';\n\nexport function tap<TSource>(\n  observer: PartialAsyncObserver<TSource>\n): MonoTypeOperatorAsyncFunction<TSource>;\n\nexport function tap<TSource>(\n  next?: ((value: TSource) => any) | null,\n  error?: ((err: any) => any) | null,\n  complete?: (() => any) | null\n): MonoTypeOperatorAsyncFunction<TSource>;\n\nexport function tap<TSource>(\n  observerOrNext?: PartialAsyncObserver<TSource> | ((value: TSource) => any) | null,\n  error?: ((err: any) => any) | null,\n  complete?: (() => any) | null\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function tapOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new TapAsyncIterable<TSource>(source, toObserver(observerOrNext, error, complete));\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { ThrottleAsyncIterable } from '../throttle';\n\nexport function throttle<TSource>(time: number): MonoTypeOperatorAsyncFunction<TSource> {\n  return function throttleOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TSource> {\n    return new ThrottleAsyncIterable<TSource>(source, time);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { TimeIntervalAsyncIterable, TimeInterval } from '../timeinterval';\n\nexport function timeInterval<TSource>(): OperatorAsyncFunction<TSource, TimeInterval<TSource>> {\n  return function timeIntervalOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<TimeInterval<TSource>> {\n    return new TimeIntervalAsyncIterable<TSource>(source);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { TimeoutAsyncIterable } from '../timeout';\n\nexport function timeout<TSource>(dueTime: number): MonoTypeOperatorAsyncFunction<TSource> {\n  return function timeoutOperatorFunction(source: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new TimeoutAsyncIterable<TSource>(source, dueTime);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { TimestampAsyncIterable, Timestamp } from '../timestamp';\n\nexport function timestamp<TSource>(): OperatorAsyncFunction<TSource, Timestamp<TSource>> {\n  return function timestampOperatorFunction(\n    source: AsyncIterable<TSource>\n  ): AsyncIterableX<Timestamp<TSource>> {\n    return new TimestampAsyncIterable<TSource>(source);\n  };\n}\n","import {\n  toDOMStream as toDOMStreamOperator,\n  ReadableBYOBStreamOptions,\n  ReadableByteStreamOptions\n} from '../../asynciterable/todomstream';\n\nimport { UnaryFunction } from '../../interfaces';\n\nexport function toDOMStream<T>(\n  strategy?: QueuingStrategy<T>\n): UnaryFunction<AsyncIterable<T>, ReadableStream<T>>;\nexport function toDOMStream<T>(\n  options: ReadableBYOBStreamOptions<Uint8Array>\n): UnaryFunction<AsyncIterable<T>, ReadableStream<Uint8Array>>;\nexport function toDOMStream<T>(\n  options: ReadableByteStreamOptions<Uint8Array>\n): UnaryFunction<AsyncIterable<T>, ReadableStream<Uint8Array>>;\nexport function toDOMStream(\n  options?: QueuingStrategy<any> | ReadableBYOBStreamOptions | ReadableByteStreamOptions\n) {\n  return function toDOMStreamOperatorFunction(source: AsyncIterable<any>) {\n    if (!options || !('type' in options) || options['type'] !== 'bytes') {\n      return toDOMStreamOperator(source, options as QueuingStrategy<any> | undefined);\n    }\n    return toDOMStreamOperator(source, options as\n      | ReadableBYOBStreamOptions\n      | ReadableByteStreamOptions);\n  };\n}\n","import { MonoTypeOperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { UnionAsyncIterable } from '../union';\nimport { comparerAsync } from '../../internal/comparer';\n\nexport function union<TSource>(\n  right: AsyncIterable<TSource>,\n  comparer: (x: TSource, y: TSource) => boolean | Promise<boolean> = comparerAsync\n): MonoTypeOperatorAsyncFunction<TSource> {\n  return function unionOperatorFunction(left: AsyncIterable<TSource>): AsyncIterableX<TSource> {\n    return new UnionAsyncIterable<TSource>(left, right, comparer);\n  };\n}\n","import { OperatorAsyncFunction } from '../../interfaces';\nimport { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { ZipAsyncIterable } from '../zip';\nimport { identityAsync } from '../../internal/identity';\n\nexport function zip<T, T2>(\n  source: AsyncIterable<T>,\n  source2: AsyncIterable<T2>\n): OperatorAsyncFunction<T, [T, T2]>;\nexport function zip<T, T2, T3>(\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): OperatorAsyncFunction<T, [T, T2, T3]>;\nexport function zip<T, T2, T3, T4>(\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): OperatorAsyncFunction<T, [T, T2, T3, T4]>;\nexport function zip<T, T2, T3, T4, T5>(\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): OperatorAsyncFunction<T, [T, T2, T3, T4, T5]>;\nexport function zip<T, T2, T3, T4, T5, T6>(\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): OperatorAsyncFunction<T, [T, T2, T3, T4, T5, T6]>;\n\nexport function zip<T, T2, R>(\n  project: (values: [T, T2]) => R | Promise<R>,\n  source2: AsyncIterable<T2>\n): OperatorAsyncFunction<T, R>;\nexport function zip<T, T2, T3, R>(\n  project: (values: [T, T2, T3]) => R | Promise<R>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): OperatorAsyncFunction<T, R>;\nexport function zip<T, T2, T3, T4, R>(\n  project: (values: [T, T2, T3, T4]) => R | Promise<R>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): OperatorAsyncFunction<T, R>;\nexport function zip<T, T2, T3, T4, T5, R>(\n  project: (values: [T, T2, T3, T4, T5]) => R | Promise<R>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): OperatorAsyncFunction<T, R>;\nexport function zip<T, T2, T3, T4, T5, T6, R>(\n  project: (values: [T, T2, T3, T4, T5, T6]) => R | Promise<R>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): OperatorAsyncFunction<T, R>;\n\nexport function zip<T>(...sources: AsyncIterable<T>[]): OperatorAsyncFunction<T, T[]>;\nexport function zip<T, R>(\n  project: (values: T[]) => R | Promise<R>,\n  ...sources: AsyncIterable<T>[]\n): OperatorAsyncFunction<T, R>;\n/* tslint:enable:max-line-length */\nexport function zip<T, R>(...sources: any[]): OperatorAsyncFunction<T, R> {\n  return function zipOperatorFunction(source: AsyncIterable<T>): AsyncIterableX<R> {\n    let fn = (sources.shift() || identityAsync) as (values: any[]) => R | Promise<R>;\n    if (fn && typeof fn !== 'function') {\n      sources.unshift(fn);\n      fn = identityAsync;\n    }\n    return new ZipAsyncIterable<T, R>([source, ...sources] as AsyncIterable<T>[], fn);\n  };\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { _case as caseStatic } from '../../iterable/case';\n\n/** @nocollapse */\nIterableX.case = caseStatic;\n\nexport declare namespace iterable {\n  let _case: typeof caseStatic;\n}\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export { caseStatic as case }; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { _catchStatic as catchStatic } from '../../iterable/catch';\n\n/** @nocollapse */\nIterableX.catch = catchStatic;\n\nexport declare namespace iterable {\n  let _catchStatic: typeof catchStatic;\n}\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export { catchStatic as catch }; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { concatStatic } from '../../iterable/concat';\n\n/** @nocollapse */\nIterableX.concat = concatStatic;\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export let concat: typeof concatStatic; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { create as createStatic } from '../../iterable/create';\n\n/** @nocollapse */\nIterableX.create = createStatic;\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export let create: typeof createStatic; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { defer as deferStatic } from '../../iterable/defer';\n\n/** @nocollapse */\nIterableX.defer = deferStatic;\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export let defer: typeof deferStatic; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { empty as emptyStatic } from '../../iterable/empty';\n\n/** @nocollapse */\nIterableX.empty = emptyStatic;\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export let empty: typeof emptyStatic; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { _for as forStatic } from '../../iterable/for';\n\n/** @nocollapse */\nIterableX.for = forStatic;\n\nexport declare namespace iterable {\n  let _for: typeof forStatic;\n}\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export { forStatic as for }; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { generate as generateStatic } from '../../iterable/generate';\n\n/** @nocollapse */\nIterableX.generate = generateStatic;\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export let generate: typeof generateStatic; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { _if as ifStatic } from '../../iterable/if';\n\n/** @nocollapse */\nIterableX.if = ifStatic;\n\nexport declare namespace iterable {\n  let _if: typeof ifStatic;\n}\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export { ifStatic as if }; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { ofEntries as ofEntriesStatic } from '../../iterable/ofentries';\n\n/** @nocollapse */\nIterableX.ofEntries = ofEntriesStatic;\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export let ofEntries: typeof ofEntriesStatic; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { ofKeys as ofKeysStatic } from '../../iterable/ofkeys';\n\n/** @nocollapse */\nIterableX.ofKeys = ofKeysStatic;\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export let ofKeys: typeof ofKeysStatic; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { ofValues as ofValuesStatic } from '../../iterable/ofvalues';\n\n/** @nocollapse */\nIterableX.ofValues = ofValuesStatic;\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export let ofValues: typeof ofValuesStatic; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { onErrorResumeNextStatic } from '../../iterable/onerrorresumenext';\n\n/** @nocollapse */\nIterableX.onErrorResumeNext = onErrorResumeNextStatic;\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export let onErrorResumeNext: typeof onErrorResumeNextStatic; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { range as rangeStatic } from '../../iterable/range';\n\n/** @nocollapse */\nIterableX.range = rangeStatic;\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export let range: typeof rangeStatic; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { repeatStatic as _repeatStatic } from '../../iterable/repeat';\n\n/** @nocollapse */\nIterableX.repeat = _repeatStatic;\n\nexport declare namespace iterable {\n  let repeatStatic: typeof _repeatStatic;\n}\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export let repeat: typeof _repeatStatic; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { _throw as throwStatic } from '../../iterable/throw';\n\n/** @nocollapse */\nIterableX.throw = throwStatic;\n\nexport declare namespace iterable {\n  let _throw: typeof throwStatic;\n}\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export { throwStatic as throw }; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { _while as whileStatic } from '../../iterable/while';\n\n/** @nocollapse */\nIterableX.while = whileStatic;\n\nexport declare namespace iterable {\n  let _while: typeof whileStatic;\n}\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export { whileStatic as while }; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { zip as zipStatic } from '../../iterable/zip';\n\n/** @nocollapse */\nIterableX.zip = zipStatic;\n\ndeclare module '../../iterable/iterablex' {\n  namespace IterableX { export let zip: typeof zipStatic; }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { identity } from '../../internal/identity';\nimport { average } from '../../iterable/average';\n\nexport function averageProto(this: IterableX<number>, selector?: (x: number) => number): number;\nexport function averageProto<T>(this: IterableX<T>, selector?: (x: T) => number): number;\n/**\n * @ignore\n */\nexport function averageProto(\n  this: IterableX<any>,\n  selector: (x: any) => number = identity\n): number {\n  return average(this, selector);\n}\n\nIterableX.prototype.average = averageProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    average: typeof averageProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { buffer } from '../../iterable/buffer';\n\n/**\n * @ignore\n */\nexport function bufferProto<T>(this: IterableX<T>, count: number, skip?: number): IterableX<T[]> {\n  return buffer<T>(this, count, skip);\n}\n\nIterableX.prototype.buffer = bufferProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    buffer: typeof bufferProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { _catch } from '../../iterable/catch';\n\n/**\n * @ignore\n */\nexport function catchProto<T>(this: IterableX<T>, ...args: Iterable<T>[]): IterableX<T> {\n  return _catch<T>(this, ...args);\n}\n\nIterableX.prototype.catch = catchProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    catch: typeof catchProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { catchWith as catchWithStatic } from '../../iterable/catchwith';\n\n/**\n * @ignore\n */\nexport function catchWithProto<T>(\n  this: IterableX<T>,\n  fn: (error: any) => Iterable<T>\n): IterableX<T> {\n  return catchWithStatic<T>(this, fn);\n}\n\nIterableX.prototype.catchWith = catchWithProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    catchWith: typeof catchWithProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { chain as chainStatic } from '../../iterable/chain';\n\n/**\n * @ignore\n */\nexport function chainProto<TSource, TResult>(\n  this: IterableX<TSource>,\n  selector: (source: Iterable<TSource>) => Iterable<TResult>\n): IterableX<TResult> {\n  return chainStatic<TSource, TResult>(this, selector);\n}\n\nIterableX.prototype.chain = chainProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    chain: typeof chainProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { concatAll } from '../../iterable/concatall';\n\n/**\n * @ignore\n */\nexport function concatAllProto<T>(this: IterableX<Iterable<T>>): IterableX<T> {\n  return concatAll(this);\n}\n\nIterableX.prototype.concatAll = concatAllProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    concatAll: typeof concatAllProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { concat } from '../../iterable/concat';\n\n/* tslint:disable:max-line-length */\n/**\n * @ignore\n */\nexport function concatProto<T>(this: IterableX<T>): IterableX<T>;\n/**\n * @ignore\n */\nexport function concatProto<T, T2>(this: IterableX<T>, v2: Iterable<T2>): IterableX<T | T2>;\nexport function concatProto<T, T2, T3>(\n  this: IterableX<T>,\n  v2: Iterable<T2>,\n  v3: Iterable<T3>\n): IterableX<T | T2 | T3>;\n/**\n * @ignore\n */\nexport function concatProto<T, T2, T3, T4>(\n  this: IterableX<T>,\n  v2: Iterable<T2>,\n  v3: Iterable<T3>,\n  v4: Iterable<T4>\n): IterableX<T | T2 | T3 | T4>;\n/**\n * @ignore\n */\nexport function concatProto<T, T2, T3, T4, T5>(\n  this: IterableX<T>,\n  v2: Iterable<T2>,\n  v3: Iterable<T3>,\n  v4: Iterable<T4>,\n  v5: Iterable<T5>\n): Iterable<T | T2 | T3 | T4 | T5>;\n/**\n * @ignore\n */\nexport function concatProto<T, T2, T3, T4, T5, T6>(\n  this: IterableX<T>,\n  v2: Iterable<T2>,\n  v3: Iterable<T3>,\n  v4: Iterable<T4>,\n  v5: Iterable<T5>,\n  v6: Iterable<T6>\n): Iterable<T | T2 | T3 | T4 | T5 | T6>;\n/* tslint:enable:max-line-length */\n\n/**\n * @ignore\n */\nexport function concatProto<T>(this: IterableX<T>, ...args: Iterable<T>[]): IterableX<T> {\n  return concat(this, ...args);\n}\n\nIterableX.prototype.concat = concatProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    concat: typeof concatProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { count } from '../../iterable/count';\n\n/**\n * @ignore\n */\nexport function countProto<T>(this: IterableX<T>, fn?: (value: T) => boolean): number {\n  return count<T>(this, fn);\n}\n\nIterableX.prototype.count = countProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    count: typeof countProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { defaultIfEmpty } from '../../iterable/defaultifempty';\n\n/**\n * @ignore\n */\nexport function defaultIfEmptyProto<T>(this: IterableX<T>, defaultValue: T): IterableX<T> {\n  return defaultIfEmpty<T>(this, defaultValue);\n}\n\nIterableX.prototype.defaultIfEmpty = defaultIfEmptyProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    defaultIfEmpty: typeof defaultIfEmptyProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { distinct } from '../../iterable/distinct';\n\n/**\n * @ignore\n */\nexport function distinctProto<TSource, TKey>(\n  this: IterableX<TSource>,\n  keySelector?: (value: TSource) => TKey,\n  comparer?: (x: TKey, y: TKey) => boolean\n): IterableX<TSource> {\n  return distinct(this, keySelector, comparer);\n}\n\nIterableX.prototype.distinct = distinctProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    distinct: typeof distinctProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { distinctUntilChanged } from '../../iterable/distinctuntilchanged';\n\n/**\n * @ignore\n */\nexport function distinctUntilChangedProto<TSource, TKey>(\n  this: IterableX<TSource>,\n  keySelector?: (value: TSource) => TKey,\n  cmp?: (x: TKey, y: TKey) => boolean\n): IterableX<TSource> {\n  return distinctUntilChanged(this, keySelector, cmp);\n}\n\nIterableX.prototype.distinctUntilChanged = distinctUntilChangedProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    distinctUntilChanged: typeof distinctUntilChangedProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { doWhile } from '../../iterable/dowhile';\n\n/**\n * @ignore\n */\nexport function doWhileProto<TSource>(\n  this: IterableX<TSource>,\n  condition: () => boolean\n): IterableX<TSource> {\n  return doWhile(this, condition);\n}\n\nIterableX.prototype.doWhile = doWhileProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    doWhile: typeof doWhileProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { elementAt } from '../../iterable/elementat';\n\n/**\n * @ignore\n */\nexport function elementAtProto<T>(this: IterableX<T>, index: number) {\n  return elementAt<T>(this, index);\n}\n\nIterableX.prototype.elementAt = elementAtProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    elementAt: typeof elementAtProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { endWith } from '../../iterable/endwith';\n\n/**\n * @ignore\n */\nexport function endWithProto<T>(this: IterableX<T>, ...args: T[]) {\n  return endWith(this, ...args);\n}\n\nIterableX.prototype.endWith = endWithProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    endWith: typeof endWithProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { every } from '../../iterable/every';\n\n/**\n * @ignore\n */\nexport function everyProto<T, S extends T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => value is S\n): boolean;\nexport function everyProto<T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => boolean\n): boolean;\nexport function everyProto<T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => boolean\n): boolean {\n  return every(this, predicate);\n}\n\nIterableX.prototype.every = everyProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    every: typeof everyProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { except } from '../../iterable/except';\n\n/**\n * @ignore\n */\nexport function exceptProto<TSource>(\n  this: IterableX<TSource>,\n  second: Iterable<TSource>,\n  comparer?: (x: TSource, y: TSource) => boolean\n): IterableX<TSource> {\n  return except(this, second, comparer);\n}\n\nIterableX.prototype.except = exceptProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    except: typeof exceptProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { expand } from '../../iterable/expand';\n\n/**\n * @ignore\n */\nexport function expandProto<TSource>(\n  this: IterableX<TSource>,\n  fn: (value: TSource) => Iterable<TSource>\n) {\n  return expand(this, fn);\n}\n\nIterableX.prototype.expand = expandProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    expand: typeof expandProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { filter } from '../../iterable/filter';\n\n/**\n * @ignore\n */\nexport function filterProto<T, S extends T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => value is S,\n  thisArg?: any\n): IterableX<S>;\nexport function filterProto<T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): IterableX<T>;\nexport function filterProto<T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): IterableX<T> {\n  return filter(this, predicate, thisArg);\n}\n\nIterableX.prototype.filter = filterProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    filter: typeof filterProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { _finally as _finallyProto } from '../../iterable/finally';\n\n/**\n * @ignore\n */\nexport function finallyProto<TSource>(this: IterableX<TSource>, action: () => void) {\n  return _finallyProto(this, action);\n}\n\nIterableX.prototype.finally = finallyProto;\n\nexport declare namespace iterable {\n  let _finally: typeof _finallyProto;\n}\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    finally: typeof finallyProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { findIndex } from '../../iterable/findindex';\n\n/**\n * @ignore\n */\nexport function findIndexProto<T>(\n  this: IterableX<T>,\n  fn: (value: T, index: number) => boolean,\n  thisArg?: any\n): number {\n  return findIndex(this, fn, thisArg);\n}\n\nIterableX.prototype.findIndex = findIndexProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    findIndex: typeof findIndexProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { find } from '../../iterable/find';\n\n/**\n * @ignore\n */\n\nexport function findProto<T, S extends T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => value is S,\n  thisArg?: any\n): S | undefined;\nexport function findProto<T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): T | undefined;\nexport function findProto<T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): T | undefined {\n  return find(this, predicate, thisArg);\n}\n\nIterableX.prototype.find = findProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    find: typeof findProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { first } from '../../iterable/first';\n\n/**\n * @ignore\n */\n\nexport function firstProto<T, S extends T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => value is S\n): S | undefined;\nexport function firstProto<T>(\n  this: IterableX<T>,\n  predicate?: (value: T, index: number) => boolean\n): T | undefined;\nexport function firstProto<T>(\n  this: IterableX<T>,\n  predicate?: (value: T, index: number) => boolean\n): T | undefined {\n  return first(this, predicate);\n}\n\nIterableX.prototype.first = firstProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    first: typeof firstProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { flatMap } from '../../iterable/flatmap';\n\n/**\n * @ignore\n */\nexport function flatMapProto<TSource, TResult>(\n  this: IterableX<TSource>,\n  fn: (value: TSource) => Iterable<TResult>,\n  thisArg?: any\n): IterableX<TResult> {\n  return flatMap<TSource, TResult>(this, fn, thisArg);\n}\n\nIterableX.prototype.flatMap = flatMapProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    flatMap: typeof flatMapProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { flatten } from '../../iterable/flatten';\n\n/**\n * @ignore\n */\nexport function flattenProto<T>(this: IterableX<T>, depth?: number): IterableX<T> {\n  return flatten(this, depth);\n}\n\nIterableX.prototype.flatten = flattenProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    flatten: typeof flattenProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { groupBy, GroupedIterable, groupByResultIdentity } from '../../iterable/groupby';\nimport { identity } from '../../internal/identity';\n\nexport function groupByProto<TSource, TKey>(\n  this: IterableX<TSource>,\n  keySelector: (value: TSource) => TKey\n): IterableX<GroupedIterable<TKey, TSource>>;\nexport function groupByProto<TSource, TKey, TValue>(\n  this: IterableX<TSource>,\n  keySelector: (value: TSource) => TKey,\n  elementSelector?: (value: TSource) => TValue\n): IterableX<GroupedIterable<TKey, TValue>>;\nexport function groupByProto<TSource, TKey, TValue, TResult>(\n  this: IterableX<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (value: TSource) => TValue | Promise<TValue>,\n  resultSelector?: (key: TKey, values: Iterable<TValue>) => TResult\n): IterableX<TResult>;\n/**\n * @ignore\n */\nexport function groupByProto<TSource, TKey, TValue, TResult>(\n  this: IterableX<TSource>,\n  keySelector: (value: TSource) => TKey,\n  elementSelector: (value: TSource) => TValue = identity,\n  resultSelector: (key: TKey, values: Iterable<TValue>) => TResult = groupByResultIdentity\n): IterableX<TResult> {\n  return groupBy<TSource, TKey, TValue, TResult>(\n    this,\n    keySelector,\n    elementSelector,\n    resultSelector\n  );\n}\n\nIterableX.prototype.groupBy = groupByProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    groupBy: typeof groupByProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { groupJoin } from '../../iterable/groupjoin';\n\n/**\n * @ignore\n */\nexport function groupJoinProto<TOuter, TInner, TKey, TResult>(\n  this: IterableX<TOuter>,\n  inner: Iterable<TInner>,\n  outerSelector: (value: TOuter) => TKey,\n  innerSelector: (value: TInner) => TKey,\n  resultSelector: (outer: TOuter, inner: Iterable<TInner>) => TResult\n): IterableX<TResult> {\n  return groupJoin(this, inner, outerSelector, innerSelector, resultSelector);\n}\n\nIterableX.prototype.groupJoin = groupJoinProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    groupJoin: typeof groupJoinProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { ignoreElements } from '../../iterable/ignoreelements';\n\n/**\n * @ignore\n */\nexport function ignoreElementsProto<T>(this: IterableX<T>): IterableX<T> {\n  return ignoreElements(this);\n}\n\nIterableX.prototype.ignoreElements = ignoreElementsProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    ignoreElements: typeof ignoreElementsProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { includes } from '../../iterable/includes';\n\n/**\n * @ignore\n */\nexport function includesProto<T>(this: IterableX<T>, searchElement: T, fromIndex: number): boolean {\n  return includes(this, searchElement, fromIndex);\n}\n\nIterableX.prototype.includes = includesProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    includes: typeof includesProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { innerJoin } from '../../iterable/innerjoin';\n\n/**\n * @ignore\n */\nexport function innerJoinProto<TOuter, TInner, TKey, TResult>(\n  this: IterableX<TOuter>,\n  inner: Iterable<TInner>,\n  outerSelector: (value: TOuter) => TKey,\n  innerSelector: (value: TInner) => TKey,\n  resultSelector: (outer: TOuter, inner: TInner) => TResult\n): IterableX<TResult> {\n  return innerJoin(this, inner, outerSelector, innerSelector, resultSelector);\n}\n\nIterableX.prototype.innerJoin = innerJoinProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    innerJoin: typeof innerJoinProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { intersect } from '../../iterable/intersect';\n\n/**\n * @ignore\n */\nexport function intersectProto<T>(\n  this: IterableX<T>,\n  second: IterableX<T>,\n  comparer?: (x: T, y: T) => boolean\n) {\n  return intersect(this, second, comparer);\n}\n\nIterableX.prototype.intersect = intersectProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    intersect: typeof intersectProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { isEmpty } from '../../iterable/isempty';\n\n/**\n * @ignore\n */\nexport function isEmptyProto<T>(this: IterableX<T>): boolean {\n  return isEmpty(this);\n}\n\nIterableX.prototype.isEmpty = isEmptyProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    isEmpty: typeof isEmptyProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { last } from '../../iterable/last';\n\n/**\n * @ignore\n */\nexport function lastProto<T, S extends T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => value is S\n): S | undefined;\nexport function lastProto<T>(\n  this: IterableX<T>,\n  predicate?: (value: T, index: number) => boolean\n): T | undefined;\nexport function lastProto<T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => boolean = () => true\n): T | undefined {\n  return last(this, predicate);\n}\n\nIterableX.prototype.last = lastProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    last: typeof lastProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { map } from '../../iterable/map';\n\n/**\n * @ignore\n */\nexport function mapProto<T, U>(\n  this: IterableX<T>,\n  fn: (value: T, index: number) => U,\n  thisArg?: any\n): IterableX<U> {\n  return map<T, U>(this, fn, thisArg);\n}\n\nIterableX.prototype.map = mapProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    map: typeof mapProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { maxBy } from '../../iterable/maxby';\n\n/**\n * @ignore\n */\nexport function maxByProto<TSource, TKey>(\n  this: IterableX<TSource>,\n  keyFn: (x: TSource) => TKey,\n  cmp?: (x: TKey, y: TKey) => number\n): IterableX<TSource> {\n  return maxBy(this, keyFn, cmp);\n}\n\nIterableX.prototype.maxBy = maxByProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    maxBy: typeof maxByProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { max } from '../../iterable/max';\n\nexport function maxProto(this: IterableX<number>, fn?: (x: number) => number): number;\nexport function maxProto<T>(this: IterableX<T>, fn: (x: T) => number): number;\n/**\n * @ignore\n */\nexport function maxProto(this: IterableX<any>, fn: (x: any) => number = x => x): number {\n  return max(this, fn);\n}\n\nIterableX.prototype.max = maxProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    max: typeof maxProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { memoize } from '../../iterable/memoize';\n\nexport function memoizeProto<TSource>(\n  this: IterableX<TSource>,\n  readerCount?: number\n): IterableX<TSource>;\nexport function memoizeProto<TSource, TResult>(\n  this: IterableX<TSource>,\n  readerCount?: number,\n  selector?: (value: Iterable<TSource>) => Iterable<TResult>\n): IterableX<TResult>;\n/**\n * @ignore\n */\nexport function memoizeProto<TSource, TResult = TSource>(\n  this: IterableX<TSource>,\n  readerCount: number = -1,\n  selector?: (value: Iterable<TSource>) => Iterable<TResult>\n): IterableX<TSource | TResult> {\n  return memoize(this, readerCount, selector);\n}\n\nIterableX.prototype.memoize = memoizeProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    memoize: typeof memoizeProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { minBy } from '../../iterable/minby';\n\n/**\n * @ignore\n */\nexport function minByProto<TSource, TKey>(\n  this: IterableX<TSource>,\n  keyFn: (x: TSource) => TKey,\n  cmp?: (x: TKey, y: TKey) => number\n): IterableX<TSource> {\n  return minBy(this, keyFn, cmp);\n}\n\nIterableX.prototype.minBy = minByProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    minBy: typeof minByProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { min } from '../../iterable/min';\n\nexport function minProto(this: IterableX<number>, fn?: (x: number) => number): number;\nexport function minProto<T>(this: IterableX<T>, fn: (x: T) => number): number;\n/**\n * @ignore\n */\nexport function minProto(this: IterableX<any>, fn: (x: any) => number = x => x): number {\n  return min(this, fn);\n}\n\nIterableX.prototype.min = minProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    min: typeof minProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { onErrorResumeNext } from '../../iterable/onerrorresumenext';\n\n/**\n * @ignore\n */\nexport function onErrorResumeNextProto<TSource>(\n  this: IterableX<TSource>,\n  ...args: Iterable<TSource>[]\n): IterableX<TSource> {\n  return onErrorResumeNext(this, ...args);\n}\n\nIterableX.prototype.onErrorResumeNext = onErrorResumeNextProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    onErrorResumeNext: typeof onErrorResumeNextProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { orderBy, orderByDescending, OrderedIterableX } from '../../iterable/orderby';\nimport { thenBy as _thenBy, thenByDescending as _thenByDescending } from '../../iterable/orderby';\n\n/**\n * @ignore\n */\nexport function orderByProto<TKey, TSource>(\n  this: IterableX<TSource>,\n  keySelector: (item: TSource) => TKey,\n  comparer?: (fst: TKey, snd: TKey) => number\n): OrderedIterableX<TKey, TSource> {\n  return orderBy<TKey, TSource>(this, keySelector, comparer);\n}\n\n/**\n * @ignore\n */\nexport function orderByDescendingProto<TKey, TSource>(\n  this: IterableX<TSource>,\n  keySelector: (item: TSource) => TKey,\n  comparer?: (fst: TKey, snd: TKey) => number\n): OrderedIterableX<TKey, TSource> {\n  return orderByDescending<TKey, TSource>(this, keySelector, comparer);\n}\n\nIterableX.prototype.orderBy = orderByProto;\nIterableX.prototype.orderByDescending = orderByDescendingProto;\n\nexport declare namespace iterable {\n  let thenBy: typeof _thenBy;\n  let thenByDescending: typeof _thenByDescending;\n}\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    orderBy: typeof orderByProto;\n    orderByDescending: typeof orderByDescendingProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { pairwise } from '../../iterable/pairwise';\n\n/**\n * @ignore\n */\nexport function pairwiseProto<TSource>(this: IterableX<TSource>): IterableX<TSource[]> {\n  return pairwise(this);\n}\n\nIterableX.prototype.pairwise = pairwiseProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    pairwise: typeof pairwiseProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { partition } from '../../iterable/partition';\n\n/**\n * @ignore\n */\n\nexport function partitionProto<T, S extends T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => value is S,\n  thisArg?: any\n): IterableX<S>[];\nexport function partitionProto<T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): IterableX<T>[];\nexport function partitionProto<T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => boolean,\n  thisArg?: any\n): IterableX<T>[] {\n  return partition(this, predicate, thisArg);\n}\n\nIterableX.prototype.partition = partitionProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    partition: typeof partitionProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { pluck } from '../../iterable/pluck';\n\n/**\n * @ignore\n */\nexport function pluckProto<TSource, TResult>(\n  this: IterableX<TSource>,\n  ...args: string[]\n): IterableX<TResult> {\n  return pluck<TSource, TResult>(this, ...args);\n}\n\nIterableX.prototype.pluck = pluckProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    pluck: typeof pluckProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { reduceRight } from '../../iterable/reduceright';\n\nexport function reduceRightProto<T, R = T>(\n  this: IterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: never[]\n): R;\nexport function reduceRightProto<T, R = T>(\n  this: IterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: R\n): R;\n/**\n * @ignore\n */\nexport function reduceRightProto<T, R = T>(\n  this: IterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  ...seed: R[]\n): R {\n  return reduceRight(this, accumulator, ...seed);\n}\n\nIterableX.prototype.reduceRight = reduceRightProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    reduceRight: typeof reduceRightProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { reduce } from '../../iterable/reduce';\n\nexport function reduceProto<T, R = T>(\n  this: IterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: never[]\n): R;\nexport function reduceProto<T, R = T>(\n  this: IterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: R\n): R;\n/**\n * @ignore\n */\nexport function reduceProto<T, R = T>(\n  this: IterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  ...seed: R[]\n): R {\n  return reduce(this, accumulator, ...seed);\n}\n\nIterableX.prototype.reduce = reduceProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    reduce: typeof reduceProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { repeat } from '../../iterable/repeat';\n\n/**\n * @ignore\n */\nexport function repeatProto<TSource>(\n  this: IterableX<TSource>,\n  count: number = -1\n): IterableX<TSource> {\n  return repeat(this, count);\n}\n\nIterableX.prototype.repeat = repeatProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    repeat: typeof repeatProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { retry } from '../../iterable/retry';\n\n/**\n * @ignore\n */\nexport function retryProto<TSource>(\n  this: IterableX<TSource>,\n  count: number = -1\n): IterableX<TSource> {\n  return retry(this, count);\n}\n\nIterableX.prototype.retry = retryProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    retry: typeof retryProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { reverse } from '../../iterable/reverse';\n\n/**\n * @ignore\n */\nexport function reverseProto<TSource>(this: IterableX<TSource>): IterableX<TSource> {\n  return reverse(this);\n}\n\nIterableX.prototype.reverse = reverseProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    reverse: typeof reverseProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { scanRight } from '../../iterable/scanright';\n\nexport function scanRightProto<T, R = T>(\n  this: IterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: never[]\n): IterableX<R>;\nexport function scanRightProto<T, R = T>(\n  this: IterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: R\n): IterableX<R>;\n/**\n * @ignore\n */\nexport function scanRightProto<T, R = T>(\n  this: IterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  ...seed: R[]\n): IterableX<R> {\n  return scanRight(this, accumulator, ...seed);\n}\n\nIterableX.prototype.scanRight = scanRightProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    scanRight: typeof scanRightProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { scan } from '../../iterable/scan';\n\nexport function scanProto<T, R = T>(\n  this: IterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: never[]\n): IterableX<R>;\nexport function scanProto<T, R = T>(\n  this: IterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: R\n): IterableX<R>;\n/**\n * @ignore\n */\nexport function scanProto<T, R = T>(\n  this: IterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  ...seed: R[]\n): IterableX<R> {\n  return scan(this, accumulator, ...seed);\n}\n\nIterableX.prototype.scan = scanProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    scan: typeof scanProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { sequenceEqual } from '../../iterable/sequenceequal';\n\n/**\n * @ignore\n */\nexport function sequenceEqualProto<T>(\n  this: IterableX<T>,\n  other: Iterable<T>,\n  cmp: (first: T, second: T) => boolean = (x, y) => x === y\n): boolean {\n  return sequenceEqual(this, other, cmp);\n}\n\nIterableX.prototype.sequenceEqual = sequenceEqualProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    sequenceEqual: typeof sequenceEqualProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { share } from '../../iterable/share';\n\nexport function shareProto<TSource>(this: IterableX<TSource>): IterableX<TSource>;\nexport function shareProto<TSource, TResult>(\n  this: IterableX<TSource>,\n  fn?: (value: Iterable<TSource>) => Iterable<TResult>\n): IterableX<TResult>;\n/**\n * @ignore\n */\nexport function shareProto<TSource, TResult>(\n  this: IterableX<TSource>,\n  fn?: (value: Iterable<TSource>) => Iterable<TResult>\n): IterableX<TSource | TResult> {\n  return share(this, fn);\n}\n\nIterableX.prototype.share = shareProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    share: typeof shareProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { single } from '../../iterable/single';\n\n/**\n * @ignore\n */\nexport function singleProto<T, S extends T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => value is S\n): S | undefined;\nexport function singleProto<T>(\n  this: IterableX<T>,\n  predicate?: (value: T, index: number) => boolean\n): T | undefined;\nexport function singleProto<T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => boolean = () => true\n): T | undefined {\n  return single(this, predicate);\n}\n\nIterableX.prototype.single = singleProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    single: typeof singleProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { skipLast } from '../../iterable/skiplast';\n\n/**\n * @ignore\n */\nexport function skipLastProto<T>(this: IterableX<T>, count: number): IterableX<T> {\n  return skipLast(this, count);\n}\n\nIterableX.prototype.skipLast = skipLastProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    skipLast: typeof skipLastProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { skip } from '../../iterable/skip';\n\n/**\n * @ignore\n */\nexport function skipProto<T>(this: IterableX<T>, count: number): IterableX<T> {\n  return skip(this, count);\n}\n\nIterableX.prototype.skip = skipProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    skip: typeof skipProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { skipWhile } from '../../iterable/skipwhile';\n\n/**\n * @ignore\n */\nexport function skipWhileProto<T, S extends T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => value is S\n): IterableX<S>;\nexport function skipWhileProto<TSource>(\n  this: IterableX<TSource>,\n  predicate: (value: TSource, index: number) => boolean\n): IterableX<TSource>;\nexport function skipWhileProto<TSource>(\n  this: IterableX<TSource>,\n  predicate: (value: TSource, index: number) => boolean\n): IterableX<TSource> {\n  return skipWhile(this, predicate);\n}\n\nIterableX.prototype.skipWhile = skipWhileProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    skipWhile: typeof skipWhileProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { slice } from '../../iterable/slice';\n\n/**\n * @ignore\n */\nexport function sliceProto<T>(this: IterableX<T>, begin: number, end: number): IterableX<T> {\n  return slice(this, begin, end);\n}\n\nIterableX.prototype.slice = sliceProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    slice: typeof sliceProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { some } from '../../iterable/some';\n\n/**\n * @ignore\n */\nexport function someProto<T, S extends T>(\n  this: IterableX<T>,\n  comparer: (value: T, index: number) => value is S\n): boolean;\nexport function someProto<T>(\n  this: IterableX<T>,\n  comparer: (value: T, index: number) => boolean\n): boolean;\nexport function someProto<T>(\n  this: IterableX<T>,\n  comparer: (value: T, index: number) => boolean\n): boolean {\n  return some(this, comparer);\n}\n\nIterableX.prototype.some = someProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    some: typeof someProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { startWith } from '../../iterable/startwith';\n\n/**\n * @ignore\n */\nexport function startWithProto<T>(this: IterableX<T>, ...args: T[]) {\n  return startWith(this, ...args);\n}\n\nIterableX.prototype.startWith = startWithProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    startWith: typeof startWithProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { sum } from '../../iterable/sum';\n\nexport function sumProto(this: IterableX<number>, fn?: (x: number) => number): number;\nexport function sumProto<T>(this: IterableX<T>, fn: (x: T) => number): number;\n/**\n * @ignore\n */\nexport function sumProto(this: IterableX<any>, fn: (x: any) => number = x => x): number {\n  return sum(this, fn);\n}\n\nIterableX.prototype.sum = sumProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    sum: typeof sumProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { takeLast } from '../../iterable/takelast';\n\n/**\n * @ignore\n */\nexport function takeLastProto<T>(this: IterableX<T>, count: number): IterableX<T> {\n  return takeLast(this, count);\n}\n\nIterableX.prototype.takeLast = takeLastProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    takeLast: typeof takeLastProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { take } from '../../iterable/take';\n\n/**\n * @ignore\n */\nexport function takeProto<T>(this: IterableX<T>, count: number): IterableX<T> {\n  return take(this, count);\n}\n\nIterableX.prototype.take = takeProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    take: typeof takeProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { takeWhile } from '../../iterable/takewhile';\n\n/**\n * @ignore\n */\nexport function takeWhileProto<T, S extends T>(\n  this: IterableX<T>,\n  predicate: (value: T, index: number) => value is S\n): IterableX<S>;\nexport function takeWhileProto<TSource>(\n  this: IterableX<TSource>,\n  predicate: (value: TSource, index: number) => boolean\n): IterableX<TSource>;\nexport function takeWhileProto<TSource>(\n  this: IterableX<TSource>,\n  predicate: (value: TSource, index: number) => boolean\n): IterableX<TSource> {\n  return takeWhile(this, predicate);\n}\n\nIterableX.prototype.takeWhile = takeWhileProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    takeWhile: typeof takeWhileProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { tap } from '../../iterable/tap';\nimport { PartialObserver } from '../../observer';\n\n/**\n * @ignore\n */\nexport function tapProto<T>(this: IterableX<T>, observer: PartialObserver<T>): IterableX<T> {\n  return tap(this, observer);\n}\n\nIterableX.prototype.tap = tapProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    tap: typeof tapProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { toArray } from '../../iterable/toarray';\n\n/**\n * @ignore\n */\nexport function toArrayProto<TSource>(this: IterableX<TSource>): TSource[] {\n  return toArray(this);\n}\n\nIterableX.prototype.toArray = toArrayProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    toArray: typeof toArrayProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { toMap } from '../../iterable/tomap';\n\nexport function toMapProto<TSource, TKey>(\n  this: IterableX<TSource>,\n  keySelector: (item: TSource) => TKey\n): Map<TKey, TSource>;\nexport function toMapProto<TSource, TKey, TElement = TSource>(\n  this: IterableX<TSource>,\n  keySelector: (item: TSource) => TKey,\n  elementSelector?: (item: TSource) => TElement\n): Map<TKey, TElement>;\n/**\n * @ignore\n */\nexport function toMapProto<TSource, TKey, TElement = TSource>(\n  this: IterableX<TSource>,\n  keySelector: (item: TSource) => TKey,\n  elementSelector?: (item: TSource) => TElement\n): Map<TKey, TElement | TSource> {\n  return toMap(this, keySelector, elementSelector);\n}\n\nIterableX.prototype.toMap = toMapProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    toMap: typeof toMapProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { toSet } from '../../iterable/toset';\n\n/**\n * @ignore\n */\nexport function toSetProto<TSource>(this: IterableX<TSource>): Set<TSource> {\n  return toSet(this);\n}\n\nIterableX.prototype.toSet = toSetProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    toSet: typeof toSetProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { union } from '../../iterable/union';\n\n/**\n * @ignore\n */\nexport function unionProto<T>(\n  this: IterableX<T>,\n  right: Iterable<T>,\n  comparer?: (x: T, y: T) => boolean\n): IterableX<T> {\n  return union(this, right, comparer);\n}\n\nIterableX.prototype.union = unionProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    union: typeof unionProto;\n  }\n}\n","import { IterableX } from '../../iterable/iterablex';\nimport { zip } from '../../iterable/zip';\n\n/**\n * @ignore\n */\n\nexport function zipProto<T, T2>(this: IterableX<T>, source2: Iterable<T2>): IterableX<[T, T2]>;\nexport function zipProto<T, T2, T3>(\n  this: IterableX<T>,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>\n): IterableX<[T, T2, T3]>;\nexport function zipProto<T, T2, T3, T4>(\n  this: IterableX<T>,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>\n): IterableX<[T, T2, T3, T4]>;\nexport function zipProto<T, T2, T3, T4, T5>(\n  this: IterableX<T>,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>,\n  source5: Iterable<T5>\n): IterableX<[T, T2, T3, T4, T5]>;\nexport function zipProto<T, T2, T3, T4, T5, T6>(\n  this: IterableX<T>,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>,\n  source5: Iterable<T5>,\n  source6: Iterable<T6>\n): IterableX<[T, T2, T3, T4, T5, T6]>;\n\nexport function zipProto<T, R>(this: IterableX<T>, project: (values: [T]) => R): IterableX<R>;\nexport function zipProto<T, T2, R>(\n  this: IterableX<T>,\n  project: (values: [T, T2]) => R,\n  source2: Iterable<T2>\n): IterableX<R>;\nexport function zipProto<T, T2, T3, R>(\n  this: IterableX<T>,\n  project: (values: [T, T2, T3]) => R,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>\n): IterableX<R>;\nexport function zipProto<T, T2, T3, T4, R>(\n  this: IterableX<T>,\n  project: (values: [T, T2, T3, T4]) => R,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>\n): IterableX<R>;\nexport function zipProto<T, T2, T3, T4, T5, R>(\n  this: IterableX<T>,\n  project: (values: [T, T2, T3, T4, T5]) => R,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>,\n  source5: Iterable<T5>\n): IterableX<R>;\nexport function zipProto<T, T2, T3, T4, T5, T6, R>(\n  this: IterableX<T>,\n  project: (values: [T, T2, T3, T4, T5, T6]) => R,\n  source2: Iterable<T2>,\n  source3: Iterable<T3>,\n  source4: Iterable<T4>,\n  source5: Iterable<T5>,\n  source6: Iterable<T6>\n): IterableX<R>;\n\nexport function zipProto<T>(this: IterableX<T>, ...sources: Iterable<T>[]): IterableX<T[]>;\nexport function zipProto<T, R>(\n  this: IterableX<T>,\n  project: (values: T[]) => R,\n  ...sources: Iterable<T>[]\n): IterableX<R>;\nexport function zipProto<T, R>(this: IterableX<T>, ...args: any[]): IterableX<R> {\n  let [arg1, ...sources] = args;\n  sources = typeof arg1 === 'function' ? [this, ...sources] : (arg1 = this) && args;\n  return zip<T, R>(arg1, ...sources) as IterableX<R>;\n}\n\nIterableX.prototype.zip = zipProto;\n\ndeclare module '../../iterable/iterablex' {\n  interface IterableX<T> {\n    zip: typeof zipProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { asyncifyErrback as asyncifyErrbackStatic } from '../../asynciterable/asyncifyerrback';\n\n/** @nocollapse */\nAsyncIterableX.asyncifyErrback = asyncifyErrbackStatic;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let asyncifyErrback: typeof asyncifyErrbackStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { asyncify as asyncifyStatic } from '../../asynciterable/asyncify';\n\n/** @nocollapse */\nAsyncIterableX.asyncify = asyncifyStatic;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let asyncify: typeof asyncifyStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { _case as caseStatic } from '../../asynciterable/case';\n\n/** @nocollapse */\nAsyncIterableX.case = caseStatic;\n\nexport declare namespace asynciterable {\n  let _case: typeof caseStatic;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export { caseStatic as case }; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { _catchStatic as catchStatic } from '../../asynciterable/catch';\n\n/** @nocollapse */\nAsyncIterableX.catch = catchStatic;\n\nexport declare namespace asynciterable {\n  let _catchStatic: typeof catchStatic;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export { catchStatic as catch }; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { combineLatest as combineLatestStatic } from '../../asynciterable/combinelatest';\n\n/** @nocollapse */\nAsyncIterableX.combineLatest = combineLatestStatic;\n\nexport declare namespace asynciterable {\n  let combineLatest: typeof combineLatestStatic;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let combineLatest: typeof combineLatestStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { concatStatic as concatStatic_ } from '../../asynciterable/concat';\n\n/** @nocollapse */\nAsyncIterableX.concat = concatStatic_;\n\nexport declare namespace asynciterable {\n  let concatStatic: typeof concatStatic_;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let concat: typeof concatStatic_; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { create as createStatic } from '../../asynciterable/create';\n\n/** @nocollapse */\nAsyncIterableX.create = createStatic;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let create: typeof createStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { defer as deferStatic } from '../../asynciterable/defer';\n\n/** @nocollapse */\nAsyncIterableX.defer = deferStatic;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let defer: typeof deferStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { empty as emptyStatic } from '../../asynciterable/empty';\n\n/** @nocollapse */\nAsyncIterableX.empty = emptyStatic;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let empty: typeof emptyStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { forkJoin as forkJoinStatic } from '../../asynciterable/forkjoin';\n\n/** @nocollapse */\nAsyncIterableX.forkJoin = forkJoinStatic;\n\nexport declare namespace asynciterable {\n  let forkJoin: typeof forkJoinStatic;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let forkJoin: typeof forkJoinStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { _for as forStatic } from '../../asynciterable/for';\n\n/** @nocollapse */\nAsyncIterableX.for = forStatic;\n\nexport declare namespace asynciterable {\n  let _for: typeof forStatic;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export { forStatic as for }; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { fromEventPattern as fromEventPatternStatic } from '../../asynciterable/fromeventpattern';\n\n/** @nocollapse */\nAsyncIterableX.fromEventPattern = fromEventPatternStatic;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let fromEventPattern: typeof fromEventPatternStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { fromEvent as fromEventStatic } from '../../asynciterable/fromevent';\n\n/** @nocollapse */\nAsyncIterableX.fromEvent = fromEventStatic;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let fromEvent: typeof fromEventStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { generateTime as generateTimeStatic } from '../../asynciterable/generatetime';\n\n/** @nocollapse */\nAsyncIterableX.generateTime = generateTimeStatic;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let generateTime: typeof generateTimeStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { generate as generateStatic } from '../../asynciterable/generate';\n\n/** @nocollapse */\nAsyncIterableX.generate = generateStatic;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let generate: typeof generateStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { _if as ifStatic } from '../../asynciterable/if';\n\n/** @nocollapse */\nAsyncIterableX.if = ifStatic;\n\nexport declare namespace asynciterable {\n  let _if: typeof ifStatic;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export { ifStatic as if }; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { mergeStatic as mergeStatic_ } from '../../asynciterable/merge';\n\n/** @nocollapse */\nAsyncIterableX.merge = mergeStatic_;\n\nexport declare namespace asynciterable {\n  let mergeStatic: typeof mergeStatic_;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let merge: typeof mergeStatic_; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { ofEntries as ofEntriesStatic } from '../../asynciterable/ofentries';\n\n/** @nocollapse */\nAsyncIterableX.ofEntries = ofEntriesStatic;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let ofEntries: typeof ofEntriesStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { ofKeys as ofKeysStatic } from '../../asynciterable/ofkeys';\n\n/** @nocollapse */\nAsyncIterableX.ofKeys = ofKeysStatic;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let ofKeys: typeof ofKeysStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { onErrorResumeNextStatic as _onErrorResumeNextStatic } from '../../asynciterable/onerrorresumenext';\n\n/** @nocollapse */\nAsyncIterableX.onErrorResumeNext = _onErrorResumeNextStatic;\n\nexport declare namespace asynciterable {\n  let onErrorResumeNextStatic: typeof _onErrorResumeNextStatic;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let onErrorResumeNext: typeof _onErrorResumeNextStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { race as raceStatic } from '../../asynciterable/race';\n\n/** @nocollapse */\nAsyncIterableX.race = raceStatic;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let race: typeof raceStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { range as rangeStatic } from '../../asynciterable/range';\n\n/** @nocollapse */\nAsyncIterableX.range = rangeStatic;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let range: typeof rangeStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { repeatStatic as _repeatStatic } from '../../asynciterable/repeat';\n\n/** @nocollapse */\nAsyncIterableX.repeat = _repeatStatic;\n\nexport declare namespace asynciterable {\n  let repeatStatic: typeof _repeatStatic;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let repeat: typeof _repeatStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { _throw as throwStatic } from '../../asynciterable/throw';\n\n/** @nocollapse */\nAsyncIterableX.throw = throwStatic;\n\nexport declare namespace asynciterable {\n  let _throw: typeof throwStatic;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export { throwStatic as throw }; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { _while as whileStatic } from '../../asynciterable/while';\n\n/** @nocollapse */\nAsyncIterableX.while = whileStatic;\n\nexport declare namespace asynciterable {\n  let _while: typeof whileStatic;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export { whileStatic as while }; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { zip as zipStatic } from '../../asynciterable/zip';\n\n/** @nocollapse */\nAsyncIterableX.zip = zipStatic;\n\nexport declare namespace asynciterable {\n  let zip: typeof zipStatic;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX { export let zip: typeof zipStatic; }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { identityAsync } from '../../internal/identity';\nimport { average } from '../../asynciterable/average';\n\nexport function averageProto(\n  this: AsyncIterableX<number>,\n  selector?: (x: number) => number | Promise<number>\n): Promise<number>;\nexport function averageProto<T>(\n  this: AsyncIterableX<T>,\n  selector?: (x: T) => number | Promise<number>\n): Promise<number>;\n/**\n * @ignore\n */\nexport function averageProto(\n  this: AsyncIterableX<any>,\n  selector: (x: any) => number | Promise<number> = identityAsync\n): Promise<number> {\n  return average(this, selector);\n}\n\nAsyncIterableX.prototype.average = averageProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    average: typeof averageProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { batch } from '../../asynciterable/batch';\n\n/**\n * @ignore\n */\nexport function batchProto<T>(this: AsyncIterableX<T>): AsyncIterableX<T[]> {\n  return batch<T>(this);\n}\n\nAsyncIterableX.prototype.batch = batchProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    batch: typeof batchProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { buffer } from '../../asynciterable/buffer';\n\n/**\n * @ignore\n */\nexport function bufferProto<T>(\n  this: AsyncIterableX<T>,\n  count: number,\n  skip?: number\n): AsyncIterableX<T[]> {\n  return buffer<T>(this, count, skip);\n}\n\nAsyncIterableX.prototype.buffer = bufferProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    buffer: typeof bufferProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { _catch as _catchProto } from '../../asynciterable/catch';\n\n/**\n * @ignore\n */\nexport function catchProto<T>(\n  this: AsyncIterableX<T>,\n  ...args: AsyncIterable<T>[]\n): AsyncIterableX<T> {\n  return _catchProto<T>(this, ...args);\n}\n\nAsyncIterableX.prototype.catch = catchProto;\n\nexport declare namespace asynciterable {\n  let _catch: typeof _catchProto;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    catch: typeof catchProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { catchWith as catchWithStatic } from '../../asynciterable/catchwith';\n\n/**\n * @ignore\n */\nexport function catchWithProto<T>(\n  this: AsyncIterableX<T>,\n  selector: (error: any) => AsyncIterable<T> | Promise<AsyncIterable<T>>\n): AsyncIterableX<T> {\n  return catchWithStatic<T>(this, selector);\n}\n\nAsyncIterableX.prototype.catchWith = catchWithProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    catchWith: typeof catchWithProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { chain as chainStatic } from '../../asynciterable/chain';\n\n/**\n * @ignore\n */\nexport function chainProto<TSource, TResult>(\n  this: AsyncIterableX<TSource>,\n  selector: (source: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): AsyncIterableX<TResult> {\n  return chainStatic<TSource, TResult>(this, selector);\n}\n\nAsyncIterableX.prototype.chain = chainProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    chain: typeof chainProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { combineLatest } from '../../asynciterable/combinelatest';\n\n/**\n * @ignore\n */\n\nexport function combineLatestProto<T, T2>(\n  this: AsyncIterableX<T>,\n  source2: AsyncIterable<T2>\n): AsyncIterableX<[T, T2]>;\nexport function combineLatestProto<T, T2, T3>(\n  this: AsyncIterableX<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): AsyncIterableX<[T, T2, T3]>;\nexport function combineLatestProto<T, T2, T3, T4>(\n  this: AsyncIterableX<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): AsyncIterableX<[T, T2, T3, T4]>;\nexport function combineLatestProto<T, T2, T3, T4, T5>(\n  this: AsyncIterableX<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): AsyncIterableX<[T, T2, T3, T4, T5]>;\nexport function combineLatestProto<T, T2, T3, T4, T5, T6>(\n  this: AsyncIterableX<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): AsyncIterableX<[T, T2, T3, T4, T5, T6]>;\n\nexport function combineLatestProto<T, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T]) => R\n): AsyncIterableX<R>;\nexport function combineLatestProto<T, T2, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T, T2]) => R,\n  source2: AsyncIterable<T2>\n): AsyncIterableX<R>;\nexport function combineLatestProto<T, T2, T3, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T, T2, T3]) => R,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): AsyncIterableX<R>;\nexport function combineLatestProto<T, T2, T3, T4, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T, T2, T3, T4]) => R,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): AsyncIterableX<R>;\nexport function combineLatestProto<T, T2, T3, T4, T5, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T, T2, T3, T4, T5]) => R,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): AsyncIterableX<R>;\nexport function combineLatestProto<T, T2, T3, T4, T5, T6, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T, T2, T3, T4, T5, T6]) => R,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): AsyncIterableX<R>;\n\nexport function combineLatestProto<T>(\n  this: AsyncIterableX<T>,\n  ...sources: AsyncIterable<T>[]\n): AsyncIterableX<T[]>;\nexport function combineLatestProto<T, R>(\n  this: AsyncIterableX<T>,\n  project: (values: T[]) => R,\n  ...sources: AsyncIterable<T>[]\n): AsyncIterableX<R>;\nexport function combineLatestProto<T, R>(\n  this: AsyncIterableX<T>,\n  ...args: any[]\n): AsyncIterableX<R> {\n  let [arg1, ...sources] = args;\n  sources = typeof arg1 === 'function' ? [this, ...sources] : (arg1 = this) && args;\n  return combineLatest<T, R>(arg1, ...sources);\n}\n\nAsyncIterableX.prototype.combineLatest = combineLatestProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    combineLatest: typeof combineLatestProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { concatAll } from '../../asynciterable/concatall';\n\n/**\n * @ignore\n */\nexport function concatAllProto<T>(this: AsyncIterableX<AsyncIterable<T>>): AsyncIterableX<T> {\n  return concatAll(this);\n}\n\nAsyncIterableX.prototype.concatAll = concatAllProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    concatAll: typeof concatAllProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { concat } from '../../asynciterable/concat';\n\n/* tslint:disable:max-line-length */\n/**\n * @ignore\n */\nexport function concatProto<T>(this: AsyncIterableX<T>): AsyncIterableX<T>;\n/**\n * @ignore\n */\nexport function concatProto<T, T2>(\n  this: AsyncIterableX<T>,\n  v2: AsyncIterable<T2>\n): AsyncIterableX<T | T2>;\n/**\n * @ignore\n */\nexport function concatProto<T, T2, T3>(\n  this: AsyncIterableX<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>\n): AsyncIterableX<T | T2 | T3>;\n/**\n * @ignore\n */\nexport function concatProto<T, T2, T3, T4>(\n  this: AsyncIterableX<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>\n): AsyncIterableX<T | T2 | T3 | T4>;\n/**\n * @ignore\n */\nexport function concatProto<T, T2, T3, T4, T5>(\n  this: AsyncIterableX<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>\n): AsyncIterable<T | T2 | T3 | T4 | T5>;\n/**\n * @ignore\n */\nexport function concatProto<T, T2, T3, T4, T5, T6>(\n  this: AsyncIterableX<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>,\n  v6: AsyncIterable<T6>\n): AsyncIterable<T | T2 | T3 | T4 | T5 | T6>;\n/* tslint:enable:max-line-length */\n\n/**\n * @ignore\n */\nexport function concatProto<T>(\n  this: AsyncIterableX<T>,\n  ...args: AsyncIterable<T>[]\n): AsyncIterableX<T> {\n  return concat(this, ...args);\n}\n\nAsyncIterableX.prototype.concat = concatProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    concat: typeof concatProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { count } from '../../asynciterable/count';\n\n/**\n * @ignore\n */\nexport function countProto<T>(\n  this: AsyncIterableX<T>,\n  selector?: (value: T) => boolean | Promise<boolean>\n): Promise<number> {\n  return count<T>(this, selector);\n}\n\nAsyncIterableX.prototype.count = countProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    count: typeof countProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { debounce } from '../../asynciterable/debounce';\n\n/**\n * @ignore\n */\nexport function debounceProto<T>(this: AsyncIterableX<T>, time: number): AsyncIterableX<T> {\n  return debounce(this, time);\n}\n\nAsyncIterableX.prototype.debounce = debounceProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    debounce: typeof debounceProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { defaultIfEmpty } from '../../asynciterable/defaultifempty';\n\n/**\n * @ignore\n */\nexport function defaultIfEmptyProto<T>(\n  this: AsyncIterableX<T>,\n  defaultValue: T\n): AsyncIterableX<T> {\n  return defaultIfEmpty<T>(this, defaultValue);\n}\n\nAsyncIterableX.prototype.defaultIfEmpty = defaultIfEmptyProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    defaultIfEmpty: typeof defaultIfEmptyProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { distinct } from '../../asynciterable/distinct';\n\n/**\n * @ignore\n */\nexport function distinctProto<TSource, TKey>(\n  this: AsyncIterableX<TSource>,\n  keySelector?: (value: TSource) => TKey | Promise<TKey>,\n  comparer?: (x: TKey, y: TKey) => boolean | Promise<boolean>\n): AsyncIterableX<TSource> {\n  return distinct(this, keySelector, comparer);\n}\n\nAsyncIterableX.prototype.distinct = distinctProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    distinct: typeof distinctProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { distinctUntilChanged } from '../../asynciterable/distinctuntilchanged';\n\n/**\n * @ignore\n */\nexport function distinctUntilChangedProto<TSource, TKey>(\n  this: AsyncIterableX<TSource>,\n  keySelector?: (value: TSource) => TKey | Promise<TKey>,\n  comparer?: (x: TKey, y: TKey) => boolean | Promise<boolean>\n): AsyncIterableX<TSource> {\n  return distinctUntilChanged(this, keySelector, comparer);\n}\n\nAsyncIterableX.prototype.distinctUntilChanged = distinctUntilChangedProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    distinctUntilChanged: typeof distinctUntilChangedProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { doWhile } from '../../asynciterable/dowhile';\n\n/**\n * @ignore\n */\nexport function doWhileProto<TSource>(\n  this: AsyncIterableX<TSource>,\n  condition: () => boolean | Promise<boolean>\n): AsyncIterableX<TSource> {\n  return doWhile(this, condition);\n}\n\nAsyncIterableX.prototype.doWhile = doWhileProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    doWhile: typeof doWhileProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { elementAt } from '../../asynciterable/elementat';\n\n/**\n * @ignore\n */\nexport function elementAtProto<T>(this: AsyncIterableX<T>, index: number) {\n  return elementAt<T>(this, index);\n}\n\nAsyncIterableX.prototype.elementAt = elementAtProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    elementAt: typeof elementAtProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { endWith } from '../../asynciterable/endwith';\n\n/**\n * @ignore\n */\nexport function endWithProto<T>(this: AsyncIterableX<T>, ...args: T[]) {\n  return endWith(this, ...args);\n}\n\nAsyncIterableX.prototype.endWith = endWithProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    endWith: typeof endWithProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { every } from '../../asynciterable/every';\n\n/**\n * @ignore\n */\nexport function everyProto<T, S extends T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => value is S\n): Promise<boolean>;\nexport function everyProto<T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<boolean>;\nexport function everyProto<T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<boolean> {\n  return every<T>(this, predicate);\n}\n\nAsyncIterableX.prototype.every = everyProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    every: typeof everyProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { except } from '../../asynciterable/except';\n\n/**\n * @ignore\n */\nexport function exceptProto<TSource>(\n  this: AsyncIterableX<TSource>,\n  second: AsyncIterable<TSource>,\n  comparer?: (x: TSource, y: TSource) => boolean | Promise<boolean>\n): AsyncIterableX<TSource> {\n  return except(this, second, comparer);\n}\n\nAsyncIterableX.prototype.except = exceptProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    except: typeof exceptProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { expand } from '../../asynciterable/expand';\n\n/**\n * @ignore\n */\nexport function expandProto<TSource>(\n  this: AsyncIterableX<TSource>,\n  selector: (value: TSource) => AsyncIterable<TSource> | Promise<AsyncIterable<TSource>>\n) {\n  return expand(this, selector);\n}\n\nAsyncIterableX.prototype.expand = expandProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    expand: typeof expandProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { filter } from '../../asynciterable/filter';\n\n/**\n * @ignore\n */\n\nexport function filterProto<T, S extends T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => value is S,\n  thisArg?: any\n): AsyncIterableX<S>;\nexport function filterProto<TSource>(\n  this: AsyncIterableX<TSource>,\n  predicate: (value: TSource, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): AsyncIterableX<TSource>;\nexport function filterProto<TSource>(\n  this: AsyncIterableX<TSource>,\n  predicate: (value: TSource, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): AsyncIterableX<TSource> {\n  return filter<TSource>(this, predicate, thisArg);\n}\n\nAsyncIterableX.prototype.filter = filterProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    filter: typeof filterProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { _finally as _finallyProto } from '../../asynciterable/finally';\n\n/**\n * @ignore\n */\nexport function finallyProto<TSource>(\n  this: AsyncIterableX<TSource>,\n  action: () => any | Promise<any>\n) {\n  return _finallyProto(this, action);\n}\n\nAsyncIterableX.prototype.finally = finallyProto;\n\nexport declare namespace asynciterable {\n  let _finally: typeof _finallyProto;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    finally: typeof finallyProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { findIndex } from '../../asynciterable/findindex';\n\n/**\n * @ignore\n */\nexport function findIndexProto<T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): Promise<number> {\n  return findIndex(this, predicate, thisArg);\n}\n\nAsyncIterableX.prototype.findIndex = findIndexProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    findIndex: typeof findIndexProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { find } from '../../asynciterable/find';\n\n/**\n * @ignore\n */\n\nexport function findProto<T, S extends T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => value is S,\n  thisArg?: any\n): Promise<S | undefined>;\nexport function findProto<T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): Promise<T | undefined>;\nexport function findProto<T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): Promise<T | undefined> {\n  return find(this, predicate, thisArg);\n}\n\nAsyncIterableX.prototype.find = findProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    find: typeof findProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { first } from '../../asynciterable/first';\n\n/**\n * @ignore\n */\n\nexport function firstProto<T, S extends T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => value is S\n): Promise<S | undefined>;\nexport function firstProto<T>(\n  this: AsyncIterableX<T>,\n  predicate?: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<T | undefined>;\nexport function firstProto<T>(\n  this: AsyncIterableX<T>,\n  predicate?: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<T | undefined> {\n  return first(this, predicate);\n}\n\nAsyncIterableX.prototype.first = firstProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    first: typeof firstProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { flatMap } from '../../asynciterable/flatmap';\n\n/**\n * @ignore\n */\nexport function flatMapProto<TSource, TResult>(\n  this: AsyncIterableX<TSource>,\n  selector: (value: TSource) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>,\n  thisArg?: any\n): AsyncIterableX<TResult> {\n  return flatMap<TSource, TResult>(this, selector, thisArg);\n}\n\nAsyncIterableX.prototype.flatMap = flatMapProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    flatMap: typeof flatMapProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { flatten } from '../../asynciterable/flatten';\n\n/**\n * @ignore\n */\nexport function flattenProto<T>(this: AsyncIterableX<T>, depth?: number): AsyncIterableX<T> {\n  return flatten(this, depth);\n}\n\nAsyncIterableX.prototype.flatten = flattenProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    flatten: typeof flattenProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { forkJoin } from '../../asynciterable/forkjoin';\n\n/**\n * @ignore\n */\n\nexport function forkJoinProto<T, T2>(\n  this: AsyncIterableX<T>,\n  source2: AsyncIterable<T2>\n): Promise<[T, T2] | undefined>;\nexport function forkJoinProto<T, T2, T3>(\n  this: AsyncIterableX<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): Promise<[T, T2, T3] | undefined>;\nexport function forkJoinProto<T, T2, T3, T4>(\n  this: AsyncIterableX<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): Promise<[T, T2, T3, T4] | undefined>;\nexport function forkJoinProto<T, T2, T3, T4, T5>(\n  this: AsyncIterableX<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): Promise<[T, T2, T3, T4, T5] | undefined>;\nexport function forkJoinProto<T, T2, T3, T4, T5, T6>(\n  this: AsyncIterableX<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): Promise<[T, T2, T3, T4, T5, T6] | undefined>;\n\nexport function forkJoinProto<T, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T]) => R\n): Promise<R>;\nexport function forkJoinProto<T, T2, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T, T2]) => R,\n  source2: AsyncIterable<T2>\n): Promise<R | undefined>;\nexport function forkJoinProto<T, T2, T3, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T, T2, T3]) => R,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): Promise<R | undefined>;\nexport function forkJoinProto<T, T2, T3, T4, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T, T2, T3, T4]) => R,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): Promise<R | undefined>;\nexport function forkJoinProto<T, T2, T3, T4, T5, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T, T2, T3, T4, T5]) => R,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): Promise<R | undefined>;\nexport function forkJoinProto<T, T2, T3, T4, T5, T6, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T, T2, T3, T4, T5, T6]) => R,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): Promise<R | undefined>;\n\nexport function forkJoinProto<T>(\n  this: AsyncIterableX<T>,\n  ...sources: AsyncIterable<T>[]\n): Promise<T[] | undefined>;\nexport function forkJoinProto<T, R>(\n  this: AsyncIterableX<T>,\n  project: (values: T[]) => R,\n  ...sources: AsyncIterable<T>[]\n): Promise<R | undefined>;\n/* tslint:enable:max-line-length */\nexport function forkJoinProto<T, R>(\n  this: AsyncIterableX<T>,\n  ...args: any[]\n): Promise<R | undefined> {\n  let [arg1, ...sources] = args;\n  sources = typeof arg1 === 'function' ? [this, ...sources] : (arg1 = this) && args;\n  return forkJoin<T, R>(arg1, ...sources);\n}\n\nAsyncIterableX.prototype.forkJoin = forkJoinProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    forkJoin: typeof forkJoinProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport {\n  groupBy,\n  groupByResultIdentityAsync,\n  GroupedAsyncIterable\n} from '../../asynciterable/groupby';\nimport { identityAsync } from '../../internal/identity';\n\nexport function groupByProto<TSource, TKey>(\n  this: AsyncIterableX<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>\n): AsyncIterableX<GroupedAsyncIterable<TKey, TSource>>;\nexport function groupByProto<TSource, TKey, TValue>(\n  this: AsyncIterableX<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (value: TSource) => TValue | Promise<TValue>\n): AsyncIterableX<GroupedAsyncIterable<TKey, TValue>>;\nexport function groupByProto<TSource, TKey, TValue, TResult>(\n  this: AsyncIterableX<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (value: TSource) => TValue | Promise<TValue>,\n  resultSelector?: (key: TKey, values: Iterable<TValue>) => TResult | Promise<TResult>\n): AsyncIterableX<TResult>;\n/**\n * @ignore\n */\nexport function groupByProto<TSource, TKey, TValue, TResult>(\n  this: AsyncIterableX<TSource>,\n  keySelector: (value: TSource) => TKey | Promise<TKey>,\n  elementSelector: (value: TSource) => TValue | Promise<TValue> = identityAsync,\n  resultSelector: (\n    key: TKey,\n    values: Iterable<TValue>\n  ) => TResult | Promise<TResult> = groupByResultIdentityAsync\n): AsyncIterableX<TResult> {\n  return groupBy<TSource, TKey, TValue, TResult>(\n    this,\n    keySelector,\n    elementSelector,\n    resultSelector\n  );\n}\n\nAsyncIterableX.prototype.groupBy = groupByProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    groupBy: typeof groupByProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { groupJoin } from '../../asynciterable/groupjoin';\n\n/**\n * @ignore\n */\nexport function groupJoinProto<TOuter, TInner, TKey, TResult>(\n  this: AsyncIterableX<TOuter>,\n  inner: AsyncIterable<TInner>,\n  outerSelector: (value: TOuter) => TKey | Promise<TKey>,\n  innerSelector: (value: TInner) => TKey | Promise<TKey>,\n  resultSelector: (outer: TOuter, inner: AsyncIterable<TInner>) => TResult | Promise<TResult>\n): AsyncIterableX<TResult> {\n  return groupJoin(this, inner, outerSelector, innerSelector, resultSelector);\n}\n\nAsyncIterableX.prototype.groupJoin = groupJoinProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    groupJoin: typeof groupJoinProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { ignoreElements } from '../../asynciterable/ignoreelements';\n\n/**\n * @ignore\n */\nexport function ignoreElementsProto<T>(this: AsyncIterableX<T>): AsyncIterableX<T> {\n  return ignoreElements(this);\n}\n\nAsyncIterableX.prototype.ignoreElements = ignoreElementsProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    ignoreElements: typeof ignoreElementsProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { includes } from '../../asynciterable/includes';\n\n/**\n * @ignore\n */\nexport function includesProto<T>(\n  this: AsyncIterableX<T>,\n  searchElement: T,\n  fromIndex: number\n): Promise<boolean> {\n  return includes(this, searchElement, fromIndex);\n}\n\nAsyncIterableX.prototype.includes = includesProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    includes: typeof includesProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { innerJoin } from '../../asynciterable/innerjoin';\n\n/**\n * @ignore\n */\nexport function innerJoinProto<TOuter, TInner, TKey, TResult>(\n  this: AsyncIterableX<TOuter>,\n  inner: AsyncIterable<TInner>,\n  outerSelector: (value: TOuter) => TKey | Promise<TKey>,\n  innerSelector: (value: TInner) => TKey | Promise<TKey>,\n  resultSelector: (outer: TOuter, inner: TInner) => TResult | Promise<TResult>\n): AsyncIterableX<TResult> {\n  return innerJoin(this, inner, outerSelector, innerSelector, resultSelector);\n}\n\nAsyncIterableX.prototype.innerJoin = innerJoinProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    innerJoin: typeof innerJoinProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { intersect } from '../../asynciterable/intersect';\n\n/**\n * @ignore\n */\nexport function intersectProto<T>(\n  this: AsyncIterableX<T>,\n  second: AsyncIterable<T>,\n  comparer?: (x: T, y: T) => boolean | Promise<boolean>\n) {\n  return intersect(this, second, comparer);\n}\n\nAsyncIterableX.prototype.intersect = intersectProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    intersect: typeof intersectProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { isEmpty } from '../../asynciterable/isempty';\n\n/**\n * @ignore\n */\nexport function isEmptyProto<T>(this: AsyncIterableX<T>): Promise<boolean> {\n  return isEmpty(this);\n}\n\nAsyncIterableX.prototype.isEmpty = isEmptyProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    isEmpty: typeof isEmptyProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { last } from '../../asynciterable/last';\n\n/**\n * @ignore\n */\n\nexport function lastProto<T, S extends T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => value is S\n): Promise<S | undefined>;\nexport function lastProto<T>(\n  this: AsyncIterableX<T>,\n  predicate?: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<T | undefined>;\nexport function lastProto<T>(\n  this: AsyncIterableX<T>,\n  predicate?: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<T | undefined> {\n  return last(this, predicate);\n}\n\nAsyncIterableX.prototype.last = lastProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    last: typeof lastProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { map } from '../../asynciterable/map';\n\n/**\n * @ignore\n */\nexport function mapProto<TSource, TResult>(\n  this: AsyncIterableX<TSource>,\n  selector: (value: TSource, index: number) => Promise<TResult> | TResult,\n  thisArg?: any\n): AsyncIterableX<TResult> {\n  return map<TSource, TResult>(this, selector, thisArg);\n}\n\nAsyncIterableX.prototype.map = mapProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    map: typeof mapProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { maxBy } from '../../asynciterable/maxby';\n\n/**\n * @ignore\n */\nexport function maxByProto<TSource, TKey>(\n  this: AsyncIterableX<TSource>,\n  keySelector: (x: TSource) => TKey | Promise<TKey>,\n  comparer?: (x: TKey, y: TKey) => number | Promise<number>\n): AsyncIterableX<TSource> {\n  return maxBy(this, keySelector, comparer);\n}\n\nAsyncIterableX.prototype.maxBy = maxByProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    maxBy: typeof maxByProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { max } from '../../asynciterable/max';\nimport { identityAsync } from '../../internal/identity';\n\nexport function maxProto(\n  this: AsyncIterableX<number>,\n  selector?: (x: number) => number\n): Promise<number>;\nexport function maxProto<T>(this: AsyncIterableX<T>, selector: (x: T) => number): Promise<number>;\n/**\n * @ignore\n */\nexport function maxProto(\n  this: AsyncIterableX<any>,\n  selector: (x: any) => number | Promise<number> = identityAsync\n): Promise<number> {\n  return max(this, selector);\n}\n\nAsyncIterableX.prototype.max = maxProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    max: typeof maxProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { memoize } from '../../asynciterable/memoize';\n\nexport function memoizeProto<TSource>(\n  this: AsyncIterableX<TSource>,\n  readerCount?: number\n): AsyncIterableX<TSource>;\nexport function memoizeProto<TSource, TResult>(\n  this: AsyncIterableX<TSource>,\n  readerCount?: number,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): AsyncIterableX<TResult>;\n/**\n * @ignore\n */\nexport function memoizeProto<TSource, TResult = TSource>(\n  this: AsyncIterableX<TSource>,\n  readerCount: number = -1,\n  selector?: (value: AsyncIterable<TSource>) => AsyncIterable<TResult>\n): AsyncIterableX<TSource | TResult> {\n  return memoize(this, readerCount, selector);\n}\n\nAsyncIterableX.prototype.memoize = memoizeProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    memoize: typeof memoizeProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { mergeAll } from '../../asynciterable/mergeall';\n\n/**\n * @ignore\n */\nexport function mergeAllProto<T>(this: AsyncIterableX<AsyncIterable<T>>): AsyncIterableX<T> {\n  return mergeAll(this);\n}\n\nAsyncIterableX.prototype.mergeAll = mergeAllProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    mergeAll: typeof mergeAllProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { merge } from '../../asynciterable/merge';\n\n/* tslint:disable:max-line-length */\n/**\n * @ignore\n */\nexport function mergeProto<T>(this: AsyncIterableX<T>): AsyncIterableX<T>;\n/**\n * @ignore\n */\nexport function mergeProto<T, T2>(\n  this: AsyncIterableX<T>,\n  v2: AsyncIterable<T2>\n): AsyncIterableX<T | T2>;\n/**\n * @ignore\n */\nexport function mergeProto<T, T2, T3>(\n  this: AsyncIterableX<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>\n): AsyncIterableX<T | T2 | T3>;\n/**\n * @ignore\n */\nexport function mergeProto<T, T2, T3, T4>(\n  this: AsyncIterableX<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>\n): AsyncIterableX<T | T2 | T3 | T4>;\n/**\n * @ignore\n */\nexport function mergeProto<T, T2, T3, T4, T5>(\n  this: AsyncIterableX<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>\n): AsyncIterable<T | T2 | T3 | T4 | T5>;\n/**\n * @ignore\n */\nexport function mergeProto<T, T2, T3, T4, T5, T6>(\n  this: AsyncIterableX<T>,\n  v2: AsyncIterable<T2>,\n  v3: AsyncIterable<T3>,\n  v4: AsyncIterable<T4>,\n  v5: AsyncIterable<T5>,\n  v6: AsyncIterable<T6>\n): AsyncIterable<T | T2 | T3 | T4 | T5 | T6>;\n/* tslint:enable:max-line-length */\n\n/**\n * @ignore\n */\nexport function mergeProto<T>(\n  this: AsyncIterableX<T>,\n  ...args: AsyncIterable<T>[]\n): AsyncIterableX<T> {\n  return merge(this, ...args);\n}\n\nAsyncIterableX.prototype.merge = mergeProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    merge: typeof mergeProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { minBy } from '../../asynciterable/minby';\n\n/**\n * @ignore\n */\nexport function minByProto<TSource, TKey>(\n  this: AsyncIterableX<TSource>,\n  keySelector: (x: TSource) => TKey | Promise<TKey>,\n  comparer?: (x: TKey, y: TKey) => number | Promise<number>\n): AsyncIterableX<TSource> {\n  return minBy(this, keySelector, comparer);\n}\n\nAsyncIterableX.prototype.minBy = minByProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    minBy: typeof minByProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { min } from '../../asynciterable/min';\nimport { identityAsync } from '../../internal/identity';\n\nexport function minProto(\n  this: AsyncIterableX<number>,\n  selector?: (x: number) => number | Promise<number>\n): Promise<number>;\nexport function minProto<T>(\n  this: AsyncIterableX<T>,\n  selector: (x: T) => number | Promise<number>\n): Promise<number>;\n/**\n * @ignore\n */\nexport function minProto(\n  this: AsyncIterableX<any>,\n  selector: (x: any) => number | Promise<number> = identityAsync\n): Promise<number> {\n  return min(this, selector);\n}\n\nAsyncIterableX.prototype.min = minProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    min: typeof minProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { onErrorResumeNext } from '../../asynciterable/onerrorresumenext';\n\n/**\n * @ignore\n */\nexport function onErrorResumeNextProto<TSource>(\n  this: AsyncIterableX<TSource>,\n  ...args: AsyncIterable<TSource>[]\n): AsyncIterableX<TSource> {\n  return onErrorResumeNext(this, ...args);\n}\n\nAsyncIterableX.prototype.onErrorResumeNext = onErrorResumeNextProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    onErrorResumeNext: typeof onErrorResumeNextProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { orderBy, orderByDescending, OrderedAsyncIterableX } from '../../asynciterable/orderby';\nimport {\n  thenBy as _thenBy,\n  thenByDescending as _thenByDescending\n} from '../../asynciterable/orderby';\n\n/**\n * @ignore\n */\nexport function orderByProto<TKey, TSource>(\n  this: AsyncIterableX<TSource>,\n  keySelector: (item: TSource) => TKey,\n  comparer?: (fst: TKey, snd: TKey) => number\n): OrderedAsyncIterableX<TKey, TSource> {\n  return orderBy<TKey, TSource>(this, keySelector, comparer);\n}\n\n/**\n * @ignore\n */\nexport function orderByDescendingProto<TKey, TSource>(\n  this: AsyncIterableX<TSource>,\n  keySelector: (item: TSource) => TKey,\n  comparer?: (fst: TKey, snd: TKey) => number\n): OrderedAsyncIterableX<TKey, TSource> {\n  return orderByDescending<TKey, TSource>(this, keySelector, comparer);\n}\n\nAsyncIterableX.prototype.orderBy = orderByProto;\nAsyncIterableX.prototype.orderByDescending = orderByDescendingProto;\n\nexport declare namespace asynciterable {\n  let thenBy: typeof _thenBy;\n  let thenByDescending: typeof _thenByDescending;\n}\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    orderBy: typeof orderByProto;\n    orderByDescending: typeof orderByDescendingProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { pairwise } from '../../asynciterable/pairwise';\n\n/**\n * @ignore\n */\nexport function pairwiseProto<TSource>(this: AsyncIterableX<TSource>): AsyncIterableX<TSource[]> {\n  return pairwise(this);\n}\n\nAsyncIterableX.prototype.pairwise = pairwiseProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    pairwise: typeof pairwiseProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { partition } from '../../asynciterable/partition';\n\n/**\n * @ignore\n */\n\nexport function partitionProto<T, S extends T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => value is S,\n  thisArg?: any\n): AsyncIterableX<S>[];\nexport function partitionProto<T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): AsyncIterableX<T>[];\nexport function partitionProto<T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>,\n  thisArg?: any\n): AsyncIterableX<T>[] {\n  return partition<T>(this, predicate, thisArg);\n}\n\nAsyncIterableX.prototype.partition = partitionProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    partition: typeof partitionProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { pluck } from '../../asynciterable/pluck';\n\n/**\n * @ignore\n */\nexport function pluckProto<TSource, TResult>(\n  this: AsyncIterableX<TSource>,\n  ...args: string[]\n): AsyncIterableX<TResult> {\n  return pluck<TSource, TResult>(this, ...args);\n}\n\nAsyncIterableX.prototype.pluck = pluckProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    pluck: typeof pluckProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { reduceRight } from '../../asynciterable/reduceright';\n\nexport async function reduceRightProto<T, R = T>(\n  this: AsyncIterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: never[]\n): Promise<R>;\nexport async function reduceRightProto<T, R = T>(\n  this: AsyncIterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: R\n): Promise<R>;\n/**\n * @ignore\n */\nexport async function reduceRightProto<T, R = T>(\n  this: AsyncIterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  ...seed: R[]\n): Promise<R> {\n  return reduceRight(this, accumulator, ...seed);\n}\n\nAsyncIterableX.prototype.reduceRight = reduceRightProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    reduceRight: typeof reduceRightProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { reduce } from '../../asynciterable/reduce';\n\nexport async function reduceProto<T, R = T>(\n  this: AsyncIterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: never[]\n): Promise<R>;\nexport async function reduceProto<T, R = T>(\n  this: AsyncIterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: R\n): Promise<R>;\n/**\n * @ignore\n */\nexport async function reduceProto<T, R = T>(\n  this: AsyncIterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  ...seed: R[]\n): Promise<R> {\n  return reduce(this, accumulator, ...seed);\n}\n\nAsyncIterableX.prototype.reduce = reduceProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    reduce: typeof reduceProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { repeat } from '../../asynciterable/repeat';\n\n/**\n * @ignore\n */\nexport function repeatProto<TSource>(\n  this: AsyncIterableX<TSource>,\n  count: number = -1\n): AsyncIterableX<TSource> {\n  return repeat(this, count);\n}\n\nAsyncIterableX.prototype.repeat = repeatProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    repeat: typeof repeatProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { retry } from '../../asynciterable/retry';\n\n/**\n * @ignore\n */\nexport function retryProto<TSource>(\n  this: AsyncIterableX<TSource>,\n  count: number = -1\n): AsyncIterableX<TSource> {\n  return retry(this, count);\n}\n\nAsyncIterableX.prototype.retry = retryProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    retry: typeof retryProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { reverse } from '../../asynciterable/reverse';\n\n/**\n * @ignore\n */\nexport function reverseProto<TSource>(this: AsyncIterableX<TSource>): AsyncIterableX<TSource> {\n  return reverse(this);\n}\n\nAsyncIterableX.prototype.reverse = reverseProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    reverse: typeof reverseProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { scanRight } from '../../asynciterable/scanright';\n\nexport function scanRightProto<T, R = T>(\n  this: AsyncIterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: never[]\n): AsyncIterableX<R>;\nexport function scanRightProto<T, R = T>(\n  this: AsyncIterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  seed?: R\n): AsyncIterableX<R>;\n/**\n * @ignore\n */\nexport function scanRightProto<T, R = T>(\n  this: AsyncIterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R,\n  ...seed: R[]\n): AsyncIterableX<R> {\n  return scanRight(this, accumulator, ...seed);\n}\n\nAsyncIterableX.prototype.scanRight = scanRightProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    scanRight: typeof scanRightProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { scan } from '../../asynciterable/scan';\n\nexport function scanProto<T, R = T>(\n  this: AsyncIterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: never[]\n): AsyncIterableX<R>;\nexport function scanProto<T, R = T>(\n  this: AsyncIterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  seed?: R\n): AsyncIterableX<R>;\n/**\n * @ignore\n */\nexport function scanProto<T, R = T>(\n  this: AsyncIterableX<T>,\n  accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R | Promise<R>,\n  ...seed: R[]\n): AsyncIterableX<R> {\n  return scan(this, accumulator, ...seed);\n}\n\nAsyncIterableX.prototype.scan = scanProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    scan: typeof scanProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { sequenceEqual } from '../../asynciterable/sequenceequal';\nimport { comparerAsync } from '../../internal/comparer';\n\n/**\n * @ignore\n */\nexport function sequenceEqualProto<T>(\n  this: AsyncIterableX<T>,\n  other: AsyncIterable<T>,\n  comparer: (first: T, second: T) => boolean | Promise<boolean> = comparerAsync\n): Promise<boolean> {\n  return sequenceEqual(this, other, comparer);\n}\n\nAsyncIterableX.prototype.sequenceEqual = sequenceEqualProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    sequenceEqual: typeof sequenceEqualProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { share } from '../../asynciterable/share';\n\nexport function shareProto<TSource>(this: AsyncIterableX<TSource>): AsyncIterableX<TSource>;\nexport function shareProto<TSource, TResult>(\n  this: AsyncIterableX<TSource>,\n  selector?: (\n    value: AsyncIterable<TSource>\n  ) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>\n): AsyncIterableX<TResult>;\n/**\n * @ignore\n */\nexport function shareProto<TSource, TResult = TSource>(\n  this: AsyncIterableX<TSource>,\n  selector?: (\n    value: AsyncIterable<TSource>\n  ) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>\n): AsyncIterableX<TSource | TResult> {\n  return share(this, selector);\n}\n\nAsyncIterableX.prototype.share = shareProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    share: typeof shareProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { single } from '../../asynciterable/single';\n\n/**\n * @ignore\n */\n\nexport function singleProto<T, S extends T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => value is S\n): Promise<S | undefined>;\nexport function singleProto<T>(\n  this: AsyncIterableX<T>,\n  predicate?: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<T | undefined>;\nexport function singleProto<T>(\n  this: AsyncIterableX<T>,\n  predicate?: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<T | undefined> {\n  return single(this, predicate);\n}\n\nAsyncIterableX.prototype.single = singleProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    single: typeof singleProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { skipLast } from '../../asynciterable/skiplast';\n\n/**\n * @ignore\n */\nexport function skipLastProto<T>(this: AsyncIterableX<T>, count: number): AsyncIterableX<T> {\n  return skipLast(this, count);\n}\n\nAsyncIterableX.prototype.skipLast = skipLastProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    skipLast: typeof skipLastProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { skip } from '../../asynciterable/skip';\n\n/**\n * @ignore\n */\nexport function skipProto<T>(this: AsyncIterableX<T>, count: number): AsyncIterableX<T> {\n  return skip(this, count);\n}\n\nAsyncIterableX.prototype.skip = skipProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    skip: typeof skipProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { skipUntil } from '../../asynciterable/skipuntil';\n\n/**\n * @ignore\n */\nexport function skipUntilProto<TSource>(\n  this: AsyncIterableX<TSource>,\n  other: () => Promise<any>\n): AsyncIterableX<TSource> {\n  return skipUntil(this, other);\n}\n\nAsyncIterableX.prototype.skipUntil = skipUntilProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    skipUntil: typeof skipUntilProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { skipWhile } from '../../asynciterable/skipwhile';\n\n/**\n * @ignore\n */\n\nexport function skipWhileProto<T, S extends T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => value is S\n): AsyncIterableX<S>;\nexport function skipWhileProto<T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): AsyncIterableX<T>;\nexport function skipWhileProto<T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): AsyncIterableX<T> {\n  return skipWhile(this, predicate);\n}\n\nAsyncIterableX.prototype.skipWhile = skipWhileProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    skipWhile: typeof skipWhileProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { slice } from '../../asynciterable/slice';\n\n/**\n * @ignore\n */\nexport function sliceProto<T>(\n  this: AsyncIterableX<T>,\n  begin: number,\n  end: number\n): AsyncIterableX<T> {\n  return slice(this, begin, end);\n}\n\nAsyncIterableX.prototype.slice = sliceProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    slice: typeof sliceProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { some } from '../../asynciterable/some';\n\n/**\n * @ignore\n */\n\nexport function someProto<T, S extends T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => value is S\n): Promise<boolean>;\nexport function someProto<T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<boolean>;\nexport function someProto<T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): Promise<boolean> {\n  return some(this, predicate);\n}\n\nAsyncIterableX.prototype.some = someProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    some: typeof someProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { startWith } from '../../asynciterable/startwith';\n\n/**\n * @ignore\n */\nexport function startWithProto<T>(this: AsyncIterableX<T>, ...args: T[]) {\n  return startWith(this, ...args);\n}\n\nAsyncIterableX.prototype.startWith = startWithProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    startWith: typeof startWithProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { sum } from '../../asynciterable/sum';\nimport { identityAsync } from '../../internal/identity';\n\nexport function sumProto(\n  this: AsyncIterableX<number>,\n  selector?: (x: number) => number | Promise<number>\n): Promise<number>;\nexport function sumProto<T>(\n  this: AsyncIterableX<T>,\n  selector: (x: T) => number | Promise<number>\n): Promise<number>;\n/**\n * @ignore\n */\nexport function sumProto(\n  this: AsyncIterableX<any>,\n  selector: (x: any) => number | Promise<number> = identityAsync\n): Promise<number> {\n  return sum(this, selector);\n}\n\nAsyncIterableX.prototype.sum = sumProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    sum: typeof sumProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { takeLast } from '../../asynciterable/takelast';\n\n/**\n * @ignore\n */\nexport function takeLastProto<T>(this: AsyncIterableX<T>, count: number): AsyncIterableX<T> {\n  return takeLast(this, count);\n}\n\nAsyncIterableX.prototype.takeLast = takeLastProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    takeLast: typeof takeLastProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { take } from '../../asynciterable/take';\n\n/**\n * @ignore\n */\nexport function takeProto<T>(this: AsyncIterableX<T>, count: number): AsyncIterableX<T> {\n  return take(this, count);\n}\n\nAsyncIterableX.prototype.take = takeProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    take: typeof takeProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { takeUntil } from '../../asynciterable/takeuntil';\n\n/**\n * @ignore\n */\nexport function takeUntilProto<TSource>(\n  this: AsyncIterableX<TSource>,\n  other: () => Promise<any>\n): AsyncIterableX<TSource> {\n  return takeUntil(this, other);\n}\n\nAsyncIterableX.prototype.takeUntil = takeUntilProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    takeUntil: typeof takeUntilProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { takeWhile } from '../../asynciterable/takewhile';\n\n/**\n * @ignore\n */\n\nexport function takeWhileProto<T, S extends T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => value is S\n): AsyncIterableX<S>;\nexport function takeWhileProto<T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): AsyncIterableX<T>;\nexport function takeWhileProto<T>(\n  this: AsyncIterableX<T>,\n  predicate: (value: T, index: number) => boolean | Promise<boolean>\n): AsyncIterableX<T> {\n  return takeWhile(this, predicate);\n}\n\nAsyncIterableX.prototype.takeWhile = takeWhileProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    takeWhile: typeof takeWhileProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { tap } from '../../asynciterable/tap';\nimport { PartialAsyncObserver } from '../../observer';\n\n/** @ignore */\nexport function tapProto<T>(observer: PartialAsyncObserver<T>): AsyncIterableX<T>;\n/** @ignore */\nexport function tapProto<T>(\n  next?: ((value: T) => any) | null,\n  error?: ((err: any) => any) | null,\n  complete?: (() => any) | null\n): AsyncIterableX<T>;\n/** @ignore */\nexport function tapProto<T>(\n  this: AsyncIterableX<T>,\n  observerOrNext?: PartialAsyncObserver<T> | ((value: T) => any) | null,\n  error?: ((err: any) => any) | null,\n  complete?: (() => any) | null\n): AsyncIterableX<T> {\n  return tap(this, observerOrNext as any, error, complete);\n}\n\nAsyncIterableX.prototype.tap = tapProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    tap: typeof tapProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { throttle } from '../../asynciterable/throttle';\n\n/**\n * @ignore\n */\nexport function throttleProto<T>(this: AsyncIterableX<T>, time: number): AsyncIterableX<T> {\n  return throttle(this, time);\n}\n\nAsyncIterableX.prototype.throttle = throttleProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    throttle: typeof throttleProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { toArray } from '../../asynciterable/toarray';\n\n/**\n * @ignore\n */\nexport function toArrayProto<TSource>(this: AsyncIterableX<TSource>): Promise<TSource[]> {\n  return toArray(this);\n}\n\nAsyncIterableX.prototype.toArray = toArrayProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    toArray: typeof toArrayProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { toMap } from '../../asynciterable/tomap';\n\nexport function toMapProto<TSource, TKey>(\n  this: AsyncIterableX<TSource>,\n  keySelector: (item: TSource) => TKey | Promise<TKey>\n): Promise<Map<TKey, TSource>>;\nexport function toMapProto<TSource, TKey, TElement = TSource>(\n  this: AsyncIterableX<TSource>,\n  keySelector: (item: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (item: TSource) => TElement | Promise<TElement>\n): Promise<Map<TKey, TElement>>;\n/**\n * @ignore\n */\nexport function toMapProto<TSource, TKey, TElement = TSource>(\n  this: AsyncIterableX<TSource>,\n  keySelector: (item: TSource) => TKey | Promise<TKey>,\n  elementSelector?: (item: TSource) => TElement | Promise<TElement>\n): Promise<Map<TKey, TElement | TSource>> {\n  return toMap(this, keySelector, elementSelector);\n}\n\nAsyncIterableX.prototype.toMap = toMapProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    toMap: typeof toMapProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { toObservable } from '../../asynciterable/toobservable';\nimport { Observable } from '../../observer';\n\n/**\n * @ignore\n */\nexport function toObservableProto<TSource>(this: AsyncIterableX<TSource>): Observable<TSource> {\n  return toObservable(this);\n}\n\nAsyncIterableX.prototype.toObservable = toObservableProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    toObservable: typeof toObservableProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { toSet } from '../../asynciterable/toset';\n\n/**\n * @ignore\n */\nexport function toSetProto<TSource>(this: AsyncIterableX<TSource>): Promise<Set<TSource>> {\n  return toSet(this);\n}\n\nAsyncIterableX.prototype.toSet = toSetProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    toSet: typeof toSetProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { union } from '../../asynciterable/union';\n\n/**\n * @ignore\n */\nexport function unionProto<T>(\n  this: AsyncIterableX<T>,\n  right: AsyncIterable<T>,\n  comparer?: (x: T, y: T) => boolean | Promise<boolean>\n): AsyncIterableX<T> {\n  return union(this, right, comparer);\n}\n\nAsyncIterableX.prototype.union = unionProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    union: typeof unionProto;\n  }\n}\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { zip } from '../../asynciterable/zip';\n\n/**\n * @ignore\n */\n\nexport function zipProto<T, T2>(\n  this: AsyncIterableX<T>,\n  source2: AsyncIterable<T2>\n): AsyncIterableX<[T, T2]>;\nexport function zipProto<T, T2, T3>(\n  this: AsyncIterableX<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): AsyncIterableX<[T, T2, T3]>;\nexport function zipProto<T, T2, T3, T4>(\n  this: AsyncIterableX<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): AsyncIterableX<[T, T2, T3, T4]>;\nexport function zipProto<T, T2, T3, T4, T5>(\n  this: AsyncIterableX<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): AsyncIterableX<[T, T2, T3, T4, T5]>;\nexport function zipProto<T, T2, T3, T4, T5, T6>(\n  this: AsyncIterableX<T>,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): AsyncIterableX<[T, T2, T3, T4, T5, T6]>;\n\nexport function zipProto<T, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T]) => R\n): AsyncIterableX<R>;\nexport function zipProto<T, T2, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T, T2]) => R,\n  source2: AsyncIterable<T2>\n): AsyncIterableX<R>;\nexport function zipProto<T, T2, T3, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T, T2, T3]) => R,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>\n): AsyncIterableX<R>;\nexport function zipProto<T, T2, T3, T4, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T, T2, T3, T4]) => R,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>\n): AsyncIterableX<R>;\nexport function zipProto<T, T2, T3, T4, T5, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T, T2, T3, T4, T5]) => R,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>\n): AsyncIterableX<R>;\nexport function zipProto<T, T2, T3, T4, T5, T6, R>(\n  this: AsyncIterableX<T>,\n  project: (values: [T, T2, T3, T4, T5, T6]) => R,\n  source2: AsyncIterable<T2>,\n  source3: AsyncIterable<T3>,\n  source4: AsyncIterable<T4>,\n  source5: AsyncIterable<T5>,\n  source6: AsyncIterable<T6>\n): AsyncIterableX<R>;\n\nexport function zipProto<T>(\n  this: AsyncIterableX<T>,\n  ...sources: AsyncIterable<T>[]\n): AsyncIterableX<T[]>;\nexport function zipProto<T, R>(\n  this: AsyncIterableX<T>,\n  project: (values: T[]) => R,\n  ...sources: AsyncIterable<T>[]\n): AsyncIterableX<R>;\nexport function zipProto<T, R>(this: AsyncIterableX<T>, ...args: any[]): AsyncIterableX<R> {\n  let [arg1, ...sources] = args;\n  sources = typeof arg1 === 'function' ? [this, ...sources] : (arg1 = this) && args;\n  return zip<T, R>(arg1, ...sources);\n}\n\nAsyncIterableX.prototype.zip = zipProto;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  interface AsyncIterableX<T> {\n    zip: typeof zipProto;\n  }\n}\n","import { AsyncSink } from './asyncsink';\nimport { IterableX } from './iterable/iterablex';\nimport { observable } from './observer';\nimport { AsyncIterableX } from './asynciterable/asynciterablex';\nimport { GroupedIterable } from './iterable/groupby';\nimport { GroupedAsyncIterable } from './asynciterable/groupby';\nexport { OrderedIterableX as OrderedIterable } from './iterable/orderby';\nexport { OrderedIterableBaseX as OrderedIterableBase } from './iterable/orderby';\nexport { OrderedAsyncIterableX as OrderedAsyncIterable } from './asynciterable/orderby';\nexport { OrderedAsyncIterableBaseX as OrderedAsyncIterableBase } from './asynciterable/orderby';\n\nexport { observable as symbolObservable };\nexport { AsyncSink, IterableX as Iterable, AsyncIterableX as AsyncIterable };\n\n// Also export default to accommodate quirks of node's `--experimental-modules` mode\nexport default {\n  AsyncSink,\n  Iterable: IterableX,\n  AsyncIterable: AsyncIterableX,\n  // prettier-ignore\n  'symbolObservable': observable\n};\n\nexport type GroupedIterable<TKey, TValue> = GroupedIterable<TKey, TValue>;\nexport type GroupedAsyncIterable<TKey, TValue> = GroupedAsyncIterable<TKey, TValue>;\n\n// iterable statics\n/* tslint:disable:no-use-before-declare */\nimport './add/iterable/case';\nimport './add/iterable/catch';\nimport './add/iterable/concat';\nimport './add/iterable/create';\nimport './add/iterable/defer';\nimport './add/iterable/empty';\nimport './add/iterable/for';\nimport './add/iterable/generate';\nimport './add/iterable/if';\nimport './add/iterable/ofentries';\nimport './add/iterable/ofkeys';\nimport './add/iterable/ofvalues';\nimport './add/iterable/onerrorresumenext';\nimport './add/iterable/range';\nimport './add/iterable/repeat';\nimport './add/iterable/throw';\nimport './add/iterable/while';\nimport './add/iterable/zip';\n\n// // iterable operators\nimport './add/iterable-operators/average';\nimport './add/iterable-operators/buffer';\nimport './add/iterable-operators/catch';\nimport './add/iterable-operators/catchwith';\nimport './add/iterable-operators/chain';\nimport './add/iterable-operators/concatall';\nimport './add/iterable-operators/concat';\nimport './add/iterable-operators/count';\nimport './add/iterable-operators/defaultifempty';\nimport './add/iterable-operators/distinct';\nimport './add/iterable-operators/distinctuntilchanged';\nimport './add/iterable-operators/dowhile';\nimport './add/iterable-operators/elementat';\nimport './add/iterable-operators/endwith';\nimport './add/iterable-operators/every';\nimport './add/iterable-operators/except';\nimport './add/iterable-operators/expand';\nimport './add/iterable-operators/filter';\nimport './add/iterable-operators/finally';\nimport './add/iterable-operators/findindex';\nimport './add/iterable-operators/find';\nimport './add/iterable-operators/first';\nimport './add/iterable-operators/flatmap';\nimport './add/iterable-operators/flatten';\nimport './add/iterable-operators/groupby';\nimport './add/iterable-operators/groupjoin';\nimport './add/iterable-operators/ignoreelements';\nimport './add/iterable-operators/includes';\nimport './add/iterable-operators/innerjoin';\nimport './add/iterable-operators/intersect';\nimport './add/iterable-operators/isempty';\nimport './add/iterable-operators/last';\nimport './add/iterable-operators/map';\nimport './add/iterable-operators/maxby';\nimport './add/iterable-operators/max';\nimport './add/iterable-operators/memoize';\nimport './add/iterable-operators/minby';\nimport './add/iterable-operators/min';\nimport './add/iterable-operators/onerrorresumenext';\nimport './add/iterable-operators/orderby';\nimport './add/iterable-operators/pairwise';\nimport './add/iterable-operators/partition';\nimport './add/iterable-operators/pluck';\nimport './add/iterable-operators/publish';\nimport './add/iterable-operators/reduceright';\nimport './add/iterable-operators/reduce';\nimport './add/iterable-operators/repeat';\nimport './add/iterable-operators/retry';\nimport './add/iterable-operators/reverse';\nimport './add/iterable-operators/scanright';\nimport './add/iterable-operators/scan';\nimport './add/iterable-operators/sequenceequal';\nimport './add/iterable-operators/share';\nimport './add/iterable-operators/single';\nimport './add/iterable-operators/skiplast';\nimport './add/iterable-operators/skip';\nimport './add/iterable-operators/skipwhile';\nimport './add/iterable-operators/slice';\nimport './add/iterable-operators/some';\nimport './add/iterable-operators/startwith';\nimport './add/iterable-operators/sum';\nimport './add/iterable-operators/takelast';\nimport './add/iterable-operators/take';\nimport './add/iterable-operators/takewhile';\nimport './add/iterable-operators/tap';\nimport './add/iterable-operators/toarray';\nimport './add/iterable-operators/tomap';\nimport './add/iterable-operators/toset';\nimport './add/iterable-operators/union';\nimport './add/iterable-operators/zip';\n\n// async iterable statics\nimport './add/asynciterable/asyncifyerrback';\nimport './add/asynciterable/asyncify';\nimport './add/asynciterable/case';\nimport './add/asynciterable/catch';\nimport './add/asynciterable/combinelatest';\nimport './add/asynciterable/concat';\nimport './add/asynciterable/create';\nimport './add/asynciterable/defer';\nimport './add/asynciterable/empty';\nimport './add/asynciterable/forkjoin';\nimport './add/asynciterable/for';\nimport './add/asynciterable/fromeventpattern';\nimport './add/asynciterable/fromevent';\nimport './add/asynciterable/generatetime';\nimport './add/asynciterable/generate';\nimport './add/asynciterable/if';\nimport './add/asynciterable/merge';\nimport './add/asynciterable/ofentries';\nimport './add/asynciterable/ofkeys';\nimport './add/asynciterable/onerrorresumenext';\nimport './add/asynciterable/race';\nimport './add/asynciterable/range';\nimport './add/asynciterable/repeat';\nimport './add/asynciterable/throw';\nimport './add/asynciterable/while';\nimport './add/asynciterable/zip';\n\n// async iterable operators\nimport './add/asynciterable-operators/average';\nimport './add/asynciterable-operators/batch';\nimport './add/asynciterable-operators/buffer';\nimport './add/asynciterable-operators/catch';\nimport './add/asynciterable-operators/catchwith';\nimport './add/asynciterable-operators/chain';\nimport './add/asynciterable-operators/combinelatest';\nimport './add/asynciterable-operators/concatall';\nimport './add/asynciterable-operators/concat';\nimport './add/asynciterable-operators/count';\nimport './add/asynciterable-operators/debounce';\nimport './add/asynciterable-operators/defaultifempty';\nimport './add/asynciterable-operators/distinct';\nimport './add/asynciterable-operators/distinctuntilchanged';\nimport './add/asynciterable-operators/dowhile';\nimport './add/asynciterable-operators/elementat';\nimport './add/asynciterable-operators/endwith';\nimport './add/asynciterable-operators/every';\nimport './add/asynciterable-operators/except';\nimport './add/asynciterable-operators/expand';\nimport './add/asynciterable-operators/filter';\nimport './add/asynciterable-operators/finally';\nimport './add/asynciterable-operators/findindex';\nimport './add/asynciterable-operators/find';\nimport './add/asynciterable-operators/first';\nimport './add/asynciterable-operators/flatmap';\nimport './add/asynciterable-operators/flatten';\nimport './add/asynciterable-operators/forkjoin';\nimport './add/asynciterable-operators/groupby';\nimport './add/asynciterable-operators/groupjoin';\nimport './add/asynciterable-operators/ignoreelements';\nimport './add/asynciterable-operators/includes';\nimport './add/asynciterable-operators/innerjoin';\nimport './add/asynciterable-operators/intersect';\nimport './add/asynciterable-operators/isempty';\nimport './add/asynciterable-operators/last';\nimport './add/asynciterable-operators/map';\nimport './add/asynciterable-operators/maxby';\nimport './add/asynciterable-operators/max';\nimport './add/asynciterable-operators/memoize';\nimport './add/asynciterable-operators/mergeall';\nimport './add/asynciterable-operators/merge';\nimport './add/asynciterable-operators/minby';\nimport './add/asynciterable-operators/min';\nimport './add/asynciterable-operators/onerrorresumenext';\nimport './add/asynciterable-operators/orderby';\nimport './add/asynciterable-operators/pairwise';\nimport './add/asynciterable-operators/partition';\nimport './add/asynciterable-operators/pluck';\nimport './add/asynciterable-operators/publish';\nimport './add/asynciterable-operators/reduceright';\nimport './add/asynciterable-operators/reduce';\nimport './add/asynciterable-operators/repeat';\nimport './add/asynciterable-operators/retry';\nimport './add/asynciterable-operators/reverse';\nimport './add/asynciterable-operators/scanright';\nimport './add/asynciterable-operators/scan';\nimport './add/asynciterable-operators/sequenceequal';\nimport './add/asynciterable-operators/share';\nimport './add/asynciterable-operators/single';\nimport './add/asynciterable-operators/skiplast';\nimport './add/asynciterable-operators/skip';\nimport './add/asynciterable-operators/skipuntil';\nimport './add/asynciterable-operators/skipwhile';\nimport './add/asynciterable-operators/slice';\nimport './add/asynciterable-operators/some';\nimport './add/asynciterable-operators/startwith';\nimport './add/asynciterable-operators/sum';\nimport './add/asynciterable-operators/takelast';\nimport './add/asynciterable-operators/take';\nimport './add/asynciterable-operators/takeuntil';\nimport './add/asynciterable-operators/takewhile';\nimport './add/asynciterable-operators/tap';\nimport './add/asynciterable-operators/throttle';\nimport './add/asynciterable-operators/toarray';\nimport './add/asynciterable-operators/tomap';\nimport './add/asynciterable-operators/toobservable';\nimport './add/asynciterable-operators/toset';\nimport './add/asynciterable-operators/union';\nimport './add/asynciterable-operators/zip';\n","import { AsyncIterableX } from '../../asynciterable/asynciterablex';\nimport { fromDOMStream as fromDOMStreamStatic } from '../../asynciterable/fromdomstream';\n\n/** @nocollapse */\nAsyncIterableX.fromDOMStream = fromDOMStreamStatic;\n\ndeclare module '../../asynciterable/asynciterablex' {\n  namespace AsyncIterableX {\n    export let fromDOMStream: typeof fromDOMStreamStatic;\n  }\n}\n","import * as iterableX from './iterable/index';\nimport * as iterableXPipe from './iterable/pipe/index';\nimport * as asynciterableX from './asynciterable/index';\nimport * as asynciterableXPipe from './asynciterable/pipe/index';\n\nexport { iterableX as iterable };\nexport { iterableXPipe as iterablePipe };\nexport { asynciterableX as asynciterable };\nexport { asynciterableXPipe as asynciterablePipe };\n\n// Manually re-export because closure-compiler doesn't support `export * from X` syntax yet\nexport { default } from './Ix.dom';\nexport { OrderedIterable } from './Ix.dom';\nexport { OrderedIterableBase } from './Ix.dom';\nexport { OrderedAsyncIterable } from './Ix.dom';\nexport { OrderedAsyncIterableBase } from './Ix.dom';\nexport { AsyncSink, Iterable, AsyncIterable } from './Ix.dom';\n"],"sourceRoot":""}